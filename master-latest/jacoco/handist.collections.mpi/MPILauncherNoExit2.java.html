<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MPILauncherNoExit2.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.mpi</a> &gt; <span class="el_source">MPILauncherNoExit2.java</span></div><h1>MPILauncherNoExit2.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2020 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under 
 * the terms of the Eclipse Public License 1.0 which accompanies this 
 * distribution, and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 *******************************************************************************/
package handist.collections.mpi;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.security.Permission;
import java.util.List;

import apgas.Configuration;
import apgas.GlobalRuntime;
import apgas.impl.Config;
import apgas.impl.Launcher;
import mpi.MPI;
import mpi.MPIException;

/**
 * The {@link MPILauncherNoExit2} class implements a launcher for the apgas runtime using MPI. Programs should be run in
 * the following way:
 * &lt;p&gt;
 * &lt;em&gt;mpirun -np &amp;lt;nb hosts&amp;gt; -host &amp;lt; comma-seperated list of hosts&amp;gt; 
 * java -cp &amp;lt;classpath&amp;gt; apgas.mpi.MPILauncher &amp;lt;main class to launch&amp;gt;
 * &amp;lt;arguments for said class&amp;gt;&lt;/em&gt;
 * &lt;p&gt;
 * For instance, to launch the HelloWorld example with message &quot;Hello&quot; on 4 servers, a solution would be:
 * &lt;p&gt;
 * &lt;em&gt;mpirun -np 4 -host piccolo04,piccolo05,piccolo06,piccolo07 java -cp
 * apgas.jar:apgasExamples.jar:kryo.jar:mpi.jar:reflectasm.jar:hazelcast.jar:minlog.jar:objenesis.jar
 * apgas.mpi.MPILauncher apgas.examples.HelloWorld Hello&lt;/em&gt;
 *
 * @author Toshiyuki
 */
final public class MPILauncherNoExit2 implements Launcher {

  /**
   * Exception thrown when the application given as parameter calls {@link System#exit(int)} rather than exiting the
   * whole application.
   */
  protected static class ExitException extends SecurityException {

    /** Serial Version UID */
    private static final long serialVersionUID = -5788271742636040872L;
    public final int status;

    public ExitException(int status) {
<span class="nc" id="L59">      super(&quot;The MPI launcher prevented the call to System.exit(&quot; + status + &quot;)&quot;);</span>
<span class="nc" id="L60">      this.status = status;</span>
<span class="nc" id="L61">    }</span>
  }

  /**
   * Security manager that prevents any call to {@link System#exit(int)}.
   * 
   * @author Patrick
   */
  private static class NoExitSecurityManager extends SecurityManager {

    @Override
    public void checkPermission(Permission perm) {
      // allow anything.
<span class="nc" id="L74">    }</span>

    @Override
    public void checkPermission(Permission perm, Object context) {
      // allow anything.
<span class="nc" id="L79">    }</span>

    @Override
    public void checkExit(int status) {
<span class="nc" id="L83">      super.checkExit(status);</span>
<span class="nc" id="L84">      throw new ExitException(status);</span>
    }
  }

  /** Identifier of this place */
  static int commRank;
  /** Number of places in the system */
  static int commSize;

<span class="nc" id="L93">  static boolean finalizeCalled = false;</span>

  /**
   * Set in the main method according to the value set by {@link Configuration#APGAS_VERBOSE_LAUNCHER}
   */
  static boolean verboseLauncher;

  /**
   * Constructs a new {@link MPILauncherNoExit2} instance.
   */
<span class="nc" id="L103">  public MPILauncherNoExit2() {</span>
<span class="nc" id="L104">  }</span>

  /**
   * Launches one process with the given command line at the specified host.
   * &lt;p&gt;
   * Should not be called in practice as every java processes are supposed to be launched using the `mpirun` command.
   * Implementation will print an &quot;Internal error&quot; on the {@link System#err} before calling for the program's
   * termination and exiting with return code -1.
   *
   * @param  command   command line
   * @param  host      host
   * @param  verbose   dumps the executed commands to stderr
   * @return           the process object
   * @throws Exception if launching fails
   */
  @Override
  public Process launch(List&lt;String&gt; command, String host, boolean verbose) throws Exception {

<span class="nc" id="L122">    System.err.println(&quot;[MPILauncher] Internal Error&quot;);</span>
<span class="nc" id="L123">    MPI.Finalize();</span>
<span class="nc" id="L124">    System.exit(-1);</span>

<span class="nc" id="L126">    return null;</span>
  }

  /**
   * Launches n processes with the given command line and host list. The first host of the list is skipped. If the list
   * is incomplete, the last host is repeated.
   *
   * @param  n         number of processes to launch
   * @param  command   command line
   * @param  hosts     host list (not null, not empty, but possibly incomplete)
   * @param  verbose   dumps the executed commands to stderr
   * @throws Exception if launching fails
   */
  @Override
  public void launch(int n, List&lt;String&gt; command, List&lt;String&gt; hosts, boolean verbose) throws Exception {

<span class="nc bnc" id="L142" title="All 2 branches missed.">    if (n + 1 != commSize) {</span>
<span class="nc" id="L143">      System.err.println(</span>
          &quot;[MPILauncher] &quot; + Configuration.APGAS_PLACES + &quot; should be equal to number of MPI processes &quot; + commSize);
<span class="nc" id="L145">      MPI.Finalize();</span>
<span class="nc" id="L146">      System.exit(-1);</span>
    }

<span class="nc" id="L149">    final byte[] baCommand = serializeToByteArray(command.toArray(new String[command.size()]));</span>
<span class="nc" id="L150">    final int[] msglen = new int[1];</span>
<span class="nc" id="L151">    msglen[0] = baCommand.length;</span>
<span class="nc" id="L152">    MPI.COMM_WORLD.Bcast(msglen, 0, 1, MPI.INT, 0);</span>
<span class="nc" id="L153">    MPI.COMM_WORLD.Bcast(baCommand, 0, msglen[0], MPI.BYTE, 0);</span>
<span class="nc" id="L154">  }</span>

  /**
   * Sets up the apgas runtime for it to wait for activities to be spawned on this place.
   *
   * @throws Exception if some problem occurs with the MPI runtime
   */
  static void slave() throws Exception {

<span class="nc" id="L163">    final int[] msglen = new int[1];</span>
<span class="nc" id="L164">    MPI.COMM_WORLD.Bcast(msglen, 0, 1, MPI.INT, 0);</span>
<span class="nc" id="L165">    final byte[] msgbuf = new byte[msglen[0]];</span>
<span class="nc" id="L166">    MPI.COMM_WORLD.Bcast(msgbuf, 0, msglen[0], MPI.BYTE, 0);</span>
<span class="nc" id="L167">    final String[] command = (String[]) deserializeFromByteArray(msgbuf);</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">    for (int i = 1; i &lt; command.length; i++) {</span>
<span class="nc" id="L170">      final String term = command[i];</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">      if (term.startsWith(&quot;-D&quot;)) {</span>
<span class="nc" id="L172">        final String[] kv = term.substring(2).split(&quot;=&quot;, 2);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (verboseLauncher) {</span>
<span class="nc" id="L174">          System.err.println(&quot;[&quot; + commRank + &quot;] setProperty \&quot;&quot; + kv[0] + &quot;\&quot; = \&quot;&quot; + kv[1] + &quot;\&quot;&quot;);</span>
        }

<span class="nc" id="L177">        System.setProperty(kv[0], kv[1]);</span>
      }
    }

<span class="nc" id="L181">    GlobalRuntime.getRuntime();</span>
<span class="nc" id="L182">  }</span>

  /**
   * Shuts down the local process launched using MPI.
   */
  @Override
  public void shutdown() {
<span class="nc bnc" id="L189" title="All 2 branches missed.">    if (verboseLauncher) {</span>
<span class="nc" id="L190">      System.err.println(&quot;[MPILauncherNoExit2] About to call MPI.Finalize on rank&quot; + commRank);</span>
    }
    try {
<span class="nc bnc" id="L193" title="All 2 branches missed.">      if (!finalizeCalled) {</span>
<span class="nc" id="L194">        finalizeCalled = true;</span>
<span class="nc" id="L195">        MPI.Finalize();</span>
      }
<span class="nc" id="L197">    } catch (final MPIException e) {</span>
<span class="nc" id="L198">      System.err.println(&quot;[MPILauncher] Error on Shutdown at rank &quot; + commRank);</span>
<span class="nc" id="L199">      e.printStackTrace();</span>
<span class="nc" id="L200">    }</span>
<span class="nc" id="L201">    System.exit(0);</span>
<span class="nc" id="L202">  }</span>

  /**
   * Checks that all the processes launched are healthy.
   * &lt;p&gt;
   * Current implementation of {@link MPILauncherNoExit2} always returns true.
   *
   * @return true if all subprocesses are healthy
   */
  @Override
  public boolean healthy() {
    // TODO
<span class="nc" id="L214">    return true;</span>
  }

  /**
   * Converts a String to an int array
   *
   * @param  src String to be converted
   * @return     array of integer corresponding to the given parameter
   * @see        #intArrayToString(int[])
   */
  static int[] stringToIntArray(String src) {
<span class="nc" id="L225">    final char[] charArray = src.toCharArray();</span>
<span class="nc" id="L226">    final int[] intArray = new int[charArray.length];</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">    for (int i = 0; i &lt; charArray.length; i++) {</span>
<span class="nc" id="L228">      intArray[i] = charArray[i];</span>
    }
<span class="nc" id="L230">    return intArray;</span>
  }

  /**
   * Converts an int array back into the String it represents
   *
   * @param  src the integer array to be converted back into a String
   * @return     the constructed String
   * @see        #stringToIntArray(String)
   */
  static String intArrayToString(int[] src) {
<span class="nc" id="L241">    final char[] charArray = new char[src.length];</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">    for (int i = 0; i &lt; src.length; i++) {</span>
<span class="nc" id="L243">      charArray[i] = (char) src[i];</span>
    }
<span class="nc" id="L245">    final String str = new String(charArray);</span>
<span class="nc" id="L246">    return str;</span>
  }

  /**
   * Serializer method
   *
   * @param  obj         Object to be serialized
   * @return             array of bytes
   * @throws IOException if an I/O exception occurs
   * @see                #deserializeFromByteArray(byte[])
   */
  static byte[] serializeToByteArray(Serializable obj) throws IOException {
<span class="nc" id="L258">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L259">    final ObjectOutputStream oos = new ObjectOutputStream(baos);</span>
<span class="nc" id="L260">    oos.writeObject(obj);</span>
<span class="nc" id="L261">    return baos.toByteArray();</span>
  }

  /**
   * Deserializer method
   *
   * @param  barray                 byte array input
   * @return                        Object constructed from the input
   * @throws IOException            if an I/O occurs
   * @throws ClassNotFoundException if the class could not be identified
   * @see                           #serializeToByteArray(Serializable)
   */
  static Object deserializeFromByteArray(byte[] barray) throws IOException, ClassNotFoundException {
<span class="nc" id="L274">    final ByteArrayInputStream bais = new ByteArrayInputStream(barray);</span>
<span class="nc" id="L275">    final ObjectInputStream ois = new ObjectInputStream(bais);</span>
<span class="nc" id="L276">    return ois.readObject();</span>
  }

  /**
   * Main method of the MPILauncher class
   * &lt;p&gt;
   * Sets up the APGAS environment using an mpi launcher. Rank 0 of the processes will launch the main method of the
   * class specified as parameter with the arguments specified afterward. Other processes will only setup their apgas
   * environment and wait for incoming activities.
   * &lt;p&gt;
   * This main method takes at least one argument, the fully qualified name of the class whose main method is to be run.
   * Arguments for that class' main need to to follow that first argument.
   *
   * @param  args      Path to the class whose main method is to be run, followed by the arguments of that classe's main
   *                   method.
   * @throws Exception if MPI exception occur
   */
  public static void main(String[] args) throws Exception {
<span class="nc" id="L294">    int exitStatus = 0;</span>
<span class="nc" id="L295">    MPI.Init(args);</span>
<span class="nc" id="L296">    commRank = MPI.COMM_WORLD.Rank();</span>
<span class="nc" id="L297">    commSize = MPI.COMM_WORLD.Size();</span>

<span class="nc" id="L299">    verboseLauncher = Boolean.parseBoolean(System.getProperty(Configuration.APGAS_VERBOSE_LAUNCHER, &quot;false&quot;));</span>

<span class="nc bnc" id="L301" title="All 2 branches missed.">    if (verboseLauncher) {</span>
<span class="nc" id="L302">      System.err.println(&quot;[MPILauncher] rank = &quot; + commRank);</span>
    }

<span class="nc bnc" id="L305" title="All 2 branches missed.">    if (args.length &lt; 1) {</span>
<span class="nc" id="L306">      System.err.println(&quot;[MPILauncher] Error Main Class Required&quot;);</span>
<span class="nc" id="L307">      MPI.Finalize();</span>
<span class="nc" id="L308">      System.exit(0);</span>
    }

    /*
     * Extracts the arguments destined for the main method of the specified class.
     */
<span class="nc" id="L314">    final String[] newArgs = new String[args.length - 1];</span>
<span class="nc" id="L315">    System.arraycopy(args, 1, newArgs, 0, args.length - 1);</span>

    // Sets the number of places according to the arguments given to `mpirun`
    // command
<span class="nc" id="L319">    System.setProperty(Configuration.APGAS_PLACES, Integer.toString(commSize));</span>
    // Sets the launcher to be of MPILauncher class. This will make the apgas
    // runtime use the MPILauncher shutdown method when the apgas shutdown
    // method is launched
<span class="nc" id="L323">    System.setProperty(Config.APGAS_LAUNCHER, &quot;apgas.mpi.MPILauncherNoExit2&quot;);</span>

    /*
     * If this place is the &quot;master&quot;, i.e. rank, launches the main method of the class specified as parameter. If it is
     * not the &quot;master&quot;, sets up the APGAS runtime and waits till asynchronous tasks are submitted to this place.
     */
<span class="nc bnc" id="L329" title="All 2 branches missed.">    if (commRank == 0) {</span>
      try {
<span class="nc" id="L331">        GlobalRuntime.getRuntime();</span>
<span class="nc" id="L332">        final Method mainMethod = Class.forName(args[0]).getMethod(&quot;main&quot;, String[].class);</span>
<span class="nc" id="L333">        final Object[] mainArgs = new Object[1];</span>
<span class="nc" id="L334">        mainArgs[0] = newArgs;</span>

        // Prevent call to exit()
<span class="nc" id="L337">        System.setSecurityManager(new NoExitSecurityManager());</span>
<span class="nc" id="L338">        mainMethod.invoke(null, mainArgs);</span>
<span class="nc" id="L339">      } catch (final ClassNotFoundException e) {</span>
<span class="nc" id="L340">        System.err.println(&quot;[MPILauncher] Error: Class &quot; + args[0] + &quot; could not be found&quot;);</span>
<span class="nc" id="L341">      } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L342">        System.err.println(&quot;[MPILauncher] Error: Class &quot; + args[0] + &quot; does not have a main method&quot;);</span>
<span class="nc" id="L343">      } catch (final InvocationTargetException e) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (e.getCause() instanceof ExitException) {</span>
          // Obtain the exit status to make host 0 transmit it
          // after the program shutdown occurs
<span class="nc" id="L347">          exitStatus = ((ExitException) e.getCause()).status;</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">          if (verboseLauncher) {</span>
<span class="nc" id="L349">            System.err.println(&quot;[MPILauncherNoExit] exit code &quot; + exitStatus + &quot; was intercepted&quot;);</span>
          }
        }
<span class="nc" id="L352">      } catch (final Exception e) {</span>
<span class="nc" id="L353">        e.printStackTrace();</span>
      } finally {
        // Remove the security manager to allow shutdown
<span class="nc" id="L356">        System.setSecurityManager(null);</span>
      }

      // Initiating shutdown
<span class="nc bnc" id="L360" title="All 2 branches missed.">      if (verboseLauncher) {</span>
<span class="nc" id="L361">        System.err.println(&quot;[MPILauncher] MPI rank&quot; + commRank + &quot; is initiating shutdown&quot;);</span>
      }
      // for (Place p : apgas.Constructs.places()) {
      // if (p.id != 0) {
      // ((GlobalRuntimeImpl) GlobalRuntime.getRuntime()).immediateAsyncAt(p, () -&gt; {
      // if (verboseLauncher) {System.err.println(&quot;[MPILauncherNoExit2] &quot; + apgas.Constructs.here() + &quot; has received the
      // task making it shut down&quot;);}
      // GlobalRuntime.getRuntime().shutdown();
      // System.exit(0); // Should activate the shutdown hook of the remote host.
      // });
      // }
      // }
      // // Call to finalize for host 0 as well
      // try {
      // MPI.Finalize();
      // } catch (final MPIException e) {
      // System.err.println(&quot;[MPILauncher] Error on Shutdown at rank &quot; + commRank);
      // e.printStackTrace();
      // } finally {
      // System.exit(exitStatus);
      // }
      //
    } else {
<span class="nc" id="L384">      slave();</span>
    }
    try {
<span class="nc bnc" id="L387" title="All 2 branches missed.">      if (!finalizeCalled) {</span>
<span class="nc" id="L388">        finalizeCalled = true;</span>
<span class="nc" id="L389">        MPI.Finalize();</span>
      }
<span class="nc" id="L391">      System.exit(0);</span>
<span class="nc" id="L392">    } catch (final MPIException e) {</span>
<span class="nc" id="L393">      System.err.println(&quot;[MPILauncher] Error on Finalize - main method at rank &quot; + commRank);</span>
<span class="nc" id="L394">      e.printStackTrace();</span>
<span class="nc" id="L395">    }</span>
<span class="nc" id="L396">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>