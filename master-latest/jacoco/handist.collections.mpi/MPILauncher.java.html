<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MPILauncher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.mpi</a> &gt; <span class="el_source">MPILauncher.java</span></div><h1>MPILauncher.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2020 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under 
 * the terms of the Eclipse Public License 1.0 which accompanies this 
 * distribution, and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 *******************************************************************************/
package handist.collections.mpi;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import apgas.Configuration;
import apgas.GlobalRuntime;
import apgas.impl.Config;
import apgas.impl.Launcher;
import mpi.Comm;
import mpi.MPI;
import mpi.MPIException;

/**
 * The {@link MPILauncher} class implements a launcher for the apgas runtime
 * using MPI. Programs should be run in the following way:
 * &lt;p&gt;
 * &lt;em&gt;mpirun -np &amp;lt;nb hosts&amp;gt; -host &amp;lt; comma-seperated list of hosts&amp;gt; 
 * java -cp &amp;lt;classpath&amp;gt; apgas.mpi.MPILauncher &amp;lt;main class to launch&amp;gt;
 * &amp;lt;arguments for said class&amp;gt;&lt;/em&gt;
 * &lt;p&gt;
 * For instance, to launch the HelloWorld example with message &quot;Hello&quot; on 4
 * servers, a solution would be:
 * &lt;p&gt;
 * &lt;em&gt;mpirun -np 4 -host piccolo04,piccolo05,piccolo06,piccolo07 java -cp
 * apgas.jar:apgasExamples.jar:kryo.jar:mpi.jar:reflectasm.jar:hazelcast.jar:minlog.jar:objenesis.jar
 * apgas.mpi.MPILauncher apgas.examples.HelloWorld Hello&lt;/em&gt;
 *
 * @author Toshiyuki
 */
final public class MPILauncher implements Launcher {
  public static interface Plugin {
    public String getName();
    public void init(int rank, Comm cocm) throws MPIException;
    public void beforeFinalize(int rank, Comm com) throws MPIException;
  }

<span class="fc" id="L54">  static List&lt;Plugin&gt; plugins = new ArrayList&lt;&gt;();</span>
  public static void registerPlugins(Plugin plugin) {
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">      if(verboseLauncher) System.err.println(&quot;[MPILauncher] &quot; + plugin.getName() + &quot; is registered.&quot;);</span>
<span class="fc" id="L57">      plugins.add(plugin);</span>
<span class="fc" id="L58">  }</span>

  public static void mpiCustomSetup(int rank, Comm world) throws MPIException {
<span class="fc bfc" id="L61" title="All 2 branches covered.">    for(Plugin plugin: plugins) {</span>
<span class="fc" id="L62">      plugin.init(rank, world);</span>
<span class="fc" id="L63">    }</span>
<span class="fc" id="L64">  }</span>
  public static void mpiCustomFinalize(int rank, Comm world) throws MPIException {
<span class="fc bfc" id="L66" title="All 2 branches covered.">    for(Plugin plugin: plugins) {</span>
<span class="fc" id="L67">      plugin.beforeFinalize(rank, world);</span>
<span class="fc" id="L68">    }</span>
<span class="fc" id="L69">    MPI.Finalize();</span>
<span class="fc" id="L70">  }</span>


  /** Identifier of this place */
  static int commRank;
  /** Number of places in the system */
  static int commSize;
  /**
   * Set in the main method according to the value set by
   * {@link Configuration#APGAS_VERBOSE_LAUNCHER}
   */
  static boolean verboseLauncher;

  /**
   * Constructs a new {@link MPILauncher} instance.
   */
<span class="fc" id="L86">  public MPILauncher() {</span>
<span class="fc" id="L87">  }</span>

  /**
   * Launches one process with the given command line at the specified host.
   * &lt;p&gt;
   * Should not be called in practice as every java processes are supposed to be
   * launched using the `mpirun` command. Implementation will print an &quot;Internal
   * error&quot; on the {@link System#err} before calling for the program's
   * termination and exiting with return code -1.
   *
   * @param command
   *          command line
   * @param host
   *          host
   * @param verbose
   *          dumps the executed commands to stderr
   * @return the process object
   * @throws Exception
   *           if launching fails
   */
  @Override
  public Process launch(List&lt;String&gt; command, String host, boolean verbose)
      throws Exception {

<span class="nc" id="L111">    System.err.println(&quot;[MPILauncher] Internal Error&quot;);</span>
<span class="nc" id="L112">    mpiCustomFinalize(MPI.COMM_WORLD.Rank(), MPI.COMM_WORLD);</span>
<span class="nc" id="L113">    System.exit(-1);</span>

<span class="nc" id="L115">    return null;</span>
  }

  /**
   * Launches n processes with the given command line and host list. The first
   * host of the list is skipped. If the list is incomplete, the last host is
   * repeated.
   *
   * @param n
   *          number of processes to launch
   * @param command
   *          command line
   * @param hosts
   *          host list (not null, not empty, but possibly incomplete)
   * @param verbose
   *          dumps the executed commands to stderr
   * @throws Exception
   *           if launching fails
   */
  @Override
  public void launch(int n, List&lt;String&gt; command, List&lt;String&gt; hosts,
      boolean verbose) throws Exception {

<span class="pc bpc" id="L138" title="1 of 2 branches missed.">    if (n + 1 != commSize) {</span>
<span class="nc" id="L139">      System.err.println(&quot;[MPILauncher] &quot; + Configuration.APGAS_PLACES</span>
          + &quot; should be equal to number of MPI processes &quot; + commSize);
<span class="nc" id="L141">      MPI.Finalize();</span>
<span class="nc" id="L142">      System.exit(-1);</span>
    }

<span class="fc" id="L145">    final byte[] baCommand = serializeToByteArray(</span>
<span class="fc" id="L146">        command.toArray(new String[command.size()]));</span>
<span class="fc" id="L147">    final int[] msglen = new int[1];</span>
<span class="fc" id="L148">    msglen[0] = baCommand.length;</span>
<span class="fc" id="L149">    MPI.COMM_WORLD.Bcast(msglen, 0, 1, MPI.INT, 0);</span>
<span class="fc" id="L150">    MPI.COMM_WORLD.Bcast(baCommand, 0, msglen[0], MPI.BYTE, 0);</span>
<span class="fc" id="L151">  }</span>

  /**
   * Sets up the apgas runtime for it to wait for activities to be spawned on
   * this place.
   *
   * @throws Exception
   *           if some problem occurs with the MPI runtime
   */
  static void slave() throws Exception {

<span class="fc" id="L162">    final int[] msglen = new int[1];</span>
<span class="fc" id="L163">    MPI.COMM_WORLD.Bcast(msglen, 0, 1, MPI.INT, 0);</span>
<span class="fc" id="L164">    final byte[] msgbuf = new byte[msglen[0]];</span>
<span class="fc" id="L165">    MPI.COMM_WORLD.Bcast(msgbuf, 0, msglen[0], MPI.BYTE, 0);</span>
<span class="fc" id="L166">    final String[] command = (String[]) deserializeFromByteArray(msgbuf);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    if(verboseLauncher) {</span>
<span class="nc" id="L168">	System.err.println(&quot;command@worker[&quot;+MPI.COMM_WORLD.Rank()+&quot;]: &quot; + java.util.Arrays.asList(command));</span>
    }
<span class="fc bfc" id="L170" title="All 2 branches covered.">    for (int i = 1; i &lt; command.length; i++) {</span>
<span class="fc" id="L171">      final String term = command[i];</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">      if (term.startsWith(&quot;-D&quot;)) {</span>
<span class="fc" id="L174">        final String[] kv = term.substring(2).split(&quot;=&quot;, 2);</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (verboseLauncher) {</span>
<span class="nc" id="L176">          System.err.println(&quot;[&quot; + commRank + &quot;] setProperty \&quot;&quot; + kv[0]</span>
              + &quot;\&quot; = \&quot;&quot; + kv[1] + &quot;\&quot;&quot;);
        }
<span class="fc" id="L179">        System.setProperty(kv[0], kv[1]);</span>
      }
    }

<span class="fc" id="L183">    GlobalRuntime.getRuntime();</span>
<span class="fc" id="L184">  }</span>

  /**
   * Shuts down the local process launched using MPI.
   */
  @Override
  public void shutdown() {
    try {
<span class="nc" id="L192">      MPI.Finalize();</span>
<span class="nc" id="L193">    } catch (final MPIException e) {</span>
<span class="nc" id="L194">      System.err.println(&quot;[MPILauncher] Error on Shutdown at rank &quot; + commRank);</span>
<span class="nc" id="L195">      e.printStackTrace();</span>
<span class="nc" id="L196">    }</span>
<span class="nc" id="L197">    System.exit(0);</span>
<span class="nc" id="L198">  }</span>

  /**
   * Checks that all the processes launched are healthy.
   * &lt;p&gt;
   * Current implementation of {@link MPILauncher} always returns true.
   *
   * @return true if all subprocesses are healthy
   */
  @Override
  public boolean healthy() {
    // TODO
<span class="fc" id="L210">    return true;</span>
  }

  /**
   * Converts a String to an int array
   *
   * @param src
   *          String to be converted
   * @return array of integer corresponding to the given parameter
   * @see #intArrayToString(int[])
   */
  static int[] stringToIntArray(String src) {
<span class="nc" id="L222">    final char[] charArray = src.toCharArray();</span>
<span class="nc" id="L223">    final int[] intArray = new int[charArray.length];</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">    for (int i = 0; i &lt; charArray.length; i++) {</span>
<span class="nc" id="L225">      intArray[i] = charArray[i];</span>
    }
<span class="nc" id="L227">    return intArray;</span>
  }

  /**
   * Converts an int array back into the String it represents
   *
   * @param src
   *          the integer array to be converted back into a String
   * @return the constructed String
   * @see #stringToIntArray(String)
   */
  static String intArrayToString(int[] src) {
<span class="nc" id="L239">    final char[] charArray = new char[src.length];</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">    for (int i = 0; i &lt; src.length; i++) {</span>
<span class="nc" id="L241">      charArray[i] = (char) src[i];</span>
    }
<span class="nc" id="L243">    final String str = new String(charArray);</span>
<span class="nc" id="L244">    return str;</span>
  }

  /**
   * Serializer method
   *
   * @param obj
   *          Object to be serialized
   * @return array of bytes
   * @throws IOException
   *           if an I/O exception occurs
   * @see #deserializeFromByteArray(byte[])
   */
  static byte[] serializeToByteArray(Serializable obj) throws IOException {
<span class="fc" id="L258">    final ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L259">    final ObjectOutputStream oos = new ObjectOutputStream(baos);</span>
<span class="fc" id="L260">    oos.writeObject(obj);</span>
<span class="fc" id="L261">    return baos.toByteArray();</span>
  }

  /**
   * Deserializer method
   *
   * @param barray
   *          byte array input
   * @return Object constructed from the input
   * @throws IOException
   *           if an I/O occurs
   * @throws ClassNotFoundException
   *           if the class could not be identified
   * @see #serializeToByteArray(Serializable)
   */
  static Object deserializeFromByteArray(byte[] barray)
      throws IOException, ClassNotFoundException {
<span class="fc" id="L278">    final ByteArrayInputStream bais = new ByteArrayInputStream(barray);</span>
<span class="fc" id="L279">    final ObjectInputStream ois = new ObjectInputStream(bais);</span>
<span class="fc" id="L280">    return ois.readObject();</span>
  }

  /**
   * Main method of the MPILauncher class
   * &lt;p&gt;
   * Sets up the APGAS environment using an mpi launcher. Rank 0 of the
   * processes will launch the main method of the class specified as parameter
   * with the arguments specified afterward. Other processes will only setup
   * their apgas environment and wait for incoming activities.
   * &lt;p&gt;
   * This main method takes at least one argument, the fully qualified name of
   * the class whose main method is to be run. Arguments for that class' main
   * need to to follow that first argument.
   *
   * @param args
   *          Path to the class whose main method is to be run, followed by the
   *          arguments of that classe's main method.
   * @throws Exception
   *           if MPI exception occur
   */
  public static void main(String[] args) throws Exception {
   
<span class="fc" id="L303">    MPI.Init(args);</span>
<span class="fc" id="L304">    commRank = MPI.COMM_WORLD.Rank();</span>
<span class="fc" id="L305">    commSize = MPI.COMM_WORLD.Size();</span>

<span class="fc" id="L307">    verboseLauncher = Boolean.parseBoolean(</span>
<span class="fc" id="L308">        System.getProperty(Configuration.APGAS_VERBOSE_LAUNCHER, &quot;false&quot;));</span>

    
    //Determine is we are using MPJ, in which case the args will need to be adjusted
<span class="fc" id="L312">    boolean isMPJ = false;</span>
    try {
<span class="nc" id="L314">      final Class&lt;?&gt; mpjdevCommClass = Class.forName(&quot;mpjdev.Comm&quot;);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">      isMPJ = (mpjdevCommClass != null);</span>
<span class="fc" id="L316">    } catch (Exception e) {</span>
      // Ignore any exception
<span class="nc" id="L318">    }</span>
    
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    if (verboseLauncher) {</span>
<span class="nc" id="L321">      System.err.println(&quot;[MPILaucnher] command: &quot; + java.util.Arrays.asList(args));	</span>
<span class="nc" id="L322">      System.err.println(&quot;[MPILauncher] rank = &quot; + commRank);</span>
    }

<span class="pc bpc" id="L325" title="1 of 2 branches missed.">    if (args.length &lt; 1) {</span>
<span class="nc" id="L326">      System.err.println(&quot;[MPILauncher] Error Main Class Required&quot;);</span>
<span class="nc" id="L327">      MPI.Finalize();</span>
<span class="nc" id="L328">      System.exit(0);</span>
    }

    /*
     * Extracts the arguments destined for the main method of the specified
     * class.
     */
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">    final int offset = isMPJ?4:1;</span>
<span class="fc" id="L336">    final String[] newArgs = new String[args.length - offset];</span>
<span class="fc" id="L337">    System.arraycopy(args, offset, newArgs, 0, args.length - offset);</span>

    // Sets the number of places according to the arguments given to `mpirun`
    // command
<span class="fc" id="L341">    System.setProperty(Configuration.APGAS_PLACES, Integer.toString(commSize));</span>
    // Sets the launcher to be of MPILauncher class. This will make the apgas
    // runtime use the MPILauncher shutdown method when the apgas shutdown
    // method is launched
<span class="fc" id="L345">    System.setProperty(Config.APGAS_LAUNCHER, &quot;handist.collections.mpi.MPILauncher&quot;);</span>

    /*
     * If this place is the &quot;master&quot;, i.e. rank, launches the main method of the
     * class specified as parameter. If it is not the &quot;master&quot;, sets up the
     * APGAS runtime and waits till asynchronous tasks are submitted to this
     * place.
     */
<span class="fc bfc" id="L353" title="All 2 branches covered.">    if (commRank == 0) {</span>
      try {
<span class="fc" id="L355">        GlobalRuntime.getRuntime();</span>
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        final Method mainMethod = Class.forName(args[isMPJ? 3:0]).getMethod(&quot;main&quot;,</span>
            String[].class);
<span class="fc" id="L358">        final Object[] mainArgs = new Object[1];</span>
<span class="fc" id="L359">        mainArgs[0] = newArgs;</span>
<span class="fc" id="L360">        mpiCustomSetup(commRank, MPI.COMM_WORLD);</span>
<span class="fc" id="L361">        mainMethod.invoke(null, mainArgs);</span>
<span class="nc" id="L362">      } catch (final ClassNotFoundException e) {</span>
<span class="nc" id="L363">        System.err.println(</span>
            &quot;[MPILauncher] Error: Class &quot; + args[0] + &quot; could not be found&quot;);
<span class="nc" id="L365">      } catch (final NoSuchMethodException e) {</span>
<span class="nc" id="L366">        System.err.println(&quot;[MPILauncher] Error: Class &quot; + args[0]</span>
            + &quot; does not have a main method&quot;);
<span class="nc" id="L368">      } catch (final Exception e) {</span>
<span class="nc" id="L369">        e.printStackTrace();</span>
<span class="pc" id="L370">      }</span>
    } else {
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">      Class&lt;?&gt; mainClass = Class.forName(args[isMPJ? 3:0]);</span>
<span class="fc" id="L373">      slave();</span>
<span class="fc" id="L374">      mpiCustomSetup(commRank,MPI.COMM_WORLD);</span>
    }

    try {
<span class="fc" id="L378">      mpiCustomFinalize(commRank, MPI.COMM_WORLD);</span>
      //MPI.Finalize();
<span class="nc" id="L380">      System.exit(0);</span>
<span class="nc" id="L381">    } catch (final MPIException e) {</span>
<span class="nc" id="L382">      System.err.println(</span>
          &quot;[MPILauncher] Error on Finalize - main method at rank &quot; + commRank);
<span class="nc" id="L384">      e.printStackTrace();</span>
<span class="nc" id="L385">    }</span>

<span class="nc" id="L387">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>