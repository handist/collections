<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RangedList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">RangedList.java</span></div><h1>RangedList.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

import handist.collections.function.LongTBiConsumer;

/**
 * Abstract class describing a list defined on long indices. Entries can be
 * defined on any index contained within the {@link LongRange} used to
 * initialize the collection.
 *
 * @param &lt;T&gt; type handled by the collection
 */
<span class="fc" id="L29">public abstract class RangedList&lt;T&gt; implements Iterable&lt;T&gt; {</span>

    public static boolean equals(RangedList&lt;?&gt; rlist1, Object o) {
<span class="pc bpc" id="L32" title="1 of 2 branches missed.">        if (o == null) {</span>
<span class="nc bnc" id="L33" title="All 2 branches missed.">            return (rlist1 == null);</span>
        }
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">        if (!(o instanceof RangedList)) {</span>
<span class="nc" id="L36">            return false;</span>
        }
<span class="fc" id="L38">        final RangedList&lt;?&gt; rlist2 = (RangedList&lt;?&gt;) o;</span>
        // TODO this version is too slow,
        // setupFrom will be the good candidate for fast simul scanner.
<span class="fc bfc" id="L41" title="All 2 branches covered.">        if (!rlist1.getRange().equals(rlist2.getRange())) {</span>
<span class="fc" id="L42">            return false;</span>
        }
<span class="fc bfc" id="L44" title="All 2 branches covered.">        for (final long index : rlist1.getRange()) {</span>
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">            if (!rlist1.get(index).equals(rlist2.get(index))) {</span>
<span class="nc" id="L46">                return false;</span>
            }
<span class="fc" id="L48">        }</span>
<span class="fc" id="L49">        return true;</span>
    }

    public static int hashCode(RangedList&lt;?&gt; rlist) {
<span class="nc" id="L53">        int hashCode = 1;</span>
        // code from JavaAPI doc of List
<span class="nc bnc" id="L55" title="All 2 branches missed.">        for (final Object o : rlist) {</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">            hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());</span>
<span class="nc" id="L57">        }</span>
<span class="nc" id="L58">        return hashCode;</span>
    }

    /**
     * Returns a copy of this instance, restricted to the contents that are included
     * in the specified range.
     *
     * @param range portion of the {@link RangedList} to copy
     * @return a new RangedList which contains the entries of this instance on
     *         provided range
     */
    public abstract RangedList&lt;T&gt; cloneRange(LongRange range);

    /**
     * Indicates if this list contains the provided object. More formally if the
     * list contains at least one object {@code a} such that
     * &lt;code&gt;(a == null) ? o == null : a.equals(o);&lt;/code&gt; is true.
     *
     * @param o the object whose presence is to be checked
     * @return {@code true} if the collection contains {@code o}, {@code false}
     *         otherwise
     */
    public abstract boolean contains(Object o);

    /**
     * Checks if all the elements provided in the collection are present in this
     * instance.
     *
     * @param c collection of all the elements whose presence in the RangedList is
     *          to be checked
     * @return {@code true} if all the elements in the provided collection can be
     *         found in this instance, {@code false} otherwise
     */
    public boolean containsAll(Collection&lt;? extends T&gt; c) {
<span class="nc bnc" id="L92" title="All 2 branches missed.">        for (final T t : c) {</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">            if (!contains(t)) {</span>
<span class="nc" id="L94">                return false;</span>
            }
<span class="nc" id="L96">        }</span>
<span class="nc" id="L97">        return true;</span>
    }

    /**
     * Performs the provided action on each element contained by this instance, and
     * potentially collect/extract some information into the provided receiver.
     * &lt;p&gt;
     * The BiConsumer is applied on each element contained in the collection (first
     * parameter of the BiConsumer) with the receiver provided as second parameter
     * of this method as the second parameter of the BiConsumer. This allows you to
     * make modifications to individual elements and potentially extract some
     * information (of type U) and store it in the receiver provided as second
     * parameter.
     * &lt;p&gt;
     * If you do not need to extract any information from the elements contained in
     * this instance, you should use {@link #forEach(Consumer)} instead.
     *
     * @param &lt;U&gt;      type of the collected instances
     * @param action   action to perform on each element, potentially
     * @param receiver collector of information extracted
     */
    public &lt;U&gt; void forEach(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, Consumer&lt;? super U&gt; receiver) {
<span class="nc" id="L119">        forEach(getRange(), action, receiver);</span>
<span class="nc" id="L120">    }</span>

    /**
     * Performs the provided action on every element in the collection
     */
    @Override
    public void forEach(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L127">        forEach(getRange(), action);</span>
<span class="fc" id="L128">    }</span>

    /**
     * Performs the provided action on elements contained by this instance, and
     * potentially collect/extract some information into the provided receiver. This
     * method has the same effect as {@link #forEach(BiConsumer, Consumer)} but its
     * application is restricted to the range specified as first parameter.
     * &lt;p&gt;
     * The BiConsumer is applied on each element contained in the collection (first
     * parameter of the BiConsumer) with the receiver provided as second parameter
     * of this method as the second parameter of the BiConsumer. This allows you to
     * make modifications to individual elements and potentially extract some
     * information (of type U) and store it in the receiver provided as second
     * parameter.
     * &lt;p&gt;
     * If you do not need to extract any information from the elements contained in
     * this instance, you should use {@link #forEach(LongRange, Consumer)} instead.
     *
     * @param &lt;U&gt;      type of the collected instances
     * @param range    range on which the action is to be applied
     * @param action   action to perform on each element, potentially
     * @param receiver collector of information extracted
     * @see #forEach(LongRange, BiConsumer, Consumer)
     */
    public &lt;U&gt; void forEach(LongRange range, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            Consumer&lt;? super U&gt; receiver) {
<span class="nc bnc" id="L154" title="All 2 branches missed.">        for (long i = range.from; i &lt; range.to; i++) {</span>
<span class="nc" id="L155">            action.accept(get(i), receiver);</span>
        }
<span class="nc" id="L157">    }</span>

    /**
     * Applies the specified action on the elements of this collection that are
     * present in the specified range. This method is similar to
     * {@link #forEach(Consumer)} but the application of the specified action is
     * restricted to the range specified as first parameter
     *
     * @param range  range of application of the action
     * @param action action to perform on individual elements
     */
    public void forEach(LongRange range, Consumer&lt;? super T&gt; action) {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (long i = range.from; i &lt; range.to; i++) {</span>
<span class="nc" id="L170">            action.accept(get(i));</span>
        }
<span class="nc" id="L172">    }</span>

    /**
     * Applies the given action on the index/value pairs present in the specified
     * range.
     * &lt;p&gt;
     * This method is almost identical to {@link #forEach(LongTBiConsumer)} but its
     * application is restricted to the range of indices specified as parameter.
     *
     * @param range  range of indices on which to apply the action
     * @param action action to perform taking a long and a T as parameter
     */
    public void forEach(LongRange range, LongTBiConsumer&lt;? super T&gt; action) {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (long i = range.from; i &lt; range.to; i++) {</span>
<span class="nc" id="L186">            action.accept(i, get(i));</span>
        }
<span class="nc" id="L188">    }</span>

    /**
     * Performs the specified action on every index/value pair contained in this
     * collection
     *
     * @param action action to perform taking a long and a T as parameter
     */
    public void forEach(LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L197">        forEach(getRange(), action);</span>
<span class="fc" id="L198">    }</span>

    /**
     * Returns the value associated with the provided {@code long} index.
     *
     * @param index index of the value to return.
     * @return the value associated with this index
     */
    public abstract T get(long index);

    /**
     * Obtain the {@link LongRange} on which this instance is defined.
     *
     * @return the {@link LongRange} object representing the
     */
    public abstract LongRange getRange();

    /**
     * Indicates if this RangedList is empty, i.e. if it cannot contain any entry
     * because it is defined on an empty {@link LongRange}.
     *
     * @return {@code true} is the instance is defined on an empty
     *         {@link LongRange}, {@code false} otherwise.
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L223" title="All 2 branches covered.">        return getRange().size() == 0;</span>
    }

    /**
     * Creates a new collection from the elements contained in this instance by
     * transforming them into a new type
     *
     * @param &lt;U&gt;  type of the collection to create
     * @param func function that returns a type U from the provided T
     * @return a newly created collection which contains the mapping of the elements
     *         contained by this instance to type U
     */
    public &lt;U&gt; RangedList&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; func) {
<span class="fc" id="L236">        final Chunk&lt;U&gt; result = new Chunk&lt;&gt;(this.getRange());</span>
<span class="fc" id="L237">        result.setupFrom(this, func);</span>
<span class="fc" id="L238">        return result;</span>
    }

    /**
     * Creates a new collection from the elements contained in this instance on the
     * specified range by transforming them into a different type
     *
     * @param &lt;U&gt;   type of the collection to create
     * @param range the range on which to apply the method
     * @param func  function that returns a type U from the provided T
     * @return a newly created collection which contains the mapping of the elements
     *         contained by this instance (restricted to the specified range) to
     *         type U
     */
    public &lt;U&gt; RangedList&lt;U&gt; map(LongRange range, Function&lt;? super T, ? extends U&gt; func) {
<span class="nc" id="L253">        return this.subList(range.from, range.to).map(func);</span>
    }

    /**
     * Checks if the provided {@code long index} is included in the range this
     * instance is defined on, i.e. if method {@link #get(long)}, or
     * {@link #set(long,Object)} can be safely called with the provided parameter.
     *
     * @param target the index to check
     * @throws IndexOutOfBoundsException if the provided index is outside the range
     *                                   this instance is defined on
     */
    public void rangeCheck(long target) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (!this.getRange().contains(target)) {</span>
<span class="fc" id="L267">            throw new IndexOutOfBoundsException(</span>
<span class="fc" id="L268">                    &quot;[RangedList] range mismatch: &quot; + this.getRange() + &quot; does not include &quot; + target);</span>
        }
<span class="fc" id="L270">    }</span>

    /**
     * Checks if the provided {@link LongRange} is included in the range of this
     * instance.
     *
     * @param target LongRange whose inclusion in this instance is to be checked
     * @throws ArrayIndexOutOfBoundsException if the provided {@link LongRange} is
     *                                        not included in this instance
     */
    public void rangeCheck(LongRange target) {
<span class="fc bfc" id="L281" title="All 2 branches covered.">        if (!this.getRange().contains(target)) {</span>
<span class="fc" id="L282">            throw new ArrayIndexOutOfBoundsException(</span>
<span class="fc" id="L283">                    &quot;[RangedList] range mismatch:&quot; + this.getRange() + &quot; must include &quot; + target);</span>
        }
<span class="fc" id="L285">    }</span>

    /**
     * Sets the provided value at the specified index
     *
     * @param index index at which the value should be stored
     * @param value value to store at the specified index
     * @return previous value that was stored at this index, {@code null} if there
     *         was no previous value or the previous value stored was {@code null}
     */
    public abstract T set(long index, T value);

    /**
     * Initializes the values in this instance by applying the provided function on
     * the elements contained in {@code source}
     *
     * @param &lt;S&gt;    the type handled by the {@link RangedList} given as parameter,
     *               input for the function
     * @param source {@link RangedList} instance from which entried for this
     *               instance will be extracted
     * @param func   function that takes an object of type S as parameter and
     *               returns a type T
     */
    public abstract &lt;S&gt; void setupFrom(RangedList&lt;S&gt; source, Function&lt;? super S, ? extends T&gt; func);

    /**
     * Returns the number of entries in this collection as a {@code long}
     *
     * @return size of the collection
     */
    public long size() {
<span class="fc" id="L316">        final LongRange r = getRange();</span>
<span class="fc" id="L317">        return r.to - r.from;</span>
    }

    /**
     * Separates this instance into multiple {@link RangedList}s using the points
     * given as parameter.
     * &lt;p&gt;
     * For instance, if this instance is defined on a range [a,b) and points l, m,
     * and n are given as parameter, this method will return 4 {@link RangedList}
     * defined on [a,l), [l,m), [m,n), and [n,b).
     * &lt;p&gt;
     * The user will be careful to sort the points given as parameter in ascending
     * order. Exceptions during the creation of {@link RangedList} will be thrown
     * otherwise.
     *
     * @param splitPoints the points at which this instance needs to be cut
     * @return this instance entries split into several {@link RangedList}
     */
    public List&lt;RangedList&lt;T&gt;&gt; splitRange(long... splitPoints) {
<span class="fc" id="L336">        final ArrayList&lt;RangedList&lt;T&gt;&gt; toReturn = new ArrayList&lt;&gt;(splitPoints.length + 1);</span>
<span class="fc" id="L337">        final LongRange range = getRange();</span>
<span class="fc" id="L338">        long start = range.from;</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">        for (final long split : splitPoints) {</span>
<span class="fc" id="L340">            toReturn.add(new RangedListView&lt;&gt;(this, new LongRange(start, split)));</span>
<span class="fc" id="L341">            start = split;</span>
        }
<span class="fc" id="L343">        toReturn.add(new RangedListView&lt;&gt;(this, new LongRange(start, range.to)));</span>
<span class="fc" id="L344">        return toReturn;</span>
    };

    /**
     * Provides a RangedList of the elements contained in this instance from index
     * &lt;em&gt;begin&lt;/em&gt; to index &lt;em&gt;end&lt;/em&gt;.
     * &lt;p&gt;
     * If the provided range exceeds the indices contained in this instance (i.e. if
     * &lt;em&gt;begin&lt;/em&gt; is lower than the lowest index contained in this instance, or
     * if &lt;em&gt;end&lt;/em&gt; is higher than the highest index contained in this instance)
     * the method will return the elements it contains that fit within the provided
     * range.
     *
     * @param begin starting index of the desired sub-list
     * @param end   last index of the desired sub-list (exlusive)
     * @return a ranged list of the elements contained in this {@link RangedList}
     *         that fit in the provided range.
     * @throws IllegalArgumentException  if &lt;em&gt;begin&lt;/em&gt; is superior to
     *                                   &lt;em&gt;end&lt;/em&gt;.
     * @throws IndexOutOfBoundsException if the provided range has no intersection
     *                                   with the range of this instance.
     */
    public RangedList&lt;T&gt; subList(long begin, long end) {
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (begin &gt; end) {</span>
<span class="fc" id="L368">            throw new IllegalArgumentException(&quot;Cannot obtain a sublist from &quot; + begin + &quot; to &quot; + end);</span>
        }
<span class="fc" id="L370">        final long from = Math.max(begin, getRange().from);</span>
<span class="fc" id="L371">        final long to = Math.min(end, getRange().to);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (from &gt; to) {</span>
<span class="fc" id="L373">            throw new IndexOutOfBoundsException(&quot;[RangedList] no intersection with [&quot; + begin + &quot;,&quot; + end + &quot;)&quot;);</span>
        }
<span class="fc" id="L375">        final LongRange newRange = new LongRange(from, to);</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (newRange.equals(getRange())) {</span>
<span class="fc" id="L377">            return this;</span>
        }
<span class="fc" id="L379">        return new RangedListView&lt;&gt;(this, newRange);</span>
    }

    /**
     * Provides a RangedList of the elements contained in this instance on the
     * specified {@link LongRange}.
     * &lt;p&gt;
     * If the provided range exceeds the indices contained in this instance (i.e. if
     * lower bound of the {@link LongRange} is lower than the lowest index contained
     * in this instance, or if the upper bound of the provided {@link LongRange} is
     * higher than the highest index contained in this instance) the method will
     * return the elements it contains that fit within the provided range.
     *
     * @param range range of indices of which a copy is desired
     * @return a ranged list of the elements contained in this {@link RangedList}
     *         that fit in the provided range.
     * @throws IllegalArgumentException if &lt;em&gt;begin&lt;/em&gt; is superior to
     *                                  &lt;em&gt;end&lt;/em&gt;.
     */
    public RangedList&lt;T&gt; subList(LongRange range) {
<span class="fc" id="L399">        return subList(range.from, range.to);</span>
    }

    /**
     * Returns the elements contained in this instance in an array
     *
     * @return array containing the objects contained in this instance
     */
    public abstract Object[] toArray();

    /**
     * Returns the elements contained in this instance in an array
     *
     * @param r the range of elements to take
     * @return an object array containing the elements of this instance within the
     *         specified range
     */
    public abstract Object[] toArray(LongRange r);

    /**
     * Creates a Chunk containing all the elements of this instance
     *
     * @return a new {@link Chunk} with the same range as this instance containing
     *         all the elements of this instance
     */
    public Chunk&lt;T&gt; toChunk() {
<span class="nc" id="L425">        return toChunk(getRange());</span>
    }

    /**
     * Creates a Chunk containing the elements of this instance included in the
     * specified range
     *
     * @param r the range of elements to create a {@link Chunk} with.
     * @return a new {@link Chunk} with the specified range containing the elements
     *         of this instance
     */
    public abstract Chunk&lt;T&gt; toChunk(LongRange r);

    /**
     * Returns the elements contained in this instance in a {@link List}. Note that
     * the indices of the returned list do not reflect the long indices used in this
     * implementation.
     *
     * @return a list containing the elements of this instance within the specified
     *         range
     */
    public List&lt;T&gt; toList() {
<span class="nc" id="L447">        return toList(getRange());</span>
    }

    /**
     * Returns the elements contained in this instance within the specified range in
     * a {@link List}. Note that the indices of the returned list do not reflect the
     * long indices used in this implementation.
     *
     * @param r the range of indices of this instance to include in the returned
     *          list
     * @return a list containing the elements of this instance within the specified
     *         range
     */
    public abstract List&lt;T&gt; toList(LongRange r);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>