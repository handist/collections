<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Chunk.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">Chunk.java</span></div><h1>Chunk.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.KryoSerializable;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;


/**
 * Large collection that can contain objects mapped to long indices.
 *
 * @param &lt;T&gt; type of the elements handled by this instance
 */
public class Chunk&lt;T&gt; extends RangedList&lt;T&gt; implements Serializable, KryoSerializable {

    /** Serial Version UID */
    private static final long serialVersionUID = -7691832846457812518L;

    /** Array containing the T objects */
    private Object[] a;

    /** Range on which this instance is defined */
    private LongRange range;

    /**
     * Builds a Chunk with the given range and no mapping.
     * &lt;p&gt;
     * The given LongRange should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
<span class="fc" id="L60">    public Chunk(LongRange range) {</span>
<span class="fc" id="L61">        final long size = range.to - range.from;</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        if (size &gt; Config.maxChunkSize) {</span>
<span class="fc" id="L63">            throw new IllegalArgumentException(</span>
                    &quot;The given range &quot; + range + &quot; exceeds the maximum Chunk size &quot; + Config.maxChunkSize);
<span class="fc bfc" id="L65" title="All 2 branches covered.">        } else if (size &lt;= 0) {</span>
<span class="fc" id="L66">            throw new IllegalArgumentException(&quot;Cannot build a Chunk with &quot; + &quot;LongRange &quot; + range</span>
                    + &quot;, should have a strictly positive&quot; + &quot; size&quot;);
        }
<span class="fc" id="L69">        a = new Object[(int) size];</span>
<span class="fc" id="L70">        this.range = range;</span>
<span class="fc" id="L71">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange}. The provided
     * initializer generates the initial value of the element for each index. The
     * given LongRange should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range       the range of the chunk to build
     * @param initializer generates the initial value of the element for each index.
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
    public Chunk(LongRange range, Function&lt;Long, T&gt; initializer) {
<span class="fc" id="L90">        this(range);</span>
<span class="fc" id="L91">        range.forEach((long index) -&gt; {</span>
<span class="fc" id="L92">            a[(int) (index - range.from)] = initializer.apply(index);</span>
<span class="fc" id="L93">        });</span>
<span class="fc" id="L94">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange} and an initial
     * mapping for each long in the object array. The provided {@link LongRange} and
     * Object array should have the same size. An {@link IllegalArgumentException}
     * will be thrown otherwise.
     * &lt;p&gt;
     * The given {@link LongRange} should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @param a     array with the initial mapping for every long in the provided
     *              range
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range and object array.
     */
    public Chunk(LongRange range, Object[] a) {
<span class="fc" id="L117">        this(range);</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (a.length != range.size()) {</span>
<span class="fc" id="L119">            throw new IllegalArgumentException(&quot;The length of the provided &quot; + &quot;array &lt;&quot; + a.length</span>
<span class="fc" id="L120">                    + &quot;&gt; does not match the size of the &quot; + &quot;LongRange &lt;&quot; + range.size() + &quot;&gt;&quot;);</span>
        }
        // TODO Do we check for objects in array a that are not of type T?
        // We can leave as is and let the code fail later in methods get and
        // others where a ClassCastException should be thrown.
<span class="fc" id="L125">        this.a = a;</span>
<span class="fc" id="L126">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange} with each long in
     * the provided range mapped to object t. The given LongRange should have a
     * strictly positive size. Giving a {@link LongRange} instance with identical
     * lower and upper bounds will result in a {@link IllegalArgumentException}
     * being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @param t     initial mapping for every long in the provided range
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
    public Chunk(LongRange range, T t) {
<span class="fc" id="L145">        this(range);</span>
        // TODO Is this what we really want to do?
        // The mapping will be on the SAME OBJECT for every long in LongRange.
        // Don't we need a Generator&lt;T&gt; generator as argument and create an
        // instance for each key with Arrays.setAll(a, generator) ?
<span class="fc" id="L150">        Arrays.fill(a, t);</span>
<span class="fc" id="L151">    }</span>

    /**
     * Returns a new Chunk defined on the same {@link LongRange} and with the same
     * contents as this instance.
     *
     * @return a copy of this instance
     */
    @Override
    public Chunk&lt;T&gt; clone() {
        // Object[] aClone = a.clone();
<span class="fc" id="L162">        final Object[] aClone = new Object[a.length];</span>

        //// FIXME: 2018/09/19 Need deep copy?
        // for (int i = 0; i &lt; a.length; i++) {
        // try {
        // aClone[i] = ((Cloneable) a[i]).clone();
        // } catch (CloneNotSupportedException e) {
        // e.printStackTrace();
        // }
        // }

<span class="fc" id="L173">        Arrays.fill(aClone, a[0]);</span>
<span class="fc" id="L174">        System.arraycopy(a, 0, aClone, 0, a.length);</span>

<span class="fc" id="L176">        return new Chunk&lt;&gt;(this.range, aClone);</span>
    }

    @Override
    public Chunk&lt;T&gt; cloneRange(LongRange newRange) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        return range == newRange ? clone() : toChunk(newRange);</span>
    }

    @Override
    public boolean contains(Object v) {
<span class="fc bfc" id="L186" title="All 2 branches covered.">        for (final Object e : a) {</span>
<span class="fc bfc" id="L187" title="All 6 branches covered.">            if (v == null ? e == null : v.equals(e)) {</span>
<span class="fc" id="L188">                return true;</span>
            }
        }
<span class="fc" id="L191">        return false;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc" id="L196">        return RangedList.equals(this, o);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T get(long index) {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (!getRange().contains(index)) {</span>
<span class="fc" id="L205">            throw new IndexOutOfBoundsException(rangeMsg(index));</span>
        }
<span class="fc" id="L207">        return getUnsafe(index);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public LongRange getRange() {
<span class="fc" id="L215">        return range;</span>
    }

    /**
     * Returns the element located at the provided index. The provided index is
     * presumed valid and as such, no bound checking is done.
     *
     * @param index index whose value should be returned
     * @return the object stored at the provided index, possibly {@code null}
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    final T getUnsafe(long index) { // when range check was done
<span class="fc" id="L227">        final long offset = index - range.from;</span>
<span class="fc" id="L228">        return (T) a[(int) offset];</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
<span class="fc" id="L236">        return RangedList.hashCode(this);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L244">        return new ChunkIterator&lt;&gt;(this.range, this.a);</span>
    }

    /**
     * Creates and returns a new {@link RangedListIterator} on the elements
     * contained by this instance
     *
     * @return a new {@link RangedListIterator}
     */
    @Override
    public RangedListIterator&lt;T&gt; listIterator() {
<span class="fc" id="L255">        return new ChunkListIterator&lt;&gt;(this.range, this.a);</span>
    }

    /**
     * Creates and returns a new {@link RangedListIterator} starting at the
     * specified index on the elements contained by this instance
     *
     * @param index the index of the first element to be returned by calling method
     *              {@link RangedListIterator#next()}
     * @return a new {@link RangedListIterator} starting at the specified index
     */
    public RangedListIterator&lt;T&gt; listIterator(long index) {
<span class="fc" id="L267">        return new ChunkListIterator&lt;&gt;(this.range, index, this.a);</span>
    }

    private String rangeMsg(long index) {
<span class="fc" id="L271">        return &quot;[Chunk] range &quot; + index + &quot; is out of &quot; + getRange();</span>
    }

    private String rangeMsg(LongRange range) {
<span class="fc" id="L275">        return &quot;[Chunk] range &quot; + range + &quot; is not contained in &quot; + getRange();</span>
    }

    @Override
    public void read(Kryo kryo, Input input) {
<span class="fc" id="L280">        this.range = (LongRange) kryo.readClassAndObject(input);</span>
<span class="fc" id="L281">        this.a = (Object[]) kryo.readClassAndObject(input);</span>
<span class="fc" id="L282">    }</span>

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L285">        this.range = (LongRange) in.readObject();</span>
<span class="fc" id="L286">        this.a = (Object[]) in.readObject();</span>
        // System.out.println(&quot;readChunk:&quot;+this);
<span class="fc" id="L288">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public T set(long index, T value) {
<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (!getRange().contains(index)) {</span>
<span class="fc" id="L296">            throw new IndexOutOfBoundsException(rangeMsg(index));</span>
        }
<span class="fc" id="L298">        return setUnsafe(index, value);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private final T setUnsafe(long index, T v) { // when range check was done
<span class="fc" id="L303">        final long offset = index - range.from;</span>
<span class="fc" id="L304">        final T prev = (T) a[(int) offset];</span>
<span class="fc" id="L305">        a[(int) offset] = v;</span>
<span class="fc" id="L306">        return prev;</span>
    }
    private LongRange calcSubIteratorRange(LongRange range) {
<span class="fc" id="L309">        range = this.getRange().intersection(range);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if(range == null) {</span>
<span class="nc" id="L311">            throw new IndexOutOfBoundsException();</span>
        }
<span class="fc" id="L313">        return range;</span>
    }
    @Override
    public Iterator&lt;T&gt; subIterator(LongRange range) {
<span class="fc" id="L317">        range = calcSubIteratorRange(range);</span>
<span class="fc" id="L318">        int offset = (int)(range.from-this.getRange().from);</span>
<span class="fc" id="L319">        return new ChunkIterator(offset, range, this.a);</span>
    }
    @Override
    public RangedListIterator&lt;T&gt; subListIterator(LongRange range) {
<span class="fc" id="L323">        range = calcSubIteratorRange(range);</span>
<span class="fc" id="L324">        int offset = (int)(range.from-this.getRange().from);</span>
<span class="fc" id="L325">        return new ChunkListIterator&lt;T&gt;(offset, range, this.a);</span>
    }
    @Override
    public RangedListIterator&lt;T&gt; subListIterator(LongRange range, long i0) {
<span class="fc" id="L329">        range = calcSubIteratorRange(range);</span>
<span class="fc" id="L330">        int offset = (int)(range.from-this.getRange().from);</span>
<span class="fc" id="L331">        return new ChunkListIterator&lt;T&gt;(offset, range, i0, this.a);</span>
    }



    /**
     * {@inheritDoc}
     */
    @Override
    public Object[] toArray() {
<span class="fc" id="L341">        return a;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Object[] toArray(LongRange newRange) {
<span class="fc bfc" id="L349" title="All 2 branches covered.">        if (!range.contains(newRange)) {</span>
<span class="fc" id="L350">            throw new IndexOutOfBoundsException(rangeMsg(newRange));</span>
        }
<span class="fc bfc" id="L352" title="All 4 branches covered.">        if (newRange.from == range.from &amp;&amp; newRange.to == range.to) {</span>
<span class="fc" id="L353">            return a;</span>
        }
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (newRange.from == newRange.to) {</span>
<span class="fc" id="L356">            return new Object[0];</span>
        }
<span class="fc" id="L358">        final long newSize = (newRange.to - newRange.from);</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (newSize &gt; Config.maxChunkSize) {</span>
<span class="nc" id="L360">            throw new IllegalArgumentException(&quot;[Chunk] the size of the result cannot exceed &quot; + Config.maxChunkSize);</span>
        }
<span class="fc" id="L362">        final Object[] newRail = new Object[(int) newSize];</span>
<span class="fc" id="L363">        Arrays.fill(newRail, a[0]);</span>
<span class="fc" id="L364">        System.arraycopy(a, (int) (newRange.from - range.from), newRail, 0, (int) newSize);</span>
<span class="fc" id="L365">        return newRail;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Chunk&lt;T&gt; toChunk(LongRange newRange) {
<span class="fc" id="L373">        final Object[] newRail = toArray(newRange);</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">        if (newRail == a) {</span>
<span class="fc" id="L375">            return this;</span>
        }
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (newRail.length == 0) {</span>
<span class="fc" id="L378">            throw new IllegalArgumentException(&quot;[Chunk] toChunk(emptyRange) is not permitted.&quot;);</span>
        }
<span class="fc" id="L380">        return new Chunk&lt;&gt;(newRange, newRail);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;T&gt; toList(LongRange r) {
<span class="fc" id="L388">        final ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;((int) r.size());</span>
<span class="fc" id="L389">        forEach(r, (t) -&gt; list.add(t));</span>
<span class="fc" id="L390">        return list;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        if (range == null) {</span>
<span class="nc" id="L399">            return &quot;[Chunk] in Construction&quot;;</span>
        }
<span class="fc" id="L401">        final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L402">        sb.append(&quot;[&quot; + range + &quot;]:&quot;);</span>
<span class="fc" id="L403">        final long sz = Config.omitElementsToString ? Math.min(size(), Config.maxNumElementsToString) : size();</span>

<span class="fc bfc" id="L405" title="All 4 branches covered.">        for (long i = range.from, c = 0; i &lt; range.to &amp;&amp; c &lt; sz; i++, c++) {</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">            if (c &gt; 0) {</span>
<span class="fc" id="L407">                sb.append(&quot;,&quot;);</span>
            }
<span class="fc" id="L409">            sb.append(&quot;&quot; + get(i));</span>
            // if (c == sz) {
            // break;
            // }
        }
<span class="fc bfc" id="L414" title="All 2 branches covered.">        if (sz &lt; size()) {</span>
<span class="fc" id="L415">            sb.append(&quot;...(omitted &quot; + (size() - sz) + &quot; elements)&quot;);</span>
        }
<span class="fc" id="L417">        return sb.toString();</span>
    }

    @Override
    public void write(Kryo kryo, Output output) {
<span class="fc" id="L422">        kryo.writeClassAndObject(output, range);</span>
<span class="fc" id="L423">        kryo.writeClassAndObject(output, a);</span>
<span class="fc" id="L424">    }</span>

    private void writeObject(ObjectOutputStream out) throws IOException {
        // System.out.println(&quot;writeChunk:&quot;+this);
<span class="fc" id="L428">        out.writeObject(range);</span>
<span class="fc" id="L429">        out.writeObject(a);</span>
<span class="fc" id="L430">    }</span>

    /*
     * public static void main(String[] args) { long i = 5; Chunk&lt;Integer&gt; c = new
     * Chunk&lt;&gt;(new LongRange(10 * i, 11 * i)); System.out.println(&quot;prepare: &quot; + c);
     * IntStream.range(0, (int) i).forEach(j -&gt; { int v = (int) (10 * i + j);
     * System.out.println(&quot;set@&quot; + v); c.set(10 * i + j, v); });
     * System.out.println(&quot;Chunk :&quot; + c);
     *
     * c.toArray(new LongRange(0, Config.maxChunkSize)); }
     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>