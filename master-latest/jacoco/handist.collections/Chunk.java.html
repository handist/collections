<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Chunk.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">Chunk.java</span></div><h1>Chunk.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.KryoSerializable;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import handist.collections.function.LongTBiConsumer;

/**
 * Large collection that can contain objects mapped to long indices.
 *
 * @param &lt;T&gt; type of the elements handled by this instance
 */
public class Chunk&lt;T&gt; extends RangedList&lt;T&gt; implements Serializable, KryoSerializable {

    /**
     * Iterator class for Chunk
     *
     * @param &lt;T&gt; type on which the iterator operates
     */
    private static class It&lt;T&gt; implements RangedListIterator&lt;T&gt; {
        private final Chunk&lt;T&gt; chunk;
        private int i; // offset inside the chunk
<span class="fc" id="L47">        private int lastReturnedShift = -1;</span>

<span class="fc" id="L49">        public It(Chunk&lt;T&gt; chunk) {</span>
<span class="fc" id="L50">            this.chunk = chunk;</span>
<span class="fc" id="L51">            this.i = -1;</span>
<span class="fc" id="L52">        }</span>

<span class="fc" id="L54">        public It(Chunk&lt;T&gt; chunk, long i0) {</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">            if (!chunk.range.contains(i0)) {</span>
<span class="fc" id="L56">                throw new IndexOutOfBoundsException();</span>
            }
<span class="fc" id="L58">            this.chunk = chunk;</span>
<span class="fc" id="L59">            this.i = (int) (i0 - chunk.range.from - 1);</span>
<span class="fc" id="L60">        }</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L64" title="All 2 branches covered.">            return i + 1 &lt; chunk.size();</span>
        }

        @Override
        public boolean hasPrevious() {
<span class="fc bfc" id="L69" title="All 2 branches covered.">            return i &gt; 0;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T next() {
<span class="fc" id="L75">            lastReturnedShift = 0;</span>
<span class="fc" id="L76">            return (T) chunk.a[++i];</span>
        }

        @Override
        public long nextIndex() {
<span class="fc" id="L81">            return chunk.range.from + i + 1;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T previous() {
<span class="fc" id="L87">            lastReturnedShift = 1;</span>
<span class="fc" id="L88">            return (T) chunk.a[i--];</span>
        }

        @Override
        public long previousIndex() {
<span class="fc" id="L93">            return chunk.range.from + i;</span>
        }

        @Override
        public void set(T e) {
<span class="fc bfc" id="L98" title="All 2 branches covered.">            if (lastReturnedShift == -1) {</span>
<span class="fc" id="L99">                throw new IllegalStateException(&quot;[Chunk.It] Either method &quot;</span>
                        + &quot;previous or next needs to be called before method set&quot; + &quot; can be used&quot;);
            }
<span class="fc" id="L102">            chunk.a[i + lastReturnedShift] = e; // FIXME THIS IS NOT CORRECT !!!</span>
<span class="fc" id="L103">        }</span>
    }

    /** Serial Version UID */
    private static final long serialVersionUID = -7691832846457812518L;

    /** Array containing the T objects */
    private Object[] a;

    /** Range on which this instance is defined */
    private LongRange range;

    /**
     * Builds a Chunk with the given range and no mapping.
     * &lt;p&gt;
     * The given LongRange should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
<span class="fc" id="L130">    public Chunk(LongRange range) {</span>
<span class="fc" id="L131">        final long size = range.to - range.from;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (size &gt; Config.maxChunkSize) {</span>
<span class="fc" id="L133">            throw new IllegalArgumentException(</span>
                    &quot;The given range &quot; + range + &quot; exceeds the maximum Chunk size &quot; + Config.maxChunkSize);
<span class="fc bfc" id="L135" title="All 2 branches covered.">        } else if (size &lt;= 0) {</span>
<span class="fc" id="L136">            throw new IllegalArgumentException(&quot;Cannot build a Chunk with &quot; + &quot;LongRange &quot; + range</span>
                    + &quot;, should have a strictly positive&quot; + &quot; size&quot;);
        }
<span class="fc" id="L139">        a = new Object[(int) size];</span>
<span class="fc" id="L140">        this.range = range;</span>
<span class="fc" id="L141">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange}. The provided
     * initializer generates the initial value of the element for each index. The
     * given LongRange should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range       the range of the chunk to build
     * @param initializer generates the initial value of the element for each index.
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
    public Chunk(LongRange range, Function&lt;Long, T&gt; initializer) {
<span class="fc" id="L160">        this(range);</span>
<span class="fc" id="L161">        range.forEach((long index) -&gt; {</span>
<span class="fc" id="L162">            a[(int) (index - range.from)] = initializer.apply(index);</span>
<span class="fc" id="L163">        });</span>
<span class="fc" id="L164">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange} and an initial
     * mapping for each long in the object array. The provided {@link LongRange} and
     * Object array should have the same size. An {@link IllegalArgumentException}
     * will be thrown otherwise.
     * &lt;p&gt;
     * The given {@link LongRange} should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @param a     array with the initial mapping for every long in the provided
     *              range
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range and object array.
     */
    public Chunk(LongRange range, Object[] a) {
<span class="fc" id="L187">        this(range);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        if (a.length != range.size()) {</span>
<span class="fc" id="L189">            throw new IllegalArgumentException(&quot;The length of the provided &quot; + &quot;array &lt;&quot; + a.length</span>
<span class="fc" id="L190">                    + &quot;&gt; does not match the size of the &quot; + &quot;LongRange &lt;&quot; + range.size() + &quot;&gt;&quot;);</span>
        }
        // TODO Do we check for objects in array a that are not of type T?
        // We can leave as is and let the code fail later in methods get and
        // others where a ClassCastException should be thrown.
<span class="fc" id="L195">        this.a = a;</span>
<span class="fc" id="L196">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange} with each long in
     * the provided range mapped to object t. The given LongRange should have a
     * strictly positive size. Giving a {@link LongRange} instance with identical
     * lower and upper bounds will result in a {@link IllegalArgumentException}
     * being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @param t     initial mapping for every long in the provided range
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
    public Chunk(LongRange range, T t) {
<span class="fc" id="L215">        this(range);</span>
        // TODO Is this what we really want to do?
        // The mapping will be on the SAME OBJECT for every long in LongRange.
        // Don't we need a Generator&lt;T&gt; generator as argument and create an
        // instance for each key with Arrays.setAll(a, generator) ?
<span class="fc" id="L220">        Arrays.fill(a, t);</span>
<span class="fc" id="L221">    }</span>

    /**
     * Returns a new Chunk defined on the same {@link LongRange} and with the same
     * contents as this instance.
     *
     * @return a copy of this instance
     */
    @Override
    public Chunk&lt;T&gt; clone() {
        // Object[] aClone = a.clone();
<span class="fc" id="L232">        final Object[] aClone = new Object[a.length];</span>

        //// FIXME: 2018/09/19 Need deep copy?
        // for (int i = 0; i &lt; a.length; i++) {
        // try {
        // aClone[i] = ((Cloneable) a[i]).clone();
        // } catch (CloneNotSupportedException e) {
        // e.printStackTrace();
        // }
        // }

<span class="fc" id="L243">        Arrays.fill(aClone, a[0]);</span>
<span class="fc" id="L244">        System.arraycopy(a, 0, aClone, 0, a.length);</span>

<span class="fc" id="L246">        return new Chunk&lt;&gt;(this.range, aClone);</span>
    }

    @Override
    public Chunk&lt;T&gt; cloneRange(LongRange newRange) {
<span class="fc bfc" id="L251" title="All 2 branches covered.">        return range == newRange ? clone() : toChunk(newRange);</span>
    }

    @Override
    public boolean contains(Object v) {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        for (final Object e : a) {</span>
<span class="fc bfc" id="L257" title="All 6 branches covered.">            if (v == null ? e == null : v.equals(e)) {</span>
<span class="fc" id="L258">                return true;</span>
            }
        }
<span class="fc" id="L261">        return false;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc" id="L266">        return RangedList.equals(this, o);</span>
    }

    @Override
    public &lt;U&gt; void forEach(LongRange range, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            Consumer&lt;? super U&gt; receiver) {
<span class="fc" id="L272">        rangeCheck(range);</span>
        // IntStream.range(begin, end).forEach();
<span class="fc bfc" id="L274" title="All 2 branches covered.">        for (long i = range.from; i &lt; range.to; i++) {</span>
<span class="fc" id="L275">            action.accept(get(i), receiver);</span>
        }
<span class="fc" id="L277">    }</span>

    @Override
    public void forEach(LongRange range, final Consumer&lt;? super T&gt; action) {
<span class="fc" id="L281">        rangeCheck(range);</span>
<span class="fc" id="L282">        final long from = range.from;</span>
<span class="fc" id="L283">        final long to = range.to;</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">        for (long i = from; i &lt; to; i++) {</span>
<span class="fc" id="L286">            action.accept(get(i));</span>
        }
<span class="fc" id="L288">    }</span>

    @Override
    public void forEach(LongRange range, final LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L292">        rangeCheck(range);</span>
        // IntStream.range(begin, end).forEach();
<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (long i = range.from; i &lt; range.to; i++) {</span>
<span class="fc" id="L295">            action.accept(i, get(i));</span>
        }
<span class="fc" id="L297">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public T get(long index) {
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (!getRange().contains(index)) {</span>
<span class="fc" id="L305">            throw new IndexOutOfBoundsException(rangeMsg(index));</span>
        }
<span class="fc" id="L307">        return getUnsafe(index);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public LongRange getRange() {
<span class="fc" id="L315">        return range;</span>
    }

    /**
     * Returns the element located at the provided index. The provided index is
     * presumed valid and as such, no bound checking is done.
     *
     * @param index index whose value should be returned
     * @return the object stored at the provided index, possibly {@code null}
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    final T getUnsafe(long index) { // when range check was done
<span class="fc" id="L327">        final long offset = index - range.from;</span>
<span class="fc" id="L328">        return (T) a[(int) offset];</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
<span class="nc" id="L336">        return RangedList.hashCode(this);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L344">        return new It&lt;&gt;(this);</span>
    }

    /**
     * Creates and returns a new {@link RangedListIterator} on the elements
     * contained by this instance
     *
     * @return a new {@link RangedListIterator}
     */
    public RangedListIterator&lt;T&gt; rangedListIterator() {
<span class="fc" id="L354">        return new It&lt;&gt;(this);</span>
    }

    /**
     * Creates and returns a new {@link RangedListIterator} starting at the
     * specified index on the elements contained by this instance
     *
     * @param index the index of the first element to be returned by calling method
     *              {@link RangedListIterator#next()}
     * @return a new {@link RangedListIterator} starting at the specified index
     */
    public RangedListIterator&lt;T&gt; rangedListIterator(long index) {
<span class="fc" id="L366">        return new It&lt;&gt;(this, index);</span>
    }

    private String rangeMsg(long index) {
<span class="fc" id="L370">        return &quot;[Chunk] range &quot; + index + &quot; is out of &quot; + getRange();</span>
    }

    private String rangeMsg(LongRange range) {
<span class="fc" id="L374">        return &quot;[Chunk] range &quot; + range + &quot; is not contained in &quot; + getRange();</span>
    }

    @Override
    public void read(Kryo kryo, Input input) {
<span class="fc" id="L379">        this.range = (LongRange) kryo.readClassAndObject(input);</span>
<span class="fc" id="L380">        this.a = (Object[]) kryo.readClassAndObject(input);</span>
<span class="fc" id="L381">    }</span>

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L384">        this.range = (LongRange) in.readObject();</span>
<span class="fc" id="L385">        this.a = (Object[]) in.readObject();</span>
        // System.out.println(&quot;readChunk:&quot;+this);
<span class="fc" id="L387">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public T set(long index, T value) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (!getRange().contains(index)) {</span>
<span class="fc" id="L395">            throw new IndexOutOfBoundsException(rangeMsg(index));</span>
        }
<span class="fc" id="L397">        return setUnsafe(index, value);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private final T setUnsafe(long index, T v) { // when range check was done
<span class="fc" id="L402">        final long offset = index - range.from;</span>
<span class="fc" id="L403">        final T prev = (T) a[(int) offset];</span>
<span class="fc" id="L404">        a[(int) offset] = v;</span>
<span class="fc" id="L405">        return prev;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public &lt;S&gt; void setupFrom(RangedList&lt;S&gt; from, Function&lt;? super S, ? extends T&gt; func) {
<span class="fc" id="L413">        rangeCheck(from.getRange());</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (range.size() &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L415">            throw new Error(&quot;[Chunk] the size of RangedList cannot exceed Integer.MAX_VALUE.&quot;);</span>
        }
<span class="fc" id="L417">        final LongTBiConsumer&lt;S&gt; consumer = (long index, S s) -&gt; {</span>
<span class="fc" id="L418">            final T r = func.apply(s);</span>
<span class="fc" id="L419">            a[(int) (index - range.from)] = r;</span>
<span class="fc" id="L420">        };</span>
<span class="fc" id="L421">        from.forEach(consumer);</span>
<span class="fc" id="L422">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public Object[] toArray() {
<span class="fc" id="L429">        return a;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Object[] toArray(LongRange newRange) {
<span class="fc bfc" id="L437" title="All 2 branches covered.">        if (!range.contains(newRange)) {</span>
<span class="fc" id="L438">            throw new IndexOutOfBoundsException(rangeMsg(newRange));</span>
        }
<span class="fc bfc" id="L440" title="All 4 branches covered.">        if (newRange.from == range.from &amp;&amp; newRange.to == range.to) {</span>
<span class="fc" id="L441">            return a;</span>
        }
<span class="fc bfc" id="L443" title="All 2 branches covered.">        if (newRange.from == newRange.to) {</span>
<span class="fc" id="L444">            return new Object[0];</span>
        }
<span class="fc" id="L446">        final long newSize = (newRange.to - newRange.from);</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (newSize &gt; Config.maxChunkSize) {</span>
<span class="nc" id="L448">            throw new IllegalArgumentException(&quot;[Chunk] the size of the result cannot exceed &quot; + Config.maxChunkSize);</span>
        }
<span class="fc" id="L450">        final Object[] newRail = new Object[(int) newSize];</span>
<span class="fc" id="L451">        Arrays.fill(newRail, a[0]);</span>
<span class="fc" id="L452">        System.arraycopy(a, (int) (newRange.from - range.from), newRail, 0, (int) newSize);</span>
<span class="fc" id="L453">        return newRail;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Chunk&lt;T&gt; toChunk(LongRange newRange) {
<span class="fc" id="L461">        final Object[] newRail = toArray(newRange);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (newRail == a) {</span>
<span class="fc" id="L463">            return this;</span>
        }
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (newRail.length == 0) {</span>
<span class="fc" id="L466">            throw new IllegalArgumentException(&quot;[Chunk] toChunk(emptyRange) is not permitted.&quot;);</span>
        }
<span class="fc" id="L468">        return new Chunk&lt;&gt;(newRange, newRail);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;T&gt; toList(LongRange r) {
<span class="nc" id="L476">        final ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;((int) r.size());</span>
<span class="nc" id="L477">        forEach(r, (t) -&gt; list.add(t));</span>
<span class="nc" id="L478">        return list;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (range == null) {</span>
<span class="nc" id="L487">            return &quot;[Chunk] in Construction&quot;;</span>
        }
<span class="fc" id="L489">        final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L490">        sb.append(&quot;[&quot; + range + &quot;]:&quot;);</span>
<span class="fc" id="L491">        final long sz = Config.omitElementsToString ? Math.min(size(), Config.maxNumElementsToString) : size();</span>

<span class="fc bfc" id="L493" title="All 4 branches covered.">        for (long i = range.from, c = 0; i &lt; range.to &amp;&amp; c &lt; sz; i++, c++) {</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (c &gt; 0) {</span>
<span class="fc" id="L495">                sb.append(&quot;,&quot;);</span>
            }
<span class="fc" id="L497">            sb.append(&quot;&quot; + get(i));</span>
            // if (c == sz) {
            // break;
            // }
        }
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (sz &lt; size()) {</span>
<span class="fc" id="L503">            sb.append(&quot;...(omitted &quot; + (size() - sz) + &quot; elements)&quot;);</span>
        }
<span class="fc" id="L505">        return sb.toString();</span>
    }

    @Override
    public void write(Kryo kryo, Output output) {
<span class="fc" id="L510">        kryo.writeClassAndObject(output, range);</span>
<span class="fc" id="L511">        kryo.writeClassAndObject(output, a);</span>
<span class="fc" id="L512">    }</span>

    private void writeObject(ObjectOutputStream out) throws IOException {
        // System.out.println(&quot;writeChunk:&quot;+this);
<span class="fc" id="L516">        out.writeObject(range);</span>
<span class="fc" id="L517">        out.writeObject(a);</span>
<span class="fc" id="L518">    }</span>

    /*
     * public static void main(String[] args) { long i = 5; Chunk&lt;Integer&gt; c = new
     * Chunk&lt;&gt;(new LongRange(10 * i, 11 * i)); System.out.println(&quot;prepare: &quot; + c);
     * IntStream.range(0, (int) i).forEach(j -&gt; { int v = (int) (10 * i + j);
     * System.out.println(&quot;set@&quot; + v); c.set(10 * i + j, v); });
     * System.out.println(&quot;Chunk :&quot; + c);
     *
     * c.toArray(new LongRange(0, Config.maxChunkSize)); }
     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>