<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Chunk.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">Chunk.java</span></div><h1>Chunk.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.function.Function;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.KryoSerializable;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

/**
 * Large collection that can contain objects mapped to long indices.
 *
 * @param &lt;T&gt; type of the elements handled by this instance
 */
public class Chunk&lt;T&gt; extends RangedList&lt;T&gt; implements Serializable, KryoSerializable {

    /** Serial Version UID */
    private static final long serialVersionUID = -7691832846457812518L;

    /** Array containing the T objects */
    private Object[] a;

    /** Range on which this instance is defined */
    private LongRange range;

    /**
     * Builds a Chunk with the given range and no mapping.
     * &lt;p&gt;
     * The given LongRange should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
<span class="fc" id="L59">    public Chunk(LongRange range) {</span>
<span class="fc" id="L60">        final long size = range.to - range.from;</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (size &gt; Config.maxChunkSize) {</span>
<span class="fc" id="L62">            throw new IllegalArgumentException(</span>
                    &quot;The given range &quot; + range + &quot; exceeds the maximum Chunk size &quot; + Config.maxChunkSize);
<span class="fc bfc" id="L64" title="All 2 branches covered.">        } else if (size &lt;= 0) {</span>
<span class="fc" id="L65">            throw new IllegalArgumentException(&quot;Cannot build a Chunk with &quot; + &quot;LongRange &quot; + range</span>
                    + &quot;, should have a strictly positive&quot; + &quot; size&quot;);
        }
<span class="fc" id="L68">        a = new Object[(int) size];</span>
<span class="fc" id="L69">        this.range = range;</span>
<span class="fc" id="L70">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange}. The provided
     * initializer generates the initial value of the element for each index. The
     * given LongRange should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range       the range of the chunk to build
     * @param initializer generates the initial value of the element for each index.
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
    public Chunk(LongRange range, Function&lt;Long, T&gt; initializer) {
<span class="fc" id="L89">        this(range);</span>
<span class="fc" id="L90">        range.forEach((long index) -&gt; {</span>
<span class="fc" id="L91">            a[(int) (index - range.from)] = initializer.apply(index);</span>
<span class="fc" id="L92">        });</span>
<span class="fc" id="L93">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange} and an initial
     * mapping for each long in the object array. The provided {@link LongRange} and
     * Object array should have the same size. An {@link IllegalArgumentException}
     * will be thrown otherwise.
     * &lt;p&gt;
     * The given {@link LongRange} should have a strictly positive size. Giving a
     * {@link LongRange} instance with identical lower and upper bounds will result
     * in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @param a     array with the initial mapping for every long in the provided
     *              range
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range and object array.
     */
    public Chunk(LongRange range, Object[] a) {
<span class="fc" id="L116">        this(range);</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (a.length != range.size()) {</span>
<span class="fc" id="L118">            throw new IllegalArgumentException(&quot;The length of the provided &quot; + &quot;array &lt;&quot; + a.length</span>
<span class="fc" id="L119">                    + &quot;&gt; does not match the size of the &quot; + &quot;LongRange &lt;&quot; + range.size() + &quot;&gt;&quot;);</span>
        }
        // TODO Do we check for objects in array a that are not of type T?
        // We can leave as is and let the code fail later in methods get and
        // others where a ClassCastException should be thrown.
<span class="fc" id="L124">        this.a = a;</span>
<span class="fc" id="L125">    }</span>

    /**
     * Builds a {@link Chunk} with the provided {@link LongRange} with each long in
     * the provided range mapped to object t. The given LongRange should have a
     * strictly positive size. Giving a {@link LongRange} instance with identical
     * lower and upper bounds will result in a {@link IllegalArgumentException}
     * being thrown.
     * &lt;p&gt;
     * If the {@link LongRange} provided has a range that exceeds
     * {@value handist.collections.Config#maxChunkSize}, an
     * {@link IllegalArgumentException} will be be thrown.
     *
     * @param range the range of the chunk to build
     * @param t     initial mapping for every long in the provided range
     * @throws IllegalArgumentException if a {@link Chunk} cannot be built with the
     *                                  provided range.
     */
    public Chunk(LongRange range, T t) {
<span class="fc" id="L144">        this(range);</span>
<span class="fc" id="L145">        Arrays.fill(a, t);</span>
<span class="fc" id="L146">    }</span>

    private LongRange calcSubIteratorRange(LongRange range) {
<span class="fc" id="L149">        range = this.getRange().intersection(range);</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (range == null) {</span>
<span class="nc" id="L151">            throw new IndexOutOfBoundsException();</span>
        }
<span class="fc" id="L153">        return range;</span>
    }

    /**
     * Returns a new Chunk defined on the same {@link LongRange} and with the same
     * contents as this instance.
     *
     * @return a copy of this instance
     */
    @Override
    public Chunk&lt;T&gt; clone() {
        // Object[] aClone = a.clone();
<span class="fc" id="L165">        final Object[] aClone = new Object[a.length];</span>

        //// FIXME: 2018/09/19 Need deep copy?
        // for (int i = 0; i &lt; a.length; i++) {
        // try {
        // aClone[i] = ((Cloneable) a[i]).clone();
        // } catch (CloneNotSupportedException e) {
        // e.printStackTrace();
        // }
        // }

<span class="fc" id="L176">        Arrays.fill(aClone, a[0]);</span>
<span class="fc" id="L177">        System.arraycopy(a, 0, aClone, 0, a.length);</span>

<span class="fc" id="L179">        return new Chunk&lt;&gt;(this.range, aClone);</span>
    }

    @Override
    public Chunk&lt;T&gt; cloneRange(LongRange newRange) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        return range == newRange ? clone() : toChunk(newRange);</span>
    }

    @Override
    public boolean contains(Object v) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        for (final Object e : a) {</span>
<span class="fc bfc" id="L190" title="All 6 branches covered.">            if (v == null ? e == null : v.equals(e)) {</span>
<span class="fc" id="L191">                return true;</span>
            }
        }
<span class="fc" id="L194">        return false;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc" id="L199">        return RangedList.equals(this, o);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T get(long index) {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (!getRange().contains(index)) {</span>
<span class="fc" id="L208">            throw new IndexOutOfBoundsException(rangeMsg(index));</span>
        }
<span class="fc" id="L210">        return getUnsafe(index);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public LongRange getRange() {
<span class="fc" id="L218">        return range;</span>
    }

    /**
     * Returns the element located at the provided index. The provided index is
     * presumed valid and as such, no bound checking is done.
     *
     * @param index index whose value should be returned
     * @return the object stored at the provided index, possibly {@code null}
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    final T getUnsafe(long index) { // when range check was done
<span class="fc" id="L230">        final long offset = index - range.from;</span>
<span class="fc" id="L231">        return (T) a[(int) offset];</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
<span class="fc" id="L239">        return RangedList.hashCode(this);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L247">        return new ChunkIterator&lt;&gt;(this.range, this.a);</span>
    }

    /**
     * Creates and returns a new {@link RangedListIterator} on the elements
     * contained by this instance
     *
     * @return a new {@link RangedListIterator}
     */
    @Override
    public RangedListIterator&lt;T&gt; listIterator() {
<span class="fc" id="L258">        return new ChunkListIterator&lt;&gt;(this.range, this.a);</span>
    }

    /**
     * Creates and returns a new {@link RangedListIterator} starting at the
     * specified index on the elements contained by this instance
     *
     * @param index the index of the first element to be returned by calling method
     *              {@link RangedListIterator#next()}
     * @return a new {@link RangedListIterator} starting at the specified index
     */
    @Override
    public RangedListIterator&lt;T&gt; listIterator(long index) {
<span class="fc" id="L271">        return new ChunkListIterator&lt;&gt;(this.range, index, this.a);</span>
    }

    private String rangeMsg(long index) {
<span class="fc" id="L275">        return &quot;[Chunk] range &quot; + index + &quot; is out of &quot; + getRange();</span>
    }

    private String rangeMsg(LongRange range) {
<span class="fc" id="L279">        return &quot;[Chunk] range &quot; + range + &quot; is not contained in &quot; + getRange();</span>
    }

    @Override
    public void read(Kryo kryo, Input input) {
<span class="fc" id="L284">        this.range = (LongRange) kryo.readClassAndObject(input);</span>
<span class="fc" id="L285">        this.a = (Object[]) kryo.readClassAndObject(input);</span>
<span class="fc" id="L286">    }</span>

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L289">        this.range = (LongRange) in.readObject();</span>
<span class="fc" id="L290">        this.a = (Object[]) in.readObject();</span>
        // System.out.println(&quot;readChunk:&quot;+this);
<span class="fc" id="L292">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public T set(long index, T value) {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (!getRange().contains(index)) {</span>
<span class="fc" id="L300">            throw new IndexOutOfBoundsException(rangeMsg(index));</span>
        }
<span class="fc" id="L302">        return setUnsafe(index, value);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private final T setUnsafe(long index, T v) { // when range check was done
<span class="fc" id="L307">        final long offset = index - range.from;</span>
<span class="fc" id="L308">        final T prev = (T) a[(int) offset];</span>
<span class="fc" id="L309">        a[(int) offset] = v;</span>
<span class="fc" id="L310">        return prev;</span>
    }

    @Override
    public Iterator&lt;T&gt; subIterator(LongRange range) {
<span class="fc" id="L315">        range = calcSubIteratorRange(range);</span>
<span class="fc" id="L316">        final int offset = (int) (range.from - this.getRange().from);</span>
<span class="fc" id="L317">        return new ChunkIterator&lt;&gt;(offset, range, this.a);</span>
    }

    @Override
    public RangedListIterator&lt;T&gt; subListIterator(LongRange range) {
<span class="fc" id="L322">        range = calcSubIteratorRange(range);</span>
<span class="fc" id="L323">        final int offset = (int) (range.from - this.getRange().from);</span>
<span class="fc" id="L324">        return new ChunkListIterator&lt;&gt;(offset, range, this.a);</span>
    }

    @Override
    public RangedListIterator&lt;T&gt; subListIterator(LongRange range, long i0) {
<span class="fc" id="L329">        range = calcSubIteratorRange(range);</span>
<span class="fc" id="L330">        final int offset = (int) (range.from - this.getRange().from);</span>
<span class="fc" id="L331">        return new ChunkListIterator&lt;&gt;(offset, range, i0, this.a);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Object[] toArray() {
<span class="fc" id="L339">        return a;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Object[] toArray(LongRange newRange) {
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (!range.contains(newRange)) {</span>
<span class="fc" id="L348">            throw new IndexOutOfBoundsException(rangeMsg(newRange));</span>
        }
<span class="fc bfc" id="L350" title="All 4 branches covered.">        if (newRange.from == range.from &amp;&amp; newRange.to == range.to) {</span>
<span class="fc" id="L351">            return a;</span>
        }
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (newRange.from == newRange.to) {</span>
<span class="fc" id="L354">            return new Object[0];</span>
        }
<span class="fc" id="L356">        final long newSize = (newRange.to - newRange.from);</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (newSize &gt; Config.maxChunkSize) {</span>
<span class="nc" id="L358">            throw new IllegalArgumentException(&quot;[Chunk] the size of the result cannot exceed &quot; + Config.maxChunkSize);</span>
        }
<span class="fc" id="L360">        final Object[] newRail = new Object[(int) newSize];</span>
<span class="fc" id="L361">        Arrays.fill(newRail, a[0]);</span>
<span class="fc" id="L362">        System.arraycopy(a, (int) (newRange.from - range.from), newRail, 0, (int) newSize);</span>
<span class="fc" id="L363">        return newRail;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Chunk&lt;T&gt; toChunk(LongRange newRange) {
<span class="fc" id="L371">        final Object[] newRail = toArray(newRange);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (newRail == a) {</span>
<span class="fc" id="L373">            return this;</span>
        }
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (newRail.length == 0) {</span>
<span class="fc" id="L376">            throw new IllegalArgumentException(&quot;[Chunk] toChunk(emptyRange) is not permitted.&quot;);</span>
        }
<span class="fc" id="L378">        return new Chunk&lt;&gt;(newRange, newRail);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;T&gt; toList(LongRange r) {
<span class="fc" id="L386">        final ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;((int) r.size());</span>
<span class="fc" id="L387">        forEach(r, (t) -&gt; list.add(t));</span>
<span class="fc" id="L388">        return list;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (range == null) {</span>
<span class="nc" id="L397">            return &quot;[Chunk] in Construction&quot;;</span>
        }
<span class="fc" id="L399">        final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L400">        sb.append(&quot;[&quot; + range + &quot;]:&quot;);</span>
<span class="fc" id="L401">        final long sz = Config.omitElementsToString ? Math.min(size(), Config.maxNumElementsToString) : size();</span>

<span class="fc bfc" id="L403" title="All 4 branches covered.">        for (long i = range.from, c = 0; i &lt; range.to &amp;&amp; c &lt; sz; i++, c++) {</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            if (c &gt; 0) {</span>
<span class="fc" id="L405">                sb.append(&quot;,&quot;);</span>
            }
<span class="fc" id="L407">            sb.append(&quot;&quot; + get(i));</span>
            // if (c == sz) {
            // break;
            // }
        }
<span class="fc bfc" id="L412" title="All 2 branches covered.">        if (sz &lt; size()) {</span>
<span class="fc" id="L413">            sb.append(&quot;...(omitted &quot; + (size() - sz) + &quot; elements)&quot;);</span>
        }
<span class="fc" id="L415">        return sb.toString();</span>
    }

    @Override
    public void write(Kryo kryo, Output output) {
<span class="fc" id="L420">        kryo.writeClassAndObject(output, range);</span>
<span class="fc" id="L421">        kryo.writeClassAndObject(output, a);</span>
<span class="fc" id="L422">    }</span>

    private void writeObject(ObjectOutputStream out) throws IOException {
        // System.out.println(&quot;writeChunk:&quot;+this);
<span class="fc" id="L426">        out.writeObject(range);</span>
<span class="fc" id="L427">        out.writeObject(a);</span>
<span class="fc" id="L428">    }</span>

    /*
     * public static void main(String[] args) { long i = 5; Chunk&lt;Integer&gt; c = new
     * Chunk&lt;&gt;(new LongRange(10 * i, 11 * i)); System.out.println(&quot;prepare: &quot; + c);
     * IntStream.range(0, (int) i).forEach(j -&gt; { int v = (int) (10 * i + j);
     * System.out.println(&quot;set@&quot; + v); c.set(10 * i + j, v); });
     * System.out.println(&quot;Chunk :&quot; + c);
     *
     * c.toArray(new LongRange(0, Config.maxChunkSize)); }
     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>