<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractSquareRangedList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">AbstractSquareRangedList.java</span></div><h1>AbstractSquareRangedList.java</h1><pre class="source lang-java linenums">package handist.collections;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Random;
import java.util.function.Consumer;

import handist.collections.dist.TeamedPlaceGroup;
import handist.collections.function.LongTBiConsumer;
import handist.collections.function.SquareIndexTConsumer;
import handist.collections.util.Splitter;

/**
 * AbstractSquareRangedList is a general interface for SquareRangedList and
 * RangedListProduct.
 *
 * @param &lt;T&gt; represents the type of each element
 * @param &lt;X&gt; represents the type used for the return type of method
 *            {@link #subView(SquareRange)}or {@link #split(int, int)} methods.
 *            In practice, SquareChunk or SquareRangedListView uses
 *            SquareRangedList as X and RangedListProduct uses RangedListProduct
 *            as X.
 */
public interface AbstractSquareRangedList&lt;T, X extends AbstractSquareRangedList&lt;T, X&gt;&gt; extends Iterable&lt;T&gt; {

    public static int hashCode(SquareRangedList&lt;?&gt; rlist) {
<span class="nc" id="L29">        int hashCode = 1;</span>
        // code from JavaAPI doc of List
<span class="nc bnc" id="L31" title="All 2 branches missed.">        for (final Object o : rlist) {</span>
<span class="nc bnc" id="L32" title="All 2 branches missed.">            hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());</span>
<span class="nc" id="L33">        }</span>
<span class="nc" id="L34">        return hashCode;</span>
    }

    /**
     * Returns a list of each column of this instance.
     *
     * @return a list of each column of this instance.
     */
    RangedList&lt;RangedList&lt;T&gt;&gt; asColumnList();

    /**
     * Returns a list of each row of this instance
     *
     * @return a list of each row of this instance.
     */
    RangedList&lt;RangedList&lt;T&gt;&gt; asRowList();

    /**
     * Indicates if this list contains the provided object. More formally if the
     * list contains at least one object {@code a} such that
     * &lt;code&gt;(a == null) ? o == null : a.equals(o);&lt;/code&gt; is true.
     *
     * @param v the object whose presence is to be checked
     * @return {@code true} if the collection contains {@code o}, {@code false}
     *         otherwise
     */
    boolean contains(Object v);

    /**
     * Performs the provided action on every element in the collection
     *
     * @param action the action for each element
     */
    @Override
    void forEach(Consumer&lt;? super T&gt; action);

    /**
     * Performs the provided action on every element in the collection
     *
     * @param action the action for each element
     */
    void forEach(SquareIndexTConsumer&lt;? super T&gt; action);

    /**
     * Performs the provided action on every element in the collection for provided
     * range.
     *
     * @param subrange the range of provided action
     * @param action   the action for each element
     */
    void forEach(SquareRange subrange, Consumer&lt;? super T&gt; action);

    /**
     * Performs the provided action with an index on every element in the collection
     * for provided range.
     *
     * @param subrange the range of provided action
     * @param action   the action for each element
     */
    void forEach(SquareRange subrange, SquareIndexTConsumer&lt;? super T&gt; action);

    /**
     * Performs the provided action with an index on every column in the collection
     * for provided range.
     *
     * @param range        the range of provided action
     * @param columnAction the action for each column
     */
    void forEachColumn(LongRange range, LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; columnAction);

    /**
     * Performs the provided action with an index on every column in the
     * collection..
     *
     * @param columnAction the action for each column
     */
    void forEachColumn(LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; columnAction);

    /**
     * Performs the provided action with an index on every row in the collection for
     * provided range.
     *
     * @param range     the range of provided action
     * @param rowAction the action for each row
     */
    void forEachRow(LongRange range, LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; rowAction);

    /**
     * Performs the provided action with an index on every row in the collection..
     *
     * @param rowAction the action for each row
     */
    void forEachRow(LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; rowAction);

    /**
     * Performs the provided action with {@link SquareSiblingAccessor} on every
     * element in the collection for provided range.
     *
     * @param range  the range of provided action
     * @param action the action for each element
     */
    void forEachWithSiblings(SquareRange range, Consumer&lt;SquareSiblingAccessor&lt;T&gt;&gt; action);

    /**
     * Returns the value associated with the provided {@code long} indexes.
     *
     * @param index  outer index of the value to return
     * @param index2 inner index of the value to return
     * @return the value associated with this index
     */
    T get(long index, long index2);

    /**
     * Returns the view for the provided column in Square.
     *
     * @param column the column for view
     * @return the {@link RangedList} view of provided column
     */
    RangedList&lt;T&gt; getColumnView(long column);

    /**
     * Obtain the {@link SquareRange} on which this instance is defined.
     *
     * @return the {@link SquareRange} object representing
     */
    SquareRange getRange();

    /**
     * Returns the view for the provided row in Square.
     *
     * @param row the row for view
     * @return the {@link RangedList} view of provide row
     */
    RangedList&lt;T&gt; getRowView(long row);

    /**
     * Returns the view for the provided ranges in Square.
     *
     * @param ranges the {@link SquareRange} for views
     * @return the views of provided {@link SquareRange}.
     */
    default List&lt;X&gt; getViews(List&lt;SquareRange&gt; ranges) {
<span class="fc" id="L176">        final List&lt;X&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L177">        ranges.forEach((SquareRange range) -&gt; {</span>
<span class="fc" id="L178">            results.add(subView(range));</span>
<span class="fc" id="L179">        });</span>
<span class="fc" id="L180">        return results;</span>
    }

    @Override
    abstract Iterator&lt;T&gt; iterator();

    /**
     * Checks if the provided {@code long index} point is included in the range this
     * instance is defined on, i.e. if method {@link #get(long, long)}, or
     * {@link #set(long,long,Object)} can be safely called with the provided
     * parameter.
     *
     * @param outer the long value whose represents the outer index of the point
     * @param inner the long value whose represents the inner index of the point
     * @throws IndexOutOfBoundsException if the provided index is outside the range
     *                                   this instance is defined on
     */
    public default void rangeCheck(long outer, long inner) {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (!this.getRange().contains(outer, inner)) {</span>
<span class="nc" id="L199">            throw new IndexOutOfBoundsException(&quot;[SquareRangedListAbstract] range mismatch: &quot; + this.getRange()</span>
                    + &quot; does not include point(&quot; + outer + &quot;,&quot; + inner + &quot;)&quot;);
        }
<span class="fc" id="L202">    }</span>

    /**
     * Checks if the provided {@link SquareRange} is included in the range of this
     * instance.
     *
     * @param target LongRange whose inclusion in this instance is to be checked
     * @throws ArrayIndexOutOfBoundsException if the provided {@link SquareRange} is
     *                                        not included in this instance
     */
    public default void rangeCheck(SquareRange target) {
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">        if (!this.getRange().contains(target)) {</span>
<span class="nc" id="L214">            throw new ArrayIndexOutOfBoundsException(</span>
<span class="nc" id="L215">                    &quot;[SquareRangedListAbstract] range mismatch:&quot; + this.getRange() + &quot; does not include &quot; + target);</span>
        }
<span class="fc" id="L217">    }</span>

    /**
     * Sets the provided value at the specified index.
     *
     * @param index  the outer index
     * @param index2 the inner index
     * @param value  the value to set.
     * @return previous value that was stored at this index, {@code null} if there
     *         was no previous value or the previous value stored was {@code null}
     */
    T set(long index, long index2, T value);

    /**
     * Return the list of {@link SquareRangedList} that split into &lt;em&gt;outer&lt;/em&gt; +
     * &lt;em&gt;inner&lt;/em&gt; {@link SquareRangedList} instances of equal size (or near
     * equal size if the size of this instance is not divisible.
     *
     * @param outer the number of split of outer loop.
     * @param inner the number of split of outer loop.
     * @return a list of &lt;em&gt;outer&lt;/em&gt; * &lt;em&gt;inner&lt;/em&gt; {@link SquareRangedList}
     *         instance.
     */
    default List&lt;X&gt; split(int outer, int inner) {
<span class="fc" id="L241">        return getViews(splitRange(outer, inner));</span>
    }

    /**
     * Splits equally squares into &lt;em&gt;outer&lt;/em&gt; * &lt;em&gt;inner&lt;/em&gt; and squares are
     * divided to list of sizes &lt;em&gt;num&lt;/em&gt;.
     *
     * @param outer     the number of split outer range.
     * @param inner     the number ot split inner range.
     * @param num       the number dividing squares to {@link List}.
     * @param randomize if true, splited squares are added in order from begining,
     *                  else, added in random.
     * @return List of list of {@link SquareRangedList}. Size of outer list is
     *         numTherads. Size of inner list is number of {@link SquareRangedList}
     *         for each thread.
     */
    default List&lt;List&lt;X&gt;&gt; splitN(int outer, int inner, int num, boolean randomize) {
<span class="fc" id="L258">        final List&lt;SquareRange&gt; ranges = splitRange(outer, inner);</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (randomize) {</span>
<span class="fc" id="L260">            Collections.shuffle(ranges);</span>
        }
<span class="fc" id="L262">        final List&lt;List&lt;X&gt;&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L263">        final Splitter split = new Splitter(ranges.size(), num);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">        for (int i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L265">            final List&lt;SquareRange&gt; assigned = split.getIth(i, ranges);</span>
<span class="fc" id="L266">            results.add(getViews(assigned));</span>
        }
<span class="fc" id="L268">        return results;</span>
    }

    /**
     * Return the list of {@link SquareRange} that split into &lt;em&gt;outer&lt;/em&gt; +
     * &lt;em&gt;inner&lt;/em&gt; {@link SquareRange} instances of equal size (or near equal
     * size if the size of this instance is not divisible.
     *
     * @param outer the number of split of outer loop.
     * @param inner the number of split of outer loop.
     * @return a list of &lt;em&gt;outer&lt;/em&gt; * &lt;em&gt;inner&lt;/em&gt; {@link SquareRange}
     *         instance.
     */
    default List&lt;SquareRange&gt; splitRange(int outer, int inner) {
<span class="fc" id="L282">        return getRange().split(outer, inner);</span>
    }

    abstract Iterator&lt;T&gt; subIterator(SquareRange range);

    /**
     * Provides a SquareRangedList of the elements contained in this instance on the
     * specified {@link SquareRange}.
     * &lt;p&gt;
     * If the provided range exceeds the indices contained in this instance the
     * method will return the elements it contains that fit within the provided
     * range.
     *
     * @param range range of indices of which a copy is desired
     * @return a ranged list of the elements contained in this
     *         {@link SquareRangedList} that fit in the provided range.
     */
    X subView(SquareRange range);

    /**
     * Splits equally squares into &lt;em&gt;outer&lt;/em&gt; * &lt;em&gt;inner&lt;/em&gt; and return some
     * squares for each host equally. Assigned squares are divided to list of sizes
     * nThreads.
     *
     * @param outer      the number of split outer range.
     * @param inner      the number ot split inner range.
     * @param pg         the group between which this ranged list is split
     * @param numThreads the number of threads to whom squares should be assigned to
     * @param seed       seed used to randomly assign squares to hosts, must the
     *                   same on all hosts
     * @return List of list of {@link SquareRangedList}. Size of outer list is
     *         numTherads. Size of inner list is number of {@link SquareRangedList}
     *         for each thread.
     */
    default List&lt;List&lt;X&gt;&gt; teamedSplitNM(int outer, int inner, TeamedPlaceGroup pg, int numThreads, long seed) {
<span class="fc" id="L317">        final int numHosts = pg.size();</span>
<span class="fc" id="L318">        final int ithHost = pg.rank();</span>
<span class="fc" id="L319">        final Random rand = new Random(seed);</span>
<span class="fc" id="L320">        final List&lt;SquareRange&gt; ranges = splitRange(outer, inner);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (rand != null) {</span>
<span class="fc" id="L322">            Collections.shuffle(ranges, rand);</span>
        }
<span class="fc" id="L324">        final List&lt;List&lt;X&gt;&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L325">        final Splitter split = new Splitter(ranges.size(), numHosts);</span>
<span class="fc" id="L326">        final Splitter splitIn = new Splitter(split.ith(ithHost), split.ith(ithHost + 1), numThreads);</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">        for (int i = 0; i &lt; numThreads; i++) {</span>
<span class="fc" id="L328">            final List&lt;SquareRange&gt; assigned = splitIn.getIth(i, ranges);</span>
<span class="fc" id="L329">            results.add(getViews(assigned));</span>
        }
<span class="fc" id="L331">        return results;</span>
    }

    /**
     * Returns the elements contained in this instance in a one-dimensional array.
     * Ordered by outer and inner loop in {@link SquareRange}.
     *
     * @return array containing the objects contained in this instance
     */
    Object[] toArray();

    /**
     * Returns the elements contained in this instance in a one-dimensional array.
     * Ordered by outer and inner loop in {@link SquareRange}.
     *
     * @param newRange the range of elements to take
     * @return array containing the objects contained in this instance
     */
    Object[] toArray(SquareRange newRange);

    /**
     * Returns the elements contained in this instance in a one-dimensional
     * {@link Chunk}. Ordered by outer and inner loop in {@link SquareRange}.
     *
     * @param newRange the range of elements to take
     * @return chunk containing the objects contained in this instance
     */
    SquareChunk&lt;T&gt; toChunk(SquareRange newRange);

    /**
     * Returns the elements contained in this instance in a one-dimensional
     * {@link List}. Ordered by outer and inner loop in {@link SquareRange}.
     *
     * @param newRange the range of elements to take
     * @return list containing the objects contained in this instance
     */
    List&lt;T&gt; toList(SquareRange newRange);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>