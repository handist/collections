<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ParallelMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">ParallelMap.java</span></div><h1>ParallelMap.java</h1><pre class="source lang-java linenums">package handist.collections;

import static apgas.Constructs.*;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;

import handist.collections.function.SerializableBiConsumer;
import handist.collections.function.SerializableConsumer;

public class ParallelMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Serializable {

    private static final long serialVersionUID = 2613768150080256264L;

    protected Map&lt;K, V&gt; data;

    protected Function&lt;K, V&gt; proxyGenerator;

    public ParallelMap() {
<span class="fc" id="L30">        this(new HashMap&lt;&gt;());</span>
<span class="fc" id="L31">    }</span>

<span class="fc" id="L33">    protected ParallelMap(Map&lt;K, V&gt; data) {</span>
<span class="fc" id="L34">        this.data = data;</span>
<span class="fc" id="L35">    }</span>

    /**
     * Remove the all local entries.
     */
    @Override
    public void clear() {
<span class="fc" id="L42">        data.clear();</span>
<span class="fc" id="L43">    }</span>

    /**
     * Return true if the specified entry is exist in the local collection.
     *
     * @param key a key.
     * @return true is the specified object is a key present in the local map,
     */
    @Override
    public boolean containsKey(Object key) {
<span class="fc" id="L53">        return data.containsKey(key);</span>
    }

    /**
     * Indicates if the provided value is contained in the local map.
     */
    @Override
    public boolean containsValue(Object value) {
<span class="nc" id="L61">        return data.containsValue(value);</span>
    }

    boolean debugPrint() {
<span class="nc" id="L65">        return true;</span>
    }

    /**
     * Removes the provided key from the local map, returns {@code true} if there
     * was a previous obejct mapped to this key, {@code false} if there were no
     * mapping with this key or if the mapping was a {@code null} object
     *
     * @param key the key to remove from this local map
     * @return true if a mapping was removed as a result of this operation, false
     *         otherwise
     */
    public boolean delete(K key) {
<span class="nc" id="L78">        final V result = data.remove(key);</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">        return (result != null);</span>
    }

    /**
     * Return the Set of local entries.
     *
     * @return the Set of local entries.
     */
    @Override
    public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() {
<span class="fc" id="L89">        return data.entrySet();</span>
    }

    /**
     * Apply the specified operation with each Key/Value pair contained in the local
     * collection.
     *
     * @param action the operation to perform
     */
    @Override
    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (!data.isEmpty()) {</span>
<span class="fc" id="L101">            data.forEach(action);</span>
        }
<span class="fc" id="L103">    }</span>

    public void forEach(SerializableConsumer&lt;V&gt; action) {
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (final Entry&lt;K, V&gt; entry : data.entrySet()) {</span>
<span class="fc" id="L107">            action.accept(entry.getValue());</span>
<span class="fc" id="L108">        }</span>
<span class="fc" id="L109">    }</span>

    private void forEachParallelBodyLocal(SerializableConsumer&lt;V&gt; action) {
<span class="fc" id="L112">        final List&lt;Collection&lt;V&gt;&gt; separated = separateLocalValues(Runtime.getRuntime().availableProcessors() * 2);</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (final Collection&lt;V&gt; sub : separated) {</span>
<span class="fc" id="L114">            async(() -&gt; {</span>
<span class="fc" id="L115">                sub.forEach(action);</span>
<span class="fc" id="L116">            });</span>
<span class="fc" id="L117">        }</span>
<span class="fc" id="L118">    }</span>

    /**
     * Helper method which separates the keys contained in the local map into even
     * batches for the number of threads available on the system and applies the
     * provided action on each key/value pair contained in the collection in
     * parallel
     *
     * @param action action to perform on the key/value pair contained in the map
     */
    private void forEachParallelKey(SerializableBiConsumer&lt;? super K, ? super V&gt; action) {
<span class="fc" id="L129">        final int batches = Runtime.getRuntime().availableProcessors();</span>

        // Dispatch the existing keys into batches
<span class="fc" id="L132">        final List&lt;Collection&lt;K&gt;&gt; keys = new ArrayList&lt;&gt;(batches);</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (int i = 0; i &lt; batches; i++) {</span>
<span class="fc" id="L134">            keys.add(new HashSet&lt;&gt;());</span>
        }
        // Round-robin of keys into batches
<span class="fc" id="L137">        int i = 0;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (final K k : data.keySet()) {</span>
<span class="fc" id="L139">            keys.get(i++).add(k);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (i &gt;= batches) {</span>
<span class="fc" id="L141">                i = 0;</span>
            }
<span class="fc" id="L143">        }</span>

        // Spawn asynchronous activity for each batch
<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (final Collection&lt;K&gt; keysToProcess : keys) {</span>
<span class="fc" id="L147">            async(() -&gt; {</span>
                // Apply the supplied action on each key in the batch
<span class="fc bfc" id="L149" title="All 2 branches covered.">                for (final K key : keysToProcess) {</span>
<span class="fc" id="L150">                    final V value = data.get(key);</span>
<span class="fc" id="L151">                    action.accept(key, value);</span>
<span class="fc" id="L152">                }</span>
<span class="fc" id="L153">            });</span>
<span class="fc" id="L154">        }</span>
<span class="fc" id="L155">    }</span>

    /**
     * Return the element for the provided key. If there is no element at the index,
     * return null.
     *
     * When an agent generator is set on this instance and there is no element at
     * the index, a proxy value for the index is generated as a return value.
     *
     * @param key the index of the value to retrieve
     * @return the element associated with {@code key}, or null if this map contains
     *         no mapping for the key
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public V get(Object key) {
<span class="fc" id="L171">        final V result = data.get(key);</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L173">            return result;</span>
        }
<span class="pc bpc" id="L175" title="1 of 4 branches missed.">        if (proxyGenerator != null &amp;&amp; !data.containsKey(key)) {</span>
<span class="fc" id="L176">            return proxyGenerator.apply((K) key);</span>
        } else {
<span class="fc" id="L178">            return null;</span>
        }
    }

    /**
     * Indicates if the local distributed map is empty or not
     *
     * @return {@code true} if there are no mappings in the local map
     */
    @Override
    public boolean isEmpty() {
<span class="nc" id="L189">        return data.isEmpty();</span>
    }

    /**
     * Return the Set of local keys.
     *
     * @return the Set of local keys.
     */
    @Override
    public Set&lt;K&gt; keySet() {
<span class="fc" id="L199">        return data.keySet();</span>
    }

    /**
     * Apply the same operation on the all elements including remote places and
     * creates a new {@link ParallelMap} with the same keys as this instance and the
     * result of the mapping operation as values.
     *
     * @param &lt;W&gt; result type of mapping operation
     * @param op  the map operation from type &lt;code&gt;V&lt;/code&gt; to &lt;code&gt;W&lt;/code&gt;
     * @return a DistMap from &lt;code&gt;K&lt;/code&gt; to &lt;code&gt;W&lt;/code&gt; built from applying
     *         the mapping operation on each element of this instance
     */
    public &lt;W&gt; ParallelMap&lt;K, W&gt; map(Function&lt;V, W&gt; op) {
<span class="nc" id="L213">        throw new Error(&quot;not supported yet&quot;);</span>
        // TODO
        /*
         * return new ParallelMap&lt;T,S&gt;(placeGroup, team, () -&gt; { val dst = new
         * HashMap&lt;T,S&gt;(); for (entry in entries()) { val key = entry.getKey(); val
         * value = entry.getValue(); dst(key) = op(value); } return dst; });
         */
    }

    /**
     * Parallel version of {@link #forEach(BiConsumer)}
     *
     * @param action the action to perform on every key/value pair contained in this
     *               local map
     */
    public void parallelForEach(SerializableBiConsumer&lt;? super K, ? super V&gt; action) {
<span class="fc" id="L229">        finish(() -&gt; {</span>
<span class="fc" id="L230">            forEachParallelKey(action);</span>
<span class="fc" id="L231">        });</span>
<span class="fc" id="L232">    }</span>

    public void parallelForEach(SerializableConsumer&lt;V&gt; action) {
<span class="fc" id="L235">        parallelForEachLocal(action);</span>
<span class="fc" id="L236">    }</span>

    private void parallelForEachLocal(SerializableConsumer&lt;V&gt; action) {
<span class="fc" id="L239">        finish(() -&gt; {</span>
<span class="fc" id="L240">            forEachParallelBodyLocal(action);</span>
<span class="fc" id="L241">        });</span>
<span class="fc" id="L242">    }</span>

    void printLocalData() {
<span class="nc" id="L245">        System.out.println(this);</span>
<span class="nc" id="L246">    }</span>

    /**
     * Put a new entry.
     *
     * @param key   the key of the new entry.
     * @param value the value of the new entry.
     * @return the previous value associated with {@code key}, or {@code null} if
     *         there was no mapping for {@code key}.(A {@code null} return can also
     *         indicate that the map previously associated {@code null} with
     *         {@code key}.)
     */
    @Override
    public V put(K key, V value) {
<span class="fc" id="L260">        return data.put(key, value);</span>
    }

    /**
     * Adds all the mappings contained in the specified map into this local map.
     */
    @Override
    public void putAll(java.util.Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc" id="L268">        data.putAll(m);</span>
<span class="nc" id="L269">    }</span>

    /**
     * Reduce the all local elements using the given operation.
     *
     * @param &lt;S&gt;  type of the result produced by the reduction operation
     * @param op   the operation used in the reduction
     * @param unit the neutral element of the reduction operation
     * @return the result of the reduction
     */
    public &lt;S&gt; S reduceLocal(BiFunction&lt;S, V, S&gt; op, S unit) {
<span class="fc" id="L280">        S accum = unit;</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        for (final Map.Entry&lt;K, V&gt; entry : data.entrySet()) {</span>
<span class="fc" id="L282">            accum = op.apply(accum, entry.getValue());</span>
<span class="fc" id="L283">        }</span>
<span class="fc" id="L284">        return accum;</span>
    }

    /**
     * Remove the entry corresponding to the specified key in the local map.
     *
     * @param key the key corresponding to the value.
     * @return the previous value associated with the key, or {@code null} if there
     *         was no existing mapping (or the key was mapped to {@code null})
     */
    @Override
    public V remove(Object key) {
<span class="fc" id="L296">        return data.remove(key);</span>
    }

    private List&lt;Collection&lt;V&gt;&gt; separateLocalValues(int n) {
<span class="fc" id="L300">        final List&lt;Collection&lt;V&gt;&gt; result = new ArrayList&lt;&gt;(n);</span>
<span class="fc" id="L301">        final long totalNum = size();</span>
<span class="fc" id="L302">        final long rem = totalNum % n;</span>
<span class="fc" id="L303">        final long quo = totalNum / n;</span>
<span class="pc bpc" id="L304" title="1 of 2 branches missed.">        if (data.isEmpty()) {</span>
<span class="nc" id="L305">            return result;</span>
        }
<span class="fc" id="L307">        final Iterator&lt;V&gt; it = data.values().iterator();</span>
<span class="fc" id="L308">        List&lt;V&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        for (long i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L310">            list = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">            final long count = quo + ((i &lt; rem) ? 1 : 0);</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">            for (long j = 0; j &lt; count; j++) {</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">                if (it.hasNext()) {</span>
<span class="fc" id="L314">                    list.add(it.next());</span>
                }
            }
<span class="fc" id="L317">            result.add(list);</span>
        }
<span class="fc" id="L319">        return result;</span>
    }

    /**
     * Sets the proxy generator for this instance.
     * &lt;p&gt;
     * The proxy will be used to generate values when accesses to a key not
     * contained in this instance is made. Instead of throwing an exception, the
     * proxy will be called with the attempted index and the program will continue
     * with the value returned by the proxy.
     * &lt;p&gt;
     * This feature is similar to {@link Map#getOrDefault(Object, Object)}
     * operation, the difference being that instead of returning a predetermined
     * default value, the provided function is called with the key.
     *
     * @param proxy function which takes a key &quot;K&quot; as parameter and returns a &quot;V&quot;,
     *              or {@code null} to remove any previously set proxy
     */
    public void setProxyGenerator(Function&lt;K, V&gt; proxy) {
<span class="fc" id="L338">        proxyGenerator = proxy;</span>
<span class="fc" id="L339">    }</span>

    /**
     * Return the number of local entries.
     *
     * @return the number of the local entries.
     */
    @Override
    public int size() {
<span class="fc" id="L348">        return data.size();</span>
    }

    /**
     * Returns all the values of this local map in a collection.
     */
    @Override
    public Collection&lt;V&gt; values() {
<span class="fc" id="L356">        return data.values();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>