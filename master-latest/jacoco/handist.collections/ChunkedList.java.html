<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChunkedList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">ChunkedList.java</span></div><h1>ChunkedList.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2020 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under 
 * the terms of the Eclipse Public License 1.0 which accompanies this 
 * distribution, and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 *******************************************************************************/
package handist.collections;

import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import handist.collections.function.LongTBiConsumer;

<span class="fc bfc" id="L29" title="All 2 branches covered.">public class ChunkedList&lt;T&gt; extends AbstractCollection&lt;T&gt; {</span>

	private static class It&lt;S&gt; implements Iterator&lt;S&gt; {
		public TreeMap&lt;LongRange, RangedList&lt;S&gt;&gt; chunks;
		private Iterator&lt;S&gt; cIter;
		private LongRange range;

<span class="fc" id="L36">		public It(TreeMap&lt;LongRange, RangedList&lt;S&gt;&gt; chunks) {</span>
<span class="fc" id="L37">			this.chunks = chunks;</span>
<span class="fc" id="L38">			Map.Entry&lt;LongRange, RangedList&lt;S&gt;&gt; firstEntry = chunks.firstEntry();</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">			if (firstEntry != null) {</span>
<span class="fc" id="L40">				RangedList&lt;S&gt; firstChunk = firstEntry.getValue();</span>
<span class="fc" id="L41">				range = firstChunk.getRange();</span>
<span class="fc" id="L42">				cIter = firstChunk.iterator();</span>
<span class="fc" id="L43">			} else {</span>
<span class="fc" id="L44">				range = null;</span>
<span class="fc" id="L45">				cIter = null;</span>
			}
<span class="fc" id="L47">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc bfc" id="L51" title="All 2 branches covered.">			if (range == null) {</span>
<span class="fc" id="L52">				return false;</span>
			}
<span class="fc bfc" id="L54" title="All 2 branches covered.">			if (cIter.hasNext()) {</span>
<span class="fc" id="L55">				return true;</span>
			}
<span class="fc" id="L57">			Map.Entry&lt;LongRange, RangedList&lt;S&gt;&gt; nextEntry = chunks.higherEntry(range);</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">			if (nextEntry == null) {</span>
<span class="fc" id="L59">				range = null;</span>
<span class="fc" id="L60">				cIter = null;</span>
<span class="fc" id="L61">				return false;</span>
			}
<span class="fc" id="L63">			range = nextEntry.getKey();</span>
<span class="fc" id="L64">			cIter = nextEntry.getValue().iterator();</span>
<span class="fc" id="L65">			return cIter.hasNext();</span>
		}

		@Override
		public S next() {
<span class="fc bfc" id="L70" title="All 2 branches covered.">			if (hasNext()) {</span>
<span class="fc" id="L71">				return cIter.next();</span>
			}
<span class="fc" id="L73">			throw new IndexOutOfBoundsException();</span>
		}

	}
	// private List&lt;RangedList&lt;T&gt;&gt; chunks;
	private TreeMap&lt;LongRange, RangedList&lt;T&gt;&gt; chunks;

<span class="pc" id="L80">	private long size = 0;</span>

<span class="fc" id="L82">	public ChunkedList() {</span>
		//chunks = new TreeMap&lt;&gt;(Comparator.comparingLong(r -&gt; r.from));
<span class="fc" id="L84">		chunks = new TreeMap&lt;LongRange, RangedList&lt;T&gt;&gt;();</span>
<span class="fc" id="L85">	}</span>

<span class="nc" id="L87">	public ChunkedList(TreeMap&lt;LongRange, RangedList&lt;T&gt;&gt; chunks) {</span>
<span class="nc" id="L88">		this.chunks = chunks;</span>
<span class="nc" id="L89">	}</span>

	@Override
	public boolean add(T element) {
<span class="fc" id="L93">		throw new UnsupportedOperationException();</span>
	}

	@Override
	public boolean addAll(Collection&lt;? extends T&gt; c) {
<span class="fc" id="L98">		throw new UnsupportedOperationException();</span>
	}

	public void addChunk(RangedList&lt;T&gt; c) {
<span class="fc" id="L102">		LongRange desired = c.getRange();</span>
<span class="fc" id="L103">		LongRange intersection = checkOverlap(desired);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">		if (intersection != null) {</span>
<span class="fc" id="L105">			throw new RuntimeException(&quot;LongRange &quot; + desired + &quot; &quot;</span>
					+ &quot;overlaps &quot; + intersection + &quot; which is already present in&quot;
					+ &quot; this ChunkedList&quot;);
		}
<span class="fc" id="L109">		chunks.put(desired, c);</span>
<span class="fc" id="L110">		size += c.longSize();</span>
<span class="fc" id="L111">	}</span>

	public Future&lt;ChunkedList&lt;T&gt;&gt; asyncForEach(ExecutorService pool, int nthreads, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L114">		List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L115">			sub.forEach(action);</span>
<span class="fc" id="L116">		});</span>
<span class="fc" id="L117">		return new FutureN.ReturnGivenResult&lt;ChunkedList&lt;T&gt;&gt;(futures,  this);</span>
	}

	public &lt;U&gt; Future&lt;ChunkedList&lt;T&gt;&gt; asyncForEach(ExecutorService pool, int nthreads, BiConsumer&lt;? super T, Consumer&lt;U&gt;&gt; action,
			final MultiReceiver&lt;U&gt; toStore) {
<span class="fc" id="L122">		List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L123">			sub.forEach(action,toStore.getReceiver());</span>
<span class="fc" id="L124">		});</span>
<span class="fc" id="L125">		return new FutureN.ReturnGivenResult&lt;ChunkedList&lt;T&gt;&gt;(futures, this);</span>
	}

	public Future&lt;ChunkedList&lt;T&gt;&gt; asyncForEach(ExecutorService pool, int nthreads, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L129">		List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L130">			sub.forEach(action);</span>
<span class="fc" id="L131">		});</span>
<span class="fc" id="L132">		return new FutureN.ReturnGivenResult&lt;ChunkedList&lt;T&gt;&gt;(futures, this);</span>
	}

	public &lt;S&gt; Future&lt;ChunkedList&lt;S&gt;&gt; asyncMap(ExecutorService pool, int nthreads,
			Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L137">		final ChunkedList&lt;S&gt; result = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L138">		final List&lt;Future&lt;?&gt;&gt; futures = mapParallelBody(pool, nthreads, func, result);</span>

<span class="fc bfc" id="L140" title="All 2 branches covered.">		for (Future&lt;?&gt; f : futures) {</span>
			try {
<span class="fc" id="L142">				f.get();</span>
<span class="nc" id="L143">			} catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L144">				e.printStackTrace();</span>
<span class="nc" id="L145">				throw new RuntimeException(&quot;[ChunkedList] exception raised by worker threads.&quot;);</span>
<span class="fc" id="L146">			}</span>
<span class="fc" id="L147">		}</span>
<span class="fc" id="L148">		return new FutureN.ReturnGivenResult&lt;ChunkedList&lt;S&gt;&gt;(futures, result);</span>
	}

	/**
	 * Checks if the provided {@link LongRange} intersects with one of the keys
	 * contained by this instance. Returns the intersecting key, or {@code null} 
	 * if there are no such  intersecting key. 
	 * 
	 * @param range the LongRange instance to check
	 * @return a LongRange key of this object that intersects the provided 
	 * 	{@link LongRange}, or {@code null} if there are so such key.
	 */
	private LongRange checkOverlap(LongRange range) {
<span class="fc" id="L161">		LongRange floorKey = chunks.floorKey(range);</span>
<span class="fc bfc" id="L162" title="All 4 branches covered.">		if (floorKey != null &amp;&amp; floorKey.isOverlapped(range)) {</span>
<span class="fc" id="L163">			return floorKey;</span>
		}
<span class="fc" id="L165">		LongRange nextKey = chunks.higherKey(range);</span>
<span class="fc bfc" id="L166" title="All 4 branches covered.">		if (nextKey != null &amp;&amp; nextKey.isOverlapped(range)) {</span>
<span class="fc" id="L167">			return nextKey;</span>
		}
<span class="fc" id="L169">		return null;</span>
	}

	/**
	 * Clear the local elements
	 */
	@Override
	public void clear() {
<span class="fc" id="L177">		throw new UnsupportedOperationException();</span>
	}

	/**
	 * Return a Container that has the same values in the DistCol.
	 *
	 * @return a Container that has the same values in the DistCol.
	 */
	@Override
	protected Object clone() {
<span class="nc" id="L187">		TreeMap&lt;LongRange, RangedList&lt;T&gt;&gt; newChunks = new TreeMap&lt;&gt;();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">		for (RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="nc" id="L189">			newChunks.put(c.getRange(), ((Chunk&lt;T&gt;) c).clone());</span>
<span class="nc" id="L190">		}</span>
<span class="nc" id="L191">		return new ChunkedList&lt;T&gt;(newChunks);</span>
	}

	@Override
	public boolean contains(Object o) {
<span class="fc bfc" id="L196" title="All 2 branches covered.">		for (RangedList&lt;T&gt; chunk : chunks.values()) {</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">			if (chunk.contains(o)) {</span>
<span class="fc" id="L198">				return true;</span>
			}
<span class="fc" id="L200">		}</span>
<span class="fc" id="L201">		return false;</span>
	}

	@Override
	public boolean containsAll(Collection&lt;?&gt; c) {
		// cf.
		// https://stackoverflow.com/questions/10199772/what-is-the-cost-of-containsall-in-java
<span class="fc" id="L208">		Iterator&lt;?&gt; e = c.iterator();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">		while (e.hasNext()) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">			if (!this.contains(e.next())) {</span>
<span class="fc" id="L211">				return false;</span>
			}
		}
<span class="fc" id="L214">		return true;</span>
	}

	/**
	 * Return whether this chunked list contains the given chunk.
	 * @param c the {@link RangedList} whose inclusion in this instance needs to
	 * 	be checked
	 * @return {@code true} if the provided {@link RangedList} is contained in 
	 * 	this instance, {@code false} otherwise
	 */
	public boolean containsChunk(RangedList&lt;T&gt; c) {
<span class="fc" id="L225">		return chunks.containsValue(c);</span>
	}

	public boolean containsIndex(long i) {
<span class="fc" id="L229">		LongRange r = new LongRange(i);</span>
<span class="fc" id="L230">		Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(r);</span>
<span class="pc bpc" id="L231" title="1 of 4 branches missed.">		if (entry == null || !entry.getKey().contains(i)) {</span>
<span class="fc" id="L232">			entry = chunks.ceilingEntry(r);</span>
<span class="fc bfc" id="L233" title="All 4 branches covered.">			if (entry == null || !entry.getKey().contains(i)) {</span>
<span class="fc" id="L234">				return false;</span>
			}
		}
<span class="fc" id="L237">		return true;</span>
	}

	/*
    public Map&lt;LongRange, RangedList&lt;T&gt;&gt; filterChunk0(Predicate&lt;RangedList&lt;? super T&gt;&gt; filter) {
        TreeMap&lt;LongRange, RangedList&lt;T&gt;&gt; map = new TreeMap&lt;&gt;();
        for (RangedList&lt;T&gt; c : chunks.values()) {
            if (filter.test(c)) {
                map.put(c.getRange(), c);
            }
        }
        return map;
    }*/
	public List&lt;RangedList&lt;T&gt;&gt; filterChunk(Predicate&lt;RangedList&lt;? super T&gt;&gt; filter) {
<span class="fc" id="L251">		List&lt;RangedList&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">		for (RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">			if (filter.test(c)) {</span>
<span class="fc" id="L254">				result.add(c);</span>
			}
<span class="fc" id="L256">		}</span>
<span class="fc" id="L257">		return result;</span>
	}

	public &lt;U&gt; void forEach(BiConsumer&lt;? super T, Consumer&lt;U&gt;&gt; action, final Collection&lt;? super U&gt; toStore) {
<span class="fc" id="L261">		forEach(action, new Consumer&lt;U&gt;() {</span>
			@Override
			public void accept(U u) {
<span class="fc" id="L264">				toStore.add(u);</span>
<span class="fc" id="L265">			}</span>
		});
<span class="fc" id="L267">	}</span>

	public &lt;U&gt; void forEach(BiConsumer&lt;? super T, Consumer&lt;U&gt;&gt; action, Consumer&lt;U&gt; receiver) {
<span class="fc bfc" id="L270" title="All 2 branches covered.">		for (RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L271">			c.forEach(t -&gt; action.accept((T) t, receiver));</span>
<span class="fc" id="L272">		}</span>
<span class="fc" id="L273">	}</span>

	public void forEach(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L276" title="All 2 branches covered.">		for (RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L277">			c.forEach(action);</span>
<span class="fc" id="L278">		}</span>
<span class="fc" id="L279">	}</span>

	public &lt;U&gt; void forEach(ExecutorService pool, int nthreads, BiConsumer&lt;? super T, Consumer&lt;U&gt;&gt; action,
			final MultiReceiver&lt;U&gt; toStore) {
<span class="fc" id="L283">		List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L284">			sub.forEach(action,toStore.getReceiver());</span>
<span class="fc" id="L285">		});</span>
<span class="fc" id="L286">		waitNfutures(futures);</span>
<span class="fc" id="L287">	}</span>

	public void forEach(ExecutorService pool, int nthreads, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L290">		List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L291">			sub.forEach(action);</span>
<span class="fc" id="L292">		});</span>
<span class="fc" id="L293">		waitNfutures(futures);</span>
<span class="fc" id="L294">	}</span>

	public void forEach(ExecutorService pool, int nthreads, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L297">		List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L298">			sub.forEach(action);</span>
<span class="fc" id="L299">		});</span>
<span class="fc" id="L300">		waitNfutures(futures);</span>
<span class="fc" id="L301">	}</span>


	public void forEach(LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">		for (RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L306">			c.forEach(c.getRange(), action);</span>
<span class="fc" id="L307">		}</span>
<span class="fc" id="L308">	}</span>

	public void forEachChunk(Consumer&lt;RangedList&lt;T&gt;&gt; op) {
<span class="fc bfc" id="L311" title="All 2 branches covered.">		for (RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L312">			op.accept(c);</span>
<span class="fc" id="L313">		}</span>
<span class="fc" id="L314">	}</span>

	private List&lt;Future&lt;?&gt;&gt; forEachParallelBody(ExecutorService pool, int nthreads, Consumer&lt;ChunkedList&lt;T&gt;&gt; run) {
<span class="fc" id="L317">		List&lt;ChunkedList&lt;T&gt;&gt; separated = this.separate(nthreads);</span>
<span class="fc" id="L318">		List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">		for (ChunkedList&lt;T&gt; sub: separated) {</span>
<span class="fc" id="L320">			futures.add(pool.submit(() -&gt; {</span>
<span class="fc" id="L321">				run.accept(sub);</span>
<span class="fc" id="L322">			}));</span>
<span class="fc" id="L323">		}</span>
<span class="fc" id="L324">		return futures;</span>
	}

	public T get(long i) {
<span class="fc" id="L328">		LongRange r = new LongRange(i);</span>
<span class="fc" id="L329">		Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(r);</span>
<span class="fc bfc" id="L330" title="All 4 branches covered.">		if (entry == null || !entry.getKey().contains(i)) {</span>
<span class="fc" id="L331">			entry = chunks.ceilingEntry(r);</span>
<span class="pc bpc" id="L332" title="1 of 4 branches missed.">			if (entry == null || !entry.getKey().contains(i)) {</span>
<span class="fc" id="L333">				throw new IndexOutOfBoundsException(&quot;ChunkedList: index &quot; + i + &quot; is out of range of &quot; + chunks);</span>
			}
		}
<span class="fc" id="L336">		RangedList&lt;T&gt; chunk = entry.getValue();</span>
<span class="fc" id="L337">		return chunk.get(i);</span>
	}

	@Override
	public boolean isEmpty() {
<span class="fc bfc" id="L342" title="All 2 branches covered.">		return size == 0;</span>
	}

	@Override
	public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L347">		return new It&lt;T&gt;(chunks);</span>
	}
	public long longSize() {
<span class="fc" id="L350">		return size;</span>
	}

	public &lt;S&gt; ChunkedList&lt;S&gt; map(ExecutorService pool, int nthreads, Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L354">		ChunkedList&lt;S&gt; result = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L355">		List&lt;Future&lt;?&gt;&gt; futures = mapParallelBody(pool, nthreads, func, result);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">		for (Future&lt;?&gt; f : futures) {</span>
			try {
<span class="fc" id="L358">				f.get();</span>
<span class="nc" id="L359">			} catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L360">				e.printStackTrace();</span>
<span class="nc" id="L361">				throw new RuntimeException(&quot;[ChunkedList] exception raised by worker threads.&quot;);</span>
<span class="fc" id="L362">			}</span>
<span class="fc" id="L363">		}</span>
<span class="fc" id="L364">		return result;</span>
	}

	public &lt;S&gt; ChunkedList&lt;S&gt; map(Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L368">		ChunkedList&lt;S&gt; result = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L369">		forEachChunk((RangedList&lt;T&gt; c) -&gt; {</span>
<span class="fc" id="L370">			RangedList&lt;S&gt; r = c.map(func);</span>
<span class="fc" id="L371">			result.addChunk(r);</span>
<span class="fc" id="L372">		});</span>
<span class="fc" id="L373">		return result;</span>
	}

	private &lt;S&gt; List&lt;Future&lt;?&gt;&gt; mapParallelBody(ExecutorService pool, int nthreads,
			Function&lt;? super T, ? extends S&gt; func, ChunkedList&lt;S&gt; result) {
<span class="fc" id="L378">		forEachChunk((RangedList&lt;T&gt; c) -&gt; {</span>
<span class="fc" id="L379">			result.addChunk(new Chunk&lt;S&gt;(c.getRange()));</span>
<span class="fc" id="L380">		});</span>
<span class="fc" id="L381">		List&lt;ChunkedList&lt;T&gt;&gt; separatedIn = this.separate(nthreads);</span>
<span class="fc" id="L382">		List&lt;ChunkedList&lt;S&gt;&gt; separatedOut = result.separate(nthreads);</span>
<span class="fc" id="L383">		List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">		for (int i = 0; i &lt; nthreads; i++) {</span>
<span class="fc" id="L385">			final int i0 = i;</span>
<span class="fc" id="L386">			futures.add(pool.submit(() -&gt; {</span>
<span class="fc" id="L387">				ChunkedList&lt;T&gt; from = separatedIn.get(i0);</span>
<span class="fc" id="L388">				ChunkedList&lt;S&gt; to = separatedOut.get(i0);</span>
<span class="fc" id="L389">				from.mapTo(to, func);</span>
<span class="fc" id="L390">				return null;</span>
			}));
		}
<span class="fc" id="L393">		return futures;</span>
	}

	private &lt;S&gt; void mapTo(ChunkedList&lt;S&gt; to, Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L397">		Iterator&lt;RangedList&lt;T&gt;&gt; fromIter = chunks.values().iterator();</span>
<span class="fc" id="L398">		Iterator&lt;RangedList&lt;S&gt;&gt; toIter = to.chunks.values().iterator();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">		while (fromIter.hasNext()) {</span>
<span class="pc bpc" id="L400" title="2 of 4 branches missed.">			assert (toIter.hasNext());</span>
<span class="fc" id="L401">			RangedList&lt;T&gt; fromChunk = fromIter.next();</span>
<span class="fc" id="L402">			RangedList&lt;S&gt; toChunk = toIter.next();</span>
<span class="fc" id="L403">			toChunk.setupFrom(fromChunk, func);</span>
<span class="fc" id="L404">		}</span>
<span class="fc" id="L405">	}</span>

	public int numChunks() {
<span class="fc" id="L408">		return chunks.size();</span>
	}

	/**
	 * Return the logical range assined end local.
	 *
	 * @return an instance of LongRange.
	 */
	public Collection&lt;LongRange&gt; ranges() {
<span class="fc" id="L417">		return chunks.keySet();</span>
	}

	@Override
	public boolean remove(Object o) {
<span class="fc" id="L422">		throw new UnsupportedOperationException();</span>
	}

	@Override
	public boolean removeAll(Collection&lt;?&gt; c) {
<span class="fc" id="L427">		throw new UnsupportedOperationException();</span>
	}

	public RangedList&lt;T&gt; removeChunk(RangedList&lt;T&gt; c) {
<span class="fc" id="L431">		RangedList&lt;T&gt; removed = chunks.remove(c.getRange());</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">		if (removed != null) {</span>
<span class="fc" id="L433">			size -=removed.longSize();</span>
		}
<span class="fc" id="L435">		return removed;</span>
	}

	@Override
	public boolean retainAll(Collection&lt;?&gt; c) {
<span class="fc" id="L440">		throw new UnsupportedOperationException();</span>
	}

	/**
	 * Seperates the contents of the ChunkedList in &lt;em&gt;n&lt;/em&gt; parts.
	 * This can be used to apply a forEach method in parallel using 'n' threads
	 * for instance. The method returns &lt;em&gt;n&lt;/em&gt; lists, each containing a
	 * {@link ChunkedList} of &lt;em&gt;T&lt;/em&gt;s.
	 *
	 * @param n the number of parts in which to split the ChunkedList
	 * @return &lt;em&gt;n&lt;/em&gt; {@link ChunkedList}s containing the same number of
	 * 	elements
	 */
	public List&lt;ChunkedList&lt;T&gt;&gt; separate(int n) {
<span class="fc" id="L454">		long totalNum = size();</span>
<span class="fc" id="L455">		long rem = totalNum % n;</span>
<span class="fc" id="L456">		long quo = totalNum / n;</span>
<span class="fc" id="L457">		List&lt;ChunkedList&lt;T&gt;&gt; result = new ArrayList&lt;ChunkedList&lt;T&gt;&gt;(n);</span>
<span class="fc" id="L458">		RangedList&lt;T&gt; c = chunks.firstEntry().getValue();</span>
<span class="fc" id="L459">		long used = 0;</span>

<span class="fc bfc" id="L461" title="All 2 branches covered.">		for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L462">			ChunkedList&lt;T&gt; r = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L463">			result.add(r);</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">			long rest = quo + ((i &lt; rem) ? 1 : 0);</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">			while (rest &gt; 0) {</span>
<span class="fc" id="L466">				LongRange range = c.getRange();</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">				if (c.longSize() - used &lt; rest) { // not enough</span>
<span class="fc" id="L468">					long from = range.from + used;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">					if (from != range.to) {</span>
<span class="fc" id="L470">						r.addChunk(c.subList(from, range.to));	</span>
					}
<span class="fc" id="L472">					rest -= c.longSize() - used;</span>
<span class="fc" id="L473">					used = 0;</span>
					// TODO should use iterator??
<span class="fc" id="L475">					c = chunks.higherEntry(range).getValue();</span>
<span class="fc" id="L476">				} else {</span>
<span class="fc" id="L477">					long from = range.from + used;</span>
<span class="fc" id="L478">					long to = from + rest;</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">					if (from != to) {</span>
<span class="fc" id="L480">						r.addChunk(c.subList(from, to));	</span>
					}
<span class="fc" id="L482">					used += rest;</span>
<span class="fc" id="L483">					rest = 0;</span>
				}

<span class="fc" id="L486">			}</span>
		}
<span class="fc" id="L488">		return result;</span>
	}

	public T set(long i, T value) {
<span class="fc" id="L492">		LongRange r = new LongRange(i);</span>
<span class="fc" id="L493">		Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(r);</span>
<span class="fc bfc" id="L494" title="All 4 branches covered.">		if (entry == null || !entry.getKey().contains(i)) {</span>
<span class="fc" id="L495">			entry = chunks.ceilingEntry(r);</span>
<span class="pc bpc" id="L496" title="1 of 4 branches missed.">			if (entry == null || !entry.getKey().contains(i)) {</span>
<span class="fc" id="L497">				throw new IndexOutOfBoundsException(&quot;ChunkedList: index &quot; + i + &quot; is out of range of &quot; + chunks);</span>
			}
		}
<span class="fc" id="L500">		RangedList&lt;T&gt; chunk = entry.getValue();</span>
<span class="fc" id="L501">		return chunk.set(i, value);</span>
	}

	/**
	 * Return the number of local elements.
	 *
	 * @return the number of local elements.
	 */
	@Override
	public int size() {
<span class="fc" id="L511">		return (int) longSize();</span>
	}

	@Override
	public Object[] toArray() {
		//        return new Object[0];
<span class="fc" id="L517">		throw new UnsupportedOperationException();</span>
	}

	@Override
	public &lt;T1&gt; T1[] toArray(T1[] a) {
		//        return null;
<span class="fc" id="L523">		throw new UnsupportedOperationException();</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L528">		StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L529">		sb.append(&quot;[ChunkedList(&quot; + chunks.size() + &quot;)&quot;);</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">		for (RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L531">			sb.append(&quot;,&quot; + c);</span>
<span class="fc" id="L532">		}</span>
<span class="fc" id="L533">		sb.append(&quot;]&quot;);</span>
<span class="fc" id="L534">		return sb.toString();</span>
	}
	
	private void waitNfutures(List&lt;Future&lt;?&gt;&gt; futures) {
<span class="fc bfc" id="L538" title="All 2 branches covered.">		for (Future&lt;?&gt; f : futures) {</span>
			try {
<span class="fc" id="L540">				f.get();</span>
<span class="nc" id="L541">			} catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L542">				e.printStackTrace();</span>
<span class="nc" id="L543">				throw new RuntimeException(&quot;[ChunkedList] exception raised by worker threads.&quot;);</span>
<span class="fc" id="L544">			}</span>
<span class="fc" id="L545">		}</span>
<span class="fc" id="L546">	}</span>
/*
	public static void main(String[] args) {

		ChunkedList&lt;String&gt; cl5 = new ChunkedList&lt;&gt;();

		// Test1: Add Chunks

		System.out.println(&quot;Test1&quot;);
		for (int i = 0; i &lt; 10; i++) {
			if (i % 2 == 1) {
				continue;
			}
			long begin = i * 5;
			long end = (i + 1) * 5;
			Chunk&lt;String&gt; c = new Chunk&lt;&gt;(new LongRange(begin, end));
			for (long index = begin; index &lt; end; index++) {
				c.set(index, String.valueOf(index));
			}
			cl5.addChunk(c);
		}
		System.out.println(cl5.toString());

		// Test2: Iterate using each()

		System.out.println(&quot;Test2&quot;);
		StringBuilder sb2 = new StringBuilder();
		cl5.forEach(value -&gt; sb2.append(value + &quot;,&quot;));
		System.out.println(sb2.toString());

		// Test3: Iterate using iterator()

		System.out.println(&quot;Test3&quot;);
		StringBuilder sb3 = new StringBuilder();
		Iterator&lt;String&gt; it = cl5.iterator();
		while (it.hasNext()) {
			sb3.append(it.next() + &quot;,&quot;);
		}
		System.out.println(sb3.toString());

		// Test4: Raise exception

		System.out.println(&quot;Test4&quot;);
		for (int i = 0; i &lt; 10; i++) {

			long begin = i * 5 - 1;
			long end = i * 5 + 1;
			Chunk&lt;String&gt; c = new Chunk&lt;&gt;(new LongRange(begin, end));
			try {
				cl5.addChunk(c);
				System.out.println(&quot;--- FAIL ---&quot;);
			} catch (IllegalArgumentException e) {
				// do nothing
			}
		}
		for (int i = 0; i &lt; 10; i++) {

			long begin = i * 5 - 1;
			long end = i * 5 + 5;
			Chunk&lt;String&gt; c = new Chunk&lt;&gt;(new LongRange(begin, end));
			try {
				cl5.addChunk(c);
				System.out.println(&quot;--- FAIL ---&quot;);
			} catch (IllegalArgumentException e) {
				// do nothing
			}
		}
		for (int i = 0; i &lt; 10; i++) {

			long begin = i * 5 - 1;
			long end = i * 5 + 10;
			Chunk&lt;String&gt; c = new Chunk&lt;&gt;(new LongRange(begin, end));
			try {
				cl5.addChunk(c);
				System.out.println(&quot;--- FAIL ---&quot;);
			} catch (IllegalArgumentException e) {
				// do nothing
			}
		}
		System.out.println(&quot;--- OK ---&quot;);
		// Test5: Add RangedListView

		System.out.println(&quot;Test5&quot;);
		Chunk&lt;String&gt; c0 = new Chunk&lt;&gt;(new LongRange(0, 10 * 5));
		for (long i = 0; i &lt; 10 * 5; i++) {
			c0.set(i, String.valueOf(i));
		}
		for (int i = 0; i &lt; 10; i++) {
			if (i % 2 == 0) {
				continue;
			}
			long begin = i * 5;
			long end = (i + 1) * 5;
			RangedList&lt;String&gt; rl = c0.subList(begin, end);
			cl5.addChunk(rl);
		}
		System.out.println(cl5.toString());

		// Test6: Iterate combination of Chunk and RangedListView
		System.out.println(&quot;Test6&quot;);
		StringBuilder sb6 = new StringBuilder();
		Iterator&lt;String&gt; it6 = cl5.iterator();
		while (it6.hasNext()) {
			sb6.append(it6.next() + &quot;,&quot;);
		}
		System.out.println(sb6.toString());

		// Test7: Raise exception on ChunkedList with continuous range

		System.out.println(&quot;Test7&quot;);
		for (int i = 0; i &lt; 10 * 5; i++) {
			long begin = i - 1;
			long end = i + 1;
			Chunk&lt;String&gt; c = new Chunk&lt;&gt;(new LongRange(begin, end));
			try {
				cl5.addChunk(c);
				System.out.println(&quot;--- FAIL --- &quot; + begin + &quot;,&quot; + end);
			} catch (IllegalArgumentException e) {
				// do nothing
			}
		}
		for (int i = 0; i &lt; 10 * 5; i++) {
			long begin = i - 1;
			long end = i + 6;
			Chunk&lt;String&gt; c = new Chunk&lt;&gt;(new LongRange(begin, end));
			try {
				cl5.addChunk(c);
				System.out.println(&quot;--- FAIL --- &quot; + begin + &quot;,&quot; + end);
			} catch (IllegalArgumentException e) {
				// do nothing
			}
		}
		System.out.println(&quot;--- OK ---&quot;);

	}
*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>