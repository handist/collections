<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MapEntryDispatcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">MapEntryDispatcher.java</span></div><h1>MapEntryDispatcher.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.dist;

import static apgas.Constructs.*;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.KryoSerializable;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import apgas.Place;
import handist.collections.dist.util.ObjectInput;
import handist.collections.dist.util.ObjectOutput;

/**
 * {@link DistMap} has this class in order to dispatch entris to places defined
 * by {@link Distribution}. Relocate entries between places by calling
 * {@link MapEntryDispatcher.TeamOperations#dispatch}. Dhe dispatched entries
 * are added to original {@link DistMap}.
 *
 * Please be careful that reference relationships like multiple references to
 * one object are not maintained.
 *
 * @author yoshikikawanishi
 *
 * @param &lt;K&gt; : The key type of map entry
 * @param &lt;V&gt; : The value type of map entry
 */
public class MapEntryDispatcher&lt;K, V&gt; implements KryoSerializable, Serializable {

    public class TeamOperations {
        private final MapEntryDispatcher&lt;K, V&gt; handle;

<span class="fc" id="L52">        public TeamOperations(MapEntryDispatcher&lt;K, V&gt; localObject) {</span>
<span class="fc" id="L53">            handle = localObject;</span>
<span class="fc" id="L54">        }</span>

        /**
         * Relocate the entries that was put. Destination is defined by
         * {@link Distribution}.
         */
        public void dispatch() throws Exception {
<span class="fc" id="L61">            final int[] sendOffset = new int[placeGroup.size()];</span>
<span class="fc" id="L62">            final int[] sendSize = new int[placeGroup.size()];</span>
<span class="fc" id="L63">            final int[] rcvOffset = new int[placeGroup.size()];</span>
<span class="fc" id="L64">            final int[] rcvSize = new int[placeGroup.size()];</span>
<span class="fc" id="L65">            final ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L66">            handle.executeSummerizeOutput(out, sendOffset, sendSize);</span>
<span class="fc" id="L67">            final byte[] buf = CollectiveRelocator.exchangeBytesWithinGroup(placeGroup, out.toByteArray(), sendOffset,</span>
                    sendSize, rcvOffset, rcvSize);
<span class="fc" id="L69">            handle.executeDeserialize(buf, rcvOffset, rcvSize);</span>
<span class="fc" id="L70">            clear();</span>
<span class="fc" id="L71">        }</span>
    }

    private static final long serialVersionUID = -8298092935400058332L;

    protected TeamedPlaceGroup placeGroup;
    protected Map&lt;K, V&gt; base;
    public TeamOperations TEAM;

    protected Map&lt;Place, Map&lt;Thread, ObjectOutput&gt;&gt; outputMap;
    /** The entries are relocated following the rules defined by this. */
    protected Distribution&lt;K&gt; distribution;

    /**
     * @param distMap
     * @param pg
     * @param dist
     */
<span class="fc" id="L89">    MapEntryDispatcher(Map&lt;K, V&gt; distMap, TeamedPlaceGroup pg, Distribution&lt;K&gt; dist) {</span>
<span class="fc" id="L90">        base = distMap;</span>
<span class="fc" id="L91">        placeGroup = pg;</span>
<span class="fc" id="L92">        TEAM = new TeamOperations(this);</span>
<span class="fc" id="L93">        outputMap = new HashMap&lt;&gt;(placeGroup.size());</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        for (final Place pl : placeGroup.places()) {</span>
<span class="fc" id="L95">            final int nThreads = Runtime.getRuntime().availableProcessors();</span>
<span class="fc" id="L96">            outputMap.put(pl, new ConcurrentHashMap&lt;&gt;(nThreads));</span>
<span class="fc" id="L97">        }</span>
<span class="fc" id="L98">        distribution = dist;</span>
<span class="fc" id="L99">    }</span>

    /**
     * Remove the all local entries that was put dispatcher.
     */
    public void clear() {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (final Place place : outputMap.keySet()) {</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            for (final ObjectOutput output : outputMap.get(place).values()) {</span>
<span class="fc" id="L107">                output.clear();</span>
<span class="fc" id="L108">            }</span>
<span class="fc" id="L109">        }</span>
<span class="fc" id="L110">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    protected void executeDeserialize(byte[] buf, int[] offsets, int[] sizes) throws Exception {
<span class="fc" id="L114">        int current = 0;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (final Place p : placeGroup.places()) {</span>
<span class="fc" id="L116">            final int size = sizes[current];</span>
<span class="fc" id="L117">            final int offset = offsets[current];</span>
<span class="fc" id="L118">            current++;</span>
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">            if (p.equals(here()) || size == 0) {</span>
<span class="nc" id="L120">                continue;</span>
            }
<span class="fc" id="L122">            final ObjectInput ds = new ObjectInput(new ByteArrayInputStream(buf, offset, size), false);</span>
<span class="fc" id="L123">            final int nThreads = ds.readInt();</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (int i = 0; i &lt; nThreads; i++) {</span>
<span class="fc" id="L125">                final int count = ds.readInt();</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">                for (int j = 0; j &lt; count; j += 2) { // NOTE: convert key and value(two object), so &quot;J+=2&quot;.</span>
<span class="fc" id="L127">                    final K key = (K) ds.readObject();</span>
<span class="fc" id="L128">                    final V value = (V) ds.readObject();</span>
<span class="fc" id="L129">                    putLocal(key, value);</span>
                }
<span class="fc" id="L131">                ds.reset();</span>
            }
<span class="fc" id="L133">            ds.close();</span>
<span class="fc" id="L134">        }</span>
<span class="fc" id="L135">    }</span>

    private void executeSummerizeOutput(ByteArrayOutputStream out, int[] offsets, int[] sizes) throws IOException {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (int i = 0; i &lt; placeGroup.size(); i++) {</span>
<span class="fc" id="L139">            final Place place = placeGroup.get(i);</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            if (place.equals(here())) {</span>
<span class="fc" id="L141">                continue;</span>
            }
<span class="fc" id="L143">            offsets[i] = out.size();</span>
<span class="fc" id="L144">            Output output = new Output(out);</span>
<span class="fc" id="L145">            output.writeInt(outputMap.get(place).size());</span>
<span class="fc" id="L146">            output.close();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">            for (final ObjectOutput o : outputMap.get(place).values()) {</span>
<span class="fc" id="L148">                output = new Output(out);</span>
<span class="fc" id="L149">                output.writeInt(o.getCount());</span>
<span class="fc" id="L150">                output.close();</span>
<span class="fc" id="L151">                out.write(o.toByteArray());</span>
<span class="fc" id="L152">            }</span>
<span class="fc" id="L153">            out.flush();</span>
<span class="fc" id="L154">            sizes[i] = out.size() - offsets[i];</span>
        }
<span class="fc" id="L156">    }</span>

    protected ObjectOutput getOutput(Place place) {
<span class="fc" id="L159">        final Thread thread = Thread.currentThread();</span>
<span class="fc" id="L160">        ObjectOutput out = outputMap.get(place).get(thread);</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (out == null) {</span>
<span class="fc" id="L162">            out = new ObjectOutput(new ByteArrayOutputStream(), false);</span>
<span class="fc" id="L163">            outputMap.get(place).put(thread, out);</span>
        }
<span class="fc" id="L165">        return out;</span>
    }

    /**
     * Put a new entry. The entries are relocated when #relocate is called.
     *
     * @param key   the key of the new entry.
     * @param value the value of the new entry.
     * @return If the destination associated with the key is here, return the value.
     *         If not, return null.
     */
    public V put(K key, V value) {
<span class="fc" id="L177">        final Place next = distribution.location(key);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        if (next.equals(here())) {</span>
<span class="fc" id="L179">            return putLocal(key, value);</span>
        }
<span class="fc" id="L181">        final ObjectOutput out = getOutput(next);</span>
<span class="fc" id="L182">        out.writeObject(key);</span>
<span class="fc" id="L183">        out.writeObject(value);</span>
<span class="fc" id="L184">        out.flush();</span>
<span class="fc" id="L185">        return null;</span>
    }

    /**
     * Adds all the mappings contained in the specified map.
     */
    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
<span class="nc bnc" id="L192" title="All 2 branches missed.">        for (final Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {</span>
<span class="nc" id="L193">            put(e.getKey(), e.getValue());</span>
<span class="nc" id="L194">        }</span>
<span class="nc" id="L195">    }</span>

    private V putLocal(K key, V value) {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (base.containsKey(key)) {</span>
<span class="nc" id="L199">            throw new IllegalStateException(&quot;RelocationMap cannot override existing entry: &quot; + key);</span>
        }
<span class="fc" id="L201">        return base.put(key, value);</span>
    }

    @Deprecated
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void read(Kryo kryo, Input input) {
<span class="fc" id="L208">        this.base = (DistMap&lt;K, V&gt;) kryo.readClassAndObject(input);</span>
<span class="fc" id="L209">        this.placeGroup = (TeamedPlaceGroup) kryo.readClassAndObject(input);</span>
<span class="fc" id="L210">        this.distribution = (Distribution&lt;K&gt;) kryo.readClassAndObject(input);</span>
<span class="fc" id="L211">        this.TEAM = new TeamOperations(this);</span>
<span class="fc" id="L212">        this.outputMap = new HashMap&lt;&gt;(placeGroup.size());</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (final Place pl : placeGroup.places()) {</span>
<span class="fc" id="L214">            final int nThreads = Runtime.getRuntime().availableProcessors();</span>
<span class="fc" id="L215">            outputMap.put(pl, new ConcurrentHashMap&lt;&gt;(nThreads));</span>
<span class="fc" id="L216">        }</span>
<span class="fc" id="L217">    }</span>

    /**
     * Set the rule that defines destination in relocation for entries. The
     * destination of entries that have already been added is not changed.
     */
    public void setDistribution(Distribution&lt;K&gt; dist) {
<span class="nc" id="L224">        distribution = dist;</span>
<span class="nc" id="L225">    }</span>

    @Deprecated
    @Override
    public void write(Kryo kryo, Output output) {
<span class="fc" id="L230">        kryo.writeClassAndObject(output, base);</span>
<span class="fc" id="L231">        kryo.writeClassAndObject(output, placeGroup);</span>
<span class="fc" id="L232">        kryo.writeClassAndObject(output, distribution);</span>
<span class="fc" id="L233">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>