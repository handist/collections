<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CollectiveMoveManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">CollectiveMoveManager.java</span></div><h1>CollectiveMoveManager.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.dist;

import static apgas.Constructs.*;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import apgas.Place;
import handist.collections.dist.util.ObjectInput;
import handist.collections.dist.util.ObjectOutput;
import handist.collections.function.DeSerializer;
import handist.collections.function.Serializer;

/**
 * This class is used for relocating elements of distributed collections in a
 * collective manner. I.e. the transfer of instances between places occurs when
 * an instance of this relocator's {@link #sync()} method is called on every
 * host involved in the transfer.
 */
public final class CollectiveMoveManager implements MoveManager {
    private static final boolean DEBUG = false;

    /**
     * Collection of the deserializers, gathered by destination place.
     */
    private final Map&lt;Place, List&lt;DeSerializer&gt;&gt; builders;

    /**
     * The group of places which are involved in the collective relocation
     * operation.
     */
    private final TeamedPlaceGroup placeGroup;

    /**
     * The collection of serializers, gathered by destination places
     */
    private final Map&lt;Place, List&lt;Serializer&gt;&gt; serializeListMap;

    /**
     * Construct a MoveManagerLocal with the given arguments.
     *
     * @param placeGroup the group hosts that will transfer objects between
     *                   themselves using this instance.
     */
<span class="fc" id="L60">    public CollectiveMoveManager(TeamedPlaceGroup placeGroup) {</span>
<span class="fc" id="L61">        this.placeGroup = placeGroup;</span>
<span class="fc" id="L62">        serializeListMap = new HashMap&lt;&gt;(placeGroup.size());</span>
<span class="fc" id="L63">        builders = new HashMap&lt;&gt;(placeGroup.size());</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (final Place place : placeGroup.places()) {</span>
<span class="fc" id="L65">            serializeListMap.put(place, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L66">            builders.put(place, new ArrayList&lt;&gt;());</span>
<span class="fc" id="L67">        }</span>
<span class="fc" id="L68">    }</span>

    private void all2allser() throws Exception {
        // Prepare to send the data
<span class="fc" id="L72">        final int[] sendOffset = new int[placeGroup.size()];</span>
<span class="fc" id="L73">        final int[] sendSize = new int[placeGroup.size()];</span>
        // Rather than initializing an array, use an output stream as we do not know how
        // long the array needs to be an advance.
<span class="fc" id="L76">        final ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
<span class="fc" id="L77">        executeSerialization(out, sendOffset, sendSize);</span>

        // Prepare the arrays for receiving the information
<span class="fc" id="L80">        final int[] rcvOffset = new int[placeGroup.size()];</span>
<span class="fc" id="L81">        final int[] rcvSize = new int[placeGroup.size()];</span>

        // Make the MPI calls
<span class="fc" id="L84">        final byte[] buf = CollectiveRelocator.exchangeBytesWithinGroup(placeGroup, out.toByteArray(), sendOffset,</span>
                sendSize, rcvOffset, rcvSize);

        // Deserialize the objects received from the various hosts
<span class="fc" id="L88">        executeDeserialization(buf, rcvOffset, rcvSize);</span>
<span class="fc" id="L89">    }</span>

    /**
     * Removes all the serializers and deserializers contained in this instance
     */
    public void clear() {
<span class="fc bfc" id="L95" title="All 2 branches covered.">        for (final List&lt;Serializer&gt; list : serializeListMap.values()) {</span>
<span class="fc" id="L96">            list.clear();</span>
<span class="fc" id="L97">        }</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        for (final List&lt;DeSerializer&gt; list : builders.values()) {</span>
<span class="fc" id="L99">            list.clear();</span>
<span class="fc" id="L100">        }</span>
<span class="fc" id="L101">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void executeDeserialization(byte[] buf, int[] rcvOffset, int[] rcvSize) throws Exception {
<span class="fc" id="L105">        int current = 0;</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (final Place p : placeGroup.places()) {</span>
<span class="fc" id="L107">            final int size = rcvSize[current];</span>
<span class="fc" id="L108">            final int offset = rcvOffset[current];</span>
<span class="fc" id="L109">            current++;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">            if (p.equals(here())) {</span>
<span class="fc" id="L111">                continue;</span>
            }

<span class="fc" id="L114">            final ByteArrayInputStream in = new ByteArrayInputStream(buf, offset, size);</span>
<span class="fc" id="L115">            final ObjectInput ds = new ObjectInput(in);</span>
<span class="fc" id="L116">            final List&lt;DeSerializer&gt; deserializerList = (List&lt;DeSerializer&gt;) ds.readObject();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">            for (final DeSerializer deserialize : deserializerList) {</span>
<span class="fc" id="L118">                deserialize.accept(ds);</span>
<span class="fc" id="L119">            }</span>
<span class="fc" id="L120">            ds.close();</span>
<span class="fc" id="L121">        }</span>
<span class="fc" id="L122">    }</span>

    /*
     * 将来的に moveAtSync(dist:RangedDistribution, mm) を 持つものを interface 宣言するのかな？
     * public def moveAssociativeCollectionsAtSync(dist: RangedDistribution, dists:
     * List[RangedMoballe]) {
     *
     * } public def moveAssosicativeCollectionsAtSync(dist: Distribution[K]) { //
     * add dist to the list to schedule }
     */
    /**
     * Proceed to call all the serializers held by this instance and prepare an
     * array for an incoming MPI call.
     *
     * @param out     output stream into which the serialized objects need to be
     *                placed
     * @param offsets array describing the index in the byte array which is destined
     *                for every destination
     * @param sizes   length in the array which is destined to every host
     * @throws IOException if thrown while serializing the objects
     */
    private void executeSerialization(ByteArrayOutputStream out, int[] offsets, int[] sizes) throws IOException {
<span class="fc bfc" id="L144" title="All 2 branches covered.">        for (int i = 0; i &lt; placeGroup.size(); i++) {</span>
<span class="fc" id="L145">            final Place place = placeGroup.get(i);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (place.equals(here())) {</span>
<span class="fc" id="L147">                continue;</span>
            }
<span class="fc" id="L149">            offsets[i] = out.size();</span>
            // TODO should reopen ByteArray...
            if (DEBUG) {
                System.err.println(&quot;execSeri: &quot; + here() + &quot;-&gt;&quot; + place + &quot;:start:&quot; + out.size());
            }
<span class="fc" id="L154">            final ObjectOutput s = new ObjectOutput(out);</span>

            // First, write all the deserializers which will have to operate on the other
            // end
<span class="fc" id="L158">            s.writeObject(builders.get(place));</span>
            // Then call all the serializers
<span class="fc bfc" id="L160" title="All 2 branches covered.">            for (final Serializer serializer : serializeListMap.get(place)) {</span>
<span class="fc" id="L161">                serializer.accept(s);</span>
<span class="fc" id="L162">            }</span>
<span class="fc" id="L163">            s.close();</span>
            if (DEBUG) {
                System.err.println(&quot;execSeri: &quot; + here() + &quot;-&gt;&quot; + place + &quot;:finish:&quot; + out.size());
            }
<span class="fc" id="L167">            sizes[i] = out.size() - offsets[i];</span>
        }
<span class="fc" id="L169">    }</span>

    @Override
    public void request(Place pl, Serializer serializer, DeSerializer deserializer) {
<span class="fc" id="L173">        serializeListMap.get(pl).add(serializer);</span>
<span class="fc" id="L174">        builders.get(pl).add(deserializer);</span>
<span class="fc" id="L175">    }</span>

    /**
     * Execute the all requests synchronously. When the transfer of objects
     * completes, clears this object so that it can be safely re-used for another
     * transfer.
     *
     * @throws Exception if a runtime exception is thrown at any stage during the
     *                   relocation
     */
    public void sync() throws Exception {
<span class="fc" id="L186">        all2allser();</span>
        // Clear the MoveManager to make it safe to reuse
<span class="fc" id="L188">        clear();</span>
<span class="fc" id="L189">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>