<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DistIdMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">DistIdMap.java</span></div><h1>DistIdMap.java</h1><pre class="source lang-java linenums">package handist.collections.dist;

import static apgas.Constructs.*;

import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import apgas.Place;
import apgas.util.GlobalID;

/**
 * Distributed Map using {@link Long} as key and type &lt;code&gt;V&lt;/code&gt; as value. 
 * 
 *  @param &lt;V&gt; the type of the value mappings of this instance 
 */
public class DistIdMap&lt;V&gt; extends DistMap&lt;Long, V&gt;
//TODO
/* implements ManagedDistribution[Long] */
{

<span class="fc" id="L29">    private static int _debug_level = 0;</span>
    transient DistManager.Index ldist;
    transient float[] locality;

<span class="nc" id="L33">    public Map&lt;Long, Place&gt; getDist() { return ldist.dist; }</span>
<span class="nc" id="L34">    Map&lt;Long, Integer&gt; getDiff() { return ldist.diff; }</span>
<span class="nc" id="L35">    public DistributionLong getDistributionLong() { return new DistributionLong(getDist()); }</span>

    public Object writeReplace() throws ObjectStreamException {
<span class="fc" id="L38">        final TeamedPlaceGroup pg1 = placeGroup;</span>
<span class="fc" id="L39">        final GlobalID id1 = id;</span>
<span class="fc" id="L40">            return new AbstractDistCollection.LazyObjectReference&lt;DistIdMap&lt;V&gt;&gt;(pg1, id1, ()-&gt; {</span>
<span class="fc" id="L41">                return new DistIdMap&lt;V&gt;(pg1, id1);</span>
        });
    }

    /**
     * Construct a DistIdMap.
     * Place.places() is used as the PlaceGroup of the new instance.
     */
    public DistIdMap() {
<span class="nc" id="L50">        this(TeamedPlaceGroup.getWorld());</span>
<span class="nc" id="L51">    }</span>

    /**
     * Construct a DistIdMap with the given argument.
     * Team(placeGroup) is used as the PlaceGroup of the new instance.
     *
     * @param placeGroup the PlaceGroup.
     */
    public DistIdMap(TeamedPlaceGroup placeGroup) {
<span class="fc" id="L60">        super(placeGroup);</span>
        //TODO
<span class="fc" id="L62">        this.ldist = new DistManager.Index();</span>
<span class="fc" id="L63">        ldist.setup(data.keySet());</span>
<span class="fc" id="L64">        locality = new float[placeGroup.size()];</span>
<span class="fc" id="L65">        Arrays.fill(locality, 1.0f);</span>
<span class="fc" id="L66">    }</span>

    protected DistIdMap(TeamedPlaceGroup placeGroup, GlobalID id) {
<span class="fc" id="L69">        super(placeGroup, id);</span>
        //TODO
<span class="fc" id="L71">        this.ldist = new DistManager.Index();</span>
<span class="fc" id="L72">        ldist.setup(data.keySet());</span>
<span class="fc" id="L73">        locality = new float[placeGroup.size()];</span>
<span class="fc" id="L74">        Arrays.fill(locality, 1.0f);</span>
<span class="fc" id="L75">    }</span>


    /**
     * Remove the all local entries.
     */
    public void clear() {
<span class="nc" id="L82">        super.clear();</span>
<span class="nc" id="L83">        this.ldist.clear();</span>
<span class="nc" id="L84">        Arrays.fill(locality, 1.0f);</span>
<span class="nc" id="L85">    }</span>

    /*
     * Get the corresponding value of the specified id.
     *
     * @param id a Long type value.
     * @return the corresponding value of the specified id.
     */
    public V get(long id) {
<span class="nc" id="L94">        return data.get(id);</span>
    }

    /*
     * Put a new entry.
     *
     * @param id a Long type value.
     * @param value a value.
     */
    public V put(long id, V value) throws Exception {
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        if (data.containsKey(id)) {</span>
<span class="nc" id="L105">            return data.put(id, value);</span>
        }
<span class="fc" id="L107">        ldist.add(id);</span>
<span class="fc" id="L108">        return data.put(id, value);</span>
    }

    private V putForMove(long key, byte mType, V value) throws Exception {
<span class="pc bpc" id="L112" title="2 of 3 branches missed.">        switch (mType) {</span>
        case DistManager.MOVE_NEW:
<span class="fc" id="L114">            ldist.moveInNew(key);</span>
<span class="fc" id="L115">            break;</span>
        case DistManager.MOVE_OLD:
<span class="nc" id="L117">            ldist.moveInOld(key);</span>
<span class="nc" id="L118">            break;</span>
        default:
<span class="nc" id="L120">            throw new Exception(&quot;SystemError when calling putForMove &quot; + key);</span>
        }
<span class="fc" id="L122">        return data.put(key, value);</span>
    }

    public boolean delete(long id) {
<span class="nc" id="L126">        ldist.remove(id);</span>
<span class="nc" id="L127">        return super.delete(id);</span>
    }

    /*
     * Remove the corresponding value of the specified id.
     *
     * @param id a Long type value.
     */
    public V remove(long id) {
<span class="fc" id="L136">        ldist.remove(id);</span>
<span class="fc" id="L137">        return super.remove(id);</span>
    }

    private V removeForMove(long id) {
<span class="fc" id="L141">        return data.remove(id);</span>
    }

    /*
     * Return true if the entry corresponding to the specified id is local.
     *
     * @return true or false.
     */
    public boolean containsId(long id) {
<span class="nc" id="L150">        return super.containsKey(id);</span>
    }

    /*
     * Get a place where the the corresponding entry of the specified id is stored.
     * Return null when it doesn't exist.
     *
     * @param id a Long type value.
     * @return the Place.
     */
    public Place getPlace(long id) {
<span class="nc" id="L161">        return ldist.dist.get(id);</span>
    }

    /*
     * Return the Set of local ids.
     *
     * @return the Set of local ids.
     */
    public Set&lt;Long&gt; idSet() {
<span class="nc" id="L170">        return keySet();</span>
    }

    /**
     * Execute the specified operation with the corresponding value of the specified id.
     * If the entry is stored at local, the operation is executed sequaltially.
     * If the entry is stored at a remote place, the operation is asynchronously executed at the place.
     *
     * @param id a Long type value.
     * @param op the operation.
     */
    public void execAt(long id, SerializableConsumer&lt;V&gt; op) {
<span class="nc" id="L182">        Place place = getPlace(id);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (place.equals(here())) {</span>
<span class="nc" id="L184">            op.accept(data.get(id));</span>
<span class="nc" id="L185">            return;</span>
        }
<span class="nc" id="L187">        asyncAt(place, ()-&gt;  {</span>
<span class="nc" id="L188">            op.accept(data.get(id));</span>
<span class="nc" id="L189">        });</span>
<span class="nc" id="L190">    }</span>
    @Override
    public void moveAtSync(Long key, Place dest, MoveManagerLocal mm) {
<span class="fc" id="L193">	moveAtSync(key.longValue(), dest, mm);</span>
<span class="fc" id="L194">    }</span>
    
    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSync(final long key, Place dest, MoveManagerLocal mm) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (dest.equals(here()))</span>
<span class="fc" id="L199">            return;</span>

<span class="fc" id="L201">        final DistIdMap&lt;V&gt; toBranch = this;</span>
<span class="fc" id="L202">        Serializer serialize = (ObjectOutputStream s) -&gt; {</span>
<span class="fc" id="L203">            V value = this.removeForMove(key);</span>
<span class="fc" id="L204">            byte mType = ldist.moveOut(key, dest);</span>
<span class="fc" id="L205">            s.writeLong(key);</span>
<span class="fc" id="L206">            s.writeByte(mType);</span>
<span class="fc" id="L207">            s.writeObject(value);</span>
<span class="fc" id="L208">        };</span>
<span class="fc" id="L209">        DeSerializer deserialize = (ObjectInputStream ds) -&gt; {</span>
<span class="fc" id="L210">            long k = ds.readLong();</span>
<span class="fc" id="L211">            byte mType = ds.readByte();</span>
<span class="fc" id="L212">            V v = (V) ds.readObject();</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if (_debug_level &gt; 5) {</span>
<span class="nc" id="L214">                System.err.println(&quot;[&quot; + here() + &quot;] putForMove key: &quot; + k + &quot; keyType: &quot; + mType + &quot; value: &quot; + v);</span>
            }
<span class="fc" id="L216">            toBranch.putForMove(k, mType, v);</span>
<span class="fc" id="L217">        };</span>
<span class="fc" id="L218">        mm.request(dest, serialize, deserialize);</span>
<span class="fc" id="L219">    }</span>
    
    @Override 
    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSync(Collection&lt;Long&gt; keys, Place dest, MoveManagerLocal mm) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (dest.equals(here())) return;</span>
<span class="nc" id="L225">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L226">        Serializer serialize = (ObjectOutputStream s) -&gt; {</span>
<span class="nc" id="L227">            int size = keys.size();</span>
<span class="nc" id="L228">            s.writeInt(size);</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            for (Long key: keys) {</span>
<span class="nc" id="L230">                V value = collection.removeForMove(key);</span>
<span class="nc" id="L231">                byte mType = ldist.moveOut(key, dest);</span>
<span class="nc" id="L232">                s.writeLong(key);</span>
<span class="nc" id="L233">                s.writeByte(mType);</span>
<span class="nc" id="L234">                s.writeObject(value);</span>
<span class="nc" id="L235">            }</span>
<span class="nc" id="L236">        };</span>
<span class="nc" id="L237">        DeSerializer deserialize = (ObjectInputStream ds) -&gt; {</span>
<span class="nc" id="L238">            int size = ds.readInt();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            for (int i =0; i&lt;size; i++) {</span>
<span class="nc" id="L240">                long key = ds.readLong();</span>
<span class="nc" id="L241">                byte mType = ds.readByte();</span>
<span class="nc" id="L242">                V value = (V)ds.readObject();</span>
<span class="nc" id="L243">                collection.putForMove(key, mType, value);</span>
            }
<span class="nc" id="L245">        };</span>
<span class="nc" id="L246">        mm.request(dest, serialize, deserialize);</span>
<span class="nc" id="L247">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSyncCount(int count, Place dest, MoveManagerLocal mm) {
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (dest.equals(here())) return;</span>
<span class="nc" id="L252">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L253">        Serializer serialize = (ObjectOutputStream s) -&gt; {</span>
<span class="nc" id="L254">            int size = count;</span>
<span class="nc" id="L255">            s.writeInt(size);</span>
<span class="nc" id="L256">            long[] keys = new long[size];</span>
<span class="nc" id="L257">            Object[] values = new Object[size];</span>

<span class="nc" id="L259">            int i = 0;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            for (Map.Entry&lt;Long, V&gt; entry: data.entrySet()) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">                if (i == size) break;</span>
<span class="nc" id="L262">                keys[i] = entry.getKey();</span>
<span class="nc" id="L263">                values[i] = entry.getValue();</span>
<span class="nc" id="L264">                i += 1;</span>
<span class="nc" id="L265">            }</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            for (int j=0; j&lt;size; j++) {</span>
<span class="nc" id="L267">                s.writeLong(keys[j]);</span>
            }
<span class="nc bnc" id="L269" title="All 2 branches missed.">            for (int j=0; j&lt;size; j++) {</span>
<span class="nc" id="L270">                s.writeObject(values[j]);</span>
            }
<span class="nc bnc" id="L272" title="All 2 branches missed.">            for (int j=0; j&lt;size; j++) {</span>
<span class="nc" id="L273">                long key = keys[j];</span>
<span class="nc" id="L274">                collection.removeForMove(key);</span>
<span class="nc" id="L275">                byte mType = ldist.moveOut(key, dest);</span>
<span class="nc" id="L276">                s.writeByte(mType);</span>
            }
<span class="nc" id="L278">        };</span>
<span class="nc" id="L279">        DeSerializer deserialize = (ObjectInputStream ds) -&gt; {</span>
<span class="nc" id="L280">            int size = ds.readInt();</span>
<span class="nc" id="L281">            long[] keys = new long[size];</span>
<span class="nc" id="L282">            Object[] values = new Object[size];</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">            for (int j=0; j&lt;size; j++) {</span>
<span class="nc" id="L285">                keys[j]= ds.readLong();</span>
            }
<span class="nc bnc" id="L287" title="All 2 branches missed.">            for (int j=0; j&lt;size; j++) {</span>
<span class="nc" id="L288">                values[j] = ds.readObject();</span>
            }
<span class="nc bnc" id="L290" title="All 2 branches missed.">            for (int j=0; j&lt;size; j++) {</span>
<span class="nc" id="L291">                byte mType = ds.readByte();</span>
<span class="nc" id="L292">                collection.putForMove(keys[j], mType, (V)values[j]);</span>
            }
<span class="nc" id="L294">        };</span>
<span class="nc" id="L295">        mm.request(dest, serialize, deserialize);</span>
<span class="nc" id="L296">    }</span>
    @Override
    public void moveAtSync(Function&lt;Long, Place&gt; rule, MoveManagerLocal mm) {
<span class="nc" id="L299">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L300">        HashMap&lt;Place, ArrayList&lt;Long&gt;&gt; keysToMove = new HashMap&lt;&gt;();</span>
<span class="nc" id="L301">        collection.forEach((Long key, V value) -&gt; {</span>
<span class="nc" id="L302">            Place destination = rule.apply(key);</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (!keysToMove.containsKey(destination)) {</span>
<span class="nc" id="L304">                keysToMove.put(destination, new ArrayList&lt;Long&gt;());</span>
            }
<span class="nc" id="L306">            keysToMove.get(destination).add(key);</span>
<span class="nc" id="L307">        });</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        for (Place p: keysToMove.keySet()) {</span>
<span class="nc" id="L309">            moveAtSync(keysToMove.get(p), p, mm);</span>
<span class="nc" id="L310">        }</span>
<span class="nc" id="L311">    }</span>
    @Override
    public void moveAtSync(Distribution&lt;Long&gt; dist, MoveManagerLocal mm) {
<span class="nc" id="L314">        Function&lt;Long,Place&gt; rule = (Long key) -&gt; { return dist.place(key);};</span>
<span class="nc" id="L315">        moveAtSync(rule, mm);</span>
<span class="nc" id="L316">    }</span>

    /* will be implemented in Java using TreeMap
    public def moveAtSync(range: LongRange, place: Place, mm:MoveManagerLocal) {U haszero}: void {

    }
    */
    // TODO???
    //public def moveAtSync(dist:Distribution[LongRange], mm:MoveManagerLocal): void {
    // no need for sparse array


    /**
     * Update the distribution information of the entries.
     */
    public void updateDist() {
<span class="nc" id="L332">        ldist.updateDist(placeGroup);</span>
<span class="nc" id="L333">    }</span>

    /*
    public def versioningIdMap(srcName : String){
        // return new BranchingManager[DistIdMap[T], Map[Long,T]](srcName, this);
        return null as BranchingManager[DistIdMap[T], Map[Long, T]];
    }*/

    /* Ensure calling updateDist() before balance()
     * balance() should be called in all places
     */
    public void checkDistInfo(long[] result) {
<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (Map.Entry&lt;Long, Place&gt; entry : ldist.dist.entrySet()) {</span>
            // val k = entry.getKey();
<span class="nc" id="L347">            Place v = entry.getValue();</span>
<span class="nc" id="L348">            result[placeGroup.rank(v)] += 1;</span>
<span class="nc" id="L349">        }</span>
<span class="nc" id="L350">    }</span>

/*
    //TODO different naming convention of balance methods with DistMap
    public void balance(MoveManagerLocal mm) throws Exception {
        int pgSize = placeGroup.size();
        ArrayList&lt;IFPair&gt; listPlaceLocality = new ArrayList&lt;&gt;();
        float localitySum = 0.0f;
        long globalDataSize =0;
        long[] localDataSize = new long[pgSize];

        for (int i = 0; i&lt;locality.length; i++) {
            localitySum += locality[i];
        }
 

        for (int i=0; i&lt; pgSize; i++) {
            globalDataSize += localDataSize[i];
            float normalizeLocality = locality[i] / localitySum;
            listPlaceLocality.add(new IFPair(i, normalizeLocality));
        }

        listPlaceLocality.sort((IFPair a1, IFPair a2)-&gt;{
            return (a1.second &lt; a2.second) ? -1 : (a1.second &gt; a1.second) ? 1 : 0;
        });

        if (_debug_level &gt; 5) {
            for (IFPair pair: listPlaceLocality) {
                System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; + pair.second + &quot;) &quot;);
            }
            System.out.println();
            placeGroup.barrier(); // for debug print
        }

        IFPair[] cumulativeLocality = new IFPair[pgSize];
        float sumLocality = 0.0f;
        for (int i=0; i&lt;pgSize; i++) {
            sumLocality += listPlaceLocality.get(i).second;
            cumulativeLocality[i] = new IFPair(listPlaceLocality.get(i).first, sumLocality);
        }
        cumulativeLocality[pgSize - 1] = new IFPair(listPlaceLocality.get(pgSize - 1).first, 1.0f);

        if (_debug_level &gt; 5) {
            for (int i=0; i&lt;pgSize; i++) {
                IFPair pair = cumulativeLocality[i];
                System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; + pair.second + &quot;, &quot; + localDataSize[pair.first] + &quot;/&quot; + globalDataSize + &quot;) &quot;);
            }
            System.out.println();
            placeGroup.barrier(); // for debug print
        }

        ArrayList&lt;ArrayList&lt;ILPair&gt;&gt; moveList = new ArrayList&lt;&gt;(pgSize); // ArrayList(index of dest Place, num data to export)
        LinkedList&lt;ILPair&gt; stagedData = new LinkedList&lt;&gt;(); // ArrayList(index of src, num data to export)
        long previousCumuNumData = 0;

        for (int i=0; i&lt;pgSize; i++) {
            moveList.add(new ArrayList&lt;ILPair&gt;());
        }

        for (int i=0; i&lt;pgSize; i++) {
            int placeIdx = cumulativeLocality[i].first;
            float placeLocality = cumulativeLocality[i].second;
            long cumuNumData = (long) (((float)globalDataSize) * placeLocality);
            long targetNumData = cumuNumData - previousCumuNumData;
            if (localDataSize[placeIdx] &gt; targetNumData) {
                stagedData.add(new ILPair(placeIdx, localDataSize[placeIdx] - targetNumData));
                if (_debug_level &gt; 5) {
                    System.out.print(&quot;stage src: &quot; + placeIdx + &quot; num: &quot; + (localDataSize[placeIdx] - targetNumData) + &quot;, &quot;);
                }
            }
            previousCumuNumData = cumuNumData;
        }
        if (_debug_level &gt; 5) {
            System.out.println();
            placeGroup.barrier(); // for debug print
        }

        previousCumuNumData = 0;
        for (int i=0; i&lt;pgSize; i++) {
            int placeIdx = cumulativeLocality[i].first;
            float placeLocality = cumulativeLocality[i].second;
            long cumuNumData = (long)(((float)globalDataSize) * placeLocality);
            long targetNumData = cumuNumData - previousCumuNumData;
            if (targetNumData &gt; localDataSize[placeIdx]) {
                long numToImport = targetNumData - localDataSize[placeIdx];
                while (numToImport &gt; 0) {
                    ILPair pair = stagedData.removeFirst();
                    if (pair.second &gt; numToImport) {
                        moveList.get(pair.first).add(new ILPair(placeIdx, numToImport));
                        stagedData.add(new ILPair(pair.first, pair.second - numToImport));
                        numToImport = 0;
                    } else {
                        moveList.get(pair.first).add(new ILPair(placeIdx, pair.second));
                        numToImport -= pair.second;
                    }
                }
            }
            previousCumuNumData = cumuNumData;
        }

        if (_debug_level &gt; 5) {
            for (int i=0; i&lt;pgSize; i++) {
                for (ILPair pair: moveList.get(i)) {
                    System.out.print(&quot;src: &quot; + i + &quot; dest: &quot; + pair.first + &quot; size: &quot; + pair.second + &quot;, &quot;);
                }
            }
            System.out.println();
            placeGroup.barrier(); // for debug print
        }


        if (_debug_level &gt; 5) {
            long[] diffNumData = new long[pgSize];
            for (int i=0; i&lt;pgSize; i++) {
                for (ILPair pair: moveList.get(i)) {
                    diffNumData[i] -= pair.second;
                    diffNumData[pair.first] += pair.second;
                }
            }
            for (IFPair pair: listPlaceLocality) {
                System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; + pair.second + &quot;, &quot; + (localDataSize[pair.first] + diffNumData[pair.first]) + &quot;/&quot; + globalDataSize + &quot;) &quot;);
            }
            System.out.println();
            placeGroup.barrier(); // for debug print
        }

        // Move Data
        for (int i=0; i&lt;pgSize; i++) {
            if (placeGroup.get(i).equals(here())) {

            }
        }

    }

    public void balance(float[] newLocality, MoveManagerLocal mm) throws Exception {
        System.arraycopy(newLocality, 0, locality, 0, placeGroup().size);
        balance(mm);
    }
*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>