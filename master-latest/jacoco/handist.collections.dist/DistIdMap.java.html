<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DistIdMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">DistIdMap.java</span></div><h1>DistIdMap.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.dist;

import static apgas.Constructs.*;

import java.io.ObjectStreamException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Set;
import java.util.concurrent.ConcurrentNavigableMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.function.Function;

import apgas.Place;
import apgas.util.GlobalID;
import handist.collections.LongRange;
import handist.collections.dist.ElementLocationManager.ParameterErrorException;
import handist.collections.dist.util.LazyObjectReference;
import handist.collections.dist.util.ObjectInput;
import handist.collections.dist.util.ObjectOutput;
import handist.collections.function.DeSerializer;
import handist.collections.function.SerializableConsumer;
import handist.collections.function.Serializer;

/**
 * Distributed Map using {@link Long} as key and type &lt;code&gt;V&lt;/code&gt; as value.
 * &lt;h2&gt;Distribution&lt;/h2&gt;
 * &lt;p&gt;
 * This map implementation has its distribution tracked using an internal
 * mechanism. A snapshot of the current distribution can be obtained through
 * method {@link #getDistribution()}.
 *
 * @param &lt;V&gt; the type of the value mappings of this instance
 */
public class DistIdMap&lt;V&gt; extends DistSortedMap&lt;Long, V&gt; implements DistributedCollection&lt;V, DistMap&lt;Long, V&gt;&gt;,
        ElementLocationManageable&lt;Long&gt;, RangeRelocatable&lt;LongRange&gt; {

<span class="fc" id="L52">    private static int _debug_level = 0;</span>
    protected final transient ElementLocationManager&lt;Long&gt; ldist;

    /**
     * Construct a DistIdMap. {@link TeamedPlaceGroup#getWorld()} is used as the
     * PlaceGroup of the new instance, a new {@link GlobalID} will also be created
     * for this new collection.
     */
    public DistIdMap() {
<span class="fc" id="L61">        this(TeamedPlaceGroup.getWorld());</span>
<span class="fc" id="L62">    }</span>

    /**
     * Construct a DistIdMap with the given argument. TeamOperations(placeGroup) is
     * used as the PlaceGroup of the new instance.
     *
     * @param placeGroup the PlaceGroup.
     */
    public DistIdMap(TeamedPlaceGroup placeGroup) {
<span class="fc" id="L71">        this(placeGroup, new GlobalID());</span>
<span class="fc" id="L72">    }</span>

    protected DistIdMap(TeamedPlaceGroup placeGroup, GlobalID id) {
<span class="fc" id="L75">        super(placeGroup, id, new ConcurrentSkipListMap&lt;&gt;());</span>
<span class="pc" id="L76">        super.GLOBAL = new GlobalOperations&lt;&gt;(this, (TeamedPlaceGroup pg0, GlobalID gid) -&gt; new DistIdMap&lt;&gt;(pg0, gid));</span>
        // TODO
<span class="fc" id="L78">        this.ldist = new ElementLocationManager&lt;&gt;();</span>
<span class="fc" id="L79">        ldist.setup(data.keySet());</span>
<span class="fc" id="L80">    }</span>

    /**
     * Remove the all local entries.
     */
    @Override
    public void clear() {
<span class="fc bfc" id="L87" title="All 2 branches covered.">        for (final Long k : data.keySet()) {</span>
<span class="fc" id="L88">            ldist.remove(k);</span>
<span class="fc" id="L89">        }</span>
<span class="fc" id="L90">        super.clear();</span>
<span class="fc" id="L91">        Arrays.fill(locality, 1.0f);</span>
<span class="fc" id="L92">    }</span>

    /*
     * Return true if the entry corresponding to the specified id is local.
     *
     * @return true or false.
     */
    public boolean containsId(long id) {
<span class="nc" id="L100">        return super.containsKey(id);</span>
    }

    public boolean delete(long id) {
<span class="nc" id="L104">        ldist.remove(id);</span>
<span class="nc" id="L105">        return super.delete(id);</span>
    }

    /*
     * Ensure calling updateDist() before balance() balance() should be called in
     * all places
     */
    public void distSize(long[] result) {
<span class="nc bnc" id="L113" title="All 2 branches missed.">        for (final Map.Entry&lt;Long, Place&gt; entry : ldist.dist.entrySet()) {</span>
            // val k = entry.getKey();
<span class="nc" id="L115">            final Place v = entry.getValue();</span>
<span class="nc" id="L116">            result[placeGroup.rank(v)] += 1;</span>
<span class="nc" id="L117">        }</span>
<span class="nc" id="L118">    }</span>

    /**
     * Execute the specified operation with the corresponding value of the specified
     * id.
     * &lt;ul&gt;
     * &lt;li&gt;If the entry is stored at local, the operation is executed sequentially.
     * &lt;li&gt;If the entry is stored at a remote place, the operation is asynchronously
     * executed on the remote place
     * &lt;/ul&gt;
     * &lt;p&gt;
     * In the remote case, this method returns immediately. Actual completion of the
     * operation can only be guaranteed if this method's enclosing
     * {@link apgas.Constructs#finish(apgas.Job)} has returned.
     *
     * @param id a Long type value.
     * @param op the operation.
     */
    public void execAt(long id, SerializableConsumer&lt;V&gt; op) {
<span class="nc" id="L137">        final Place place = getPlace(id);</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (place.equals(here())) {</span>
<span class="nc" id="L139">            op.accept(data.get(id));</span>
<span class="nc" id="L140">            return;</span>
        }
<span class="nc" id="L142">        asyncAt(place, () -&gt; {</span>
<span class="nc" id="L143">            op.accept(data.get(id));</span>
<span class="nc" id="L144">        });</span>
<span class="nc" id="L145">    }</span>

    /**
     * Get the corresponding value of the specified id in the local collection.
     *
     * @param id long index to retrieve
     * @return the corresponding value of the specified index, or {@code null} if
     *         the corresponding mapping was null or if there is no such mapping in
     *         the local collection
     */
    public V get(long id) {
<span class="nc" id="L156">        return data.get(id);</span>
    }

    @Deprecated
    @Override
    public Collection&lt;LongRange&gt; getAllRanges() {
        // Find range from the beginning. Modify if more efficient implementation.
<span class="fc" id="L163">        final Collection&lt;LongRange&gt; ret = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L164">        Long key = firstKey();</span>
<span class="fc" id="L165">        Long from = key;</span>
<span class="fc" id="L166">        final Long last = lastKey();</span>

<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        while (key &lt;= last) {</span>
<span class="fc" id="L169">            final Long next = higherKey(key);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (next == null) {</span>
<span class="fc" id="L171">                ret.add(new LongRange(from, key + 1));</span>
<span class="fc" id="L172">                break;</span>
            }
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (next != key + 1l) {</span>
<span class="fc" id="L175">                ret.add(new LongRange(from, key + 1));</span>
<span class="fc" id="L176">                from = next;</span>
            }
<span class="fc" id="L178">            key = next;</span>
<span class="fc" id="L179">        }</span>
<span class="fc" id="L180">        return ret;</span>
    }

    Map&lt;Long, Integer&gt; getDiff() {
<span class="nc" id="L184">        return ldist.diff;</span>
    }

    /**
     * Returns a newly created snapshot of the distribution of this
     * {@link DistIdMap}. Subsequent modifications to the distribution of this
     * distributed map will not be reflected into the returned instance.
     * &lt;p&gt;
     * In case an updated {@link LongDistribution} is needed, consider using
     * {@link #registerDistribution(UpdatableDistribution)} to update the
     * {@link LongDistribution} instance each time {@link #updateDist()} is called.
     * This is more efficient than calling {@link #getDistribution()}
     *
     * @return a newly created snapshot of the current distribution of this
     *         collection.
     */
    public LongDistribution getDistribution() {
<span class="fc" id="L201">        return new LongDistribution(ldist.dist);</span>
    }

    /*
     * Get a place where the the corresponding entry of the specified id is stored.
     * Return null when it doesn't exist.
     *
     * @param id a Long type value.
     *
     * @return the Place.
     */
    public Place getPlace(long id) {
<span class="nc" id="L213">        return ldist.dist.get(id);</span>
    }

    @Override
    public void getSizeDistribution(long[] result) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        for (final Map.Entry&lt;Long, Place&gt; entry : ldist.dist.entrySet()) {</span>
<span class="nc" id="L219">            final Place p = entry.getValue();</span>
<span class="nc" id="L220">            result[placeGroup.rank(p)]++;</span>
<span class="nc" id="L221">        }</span>
<span class="nc" id="L222">    }</span>

    /*
     * Return the Set of local ids.
     *
     * @return the Set of local ids.
     */
    public Set&lt;Long&gt; idSet() {
<span class="nc" id="L230">        return keySet();</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSync(Collection&lt;Long&gt; keys, Place dest, MoveManager mm) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (dest.equals(here())) {</span>
<span class="nc" id="L237">            return;</span>
        }
<span class="nc" id="L239">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L240">        final Serializer serialize = (ObjectOutput s) -&gt; {</span>
<span class="nc" id="L241">            final int size = keys.size();</span>
<span class="nc" id="L242">            s.writeInt(size);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            for (final Long key : keys) {</span>
<span class="nc" id="L244">                final V value = collection.removeForMove(key);</span>
<span class="nc" id="L245">                final byte mType = ldist.moveOut(key, dest);</span>
<span class="nc" id="L246">                s.writeLong(key);</span>
<span class="nc" id="L247">                s.writeByte(mType);</span>
<span class="nc" id="L248">                s.writeObject(value);</span>
<span class="nc" id="L249">            }</span>
<span class="nc" id="L250">        };</span>
<span class="nc" id="L251">        final DeSerializer deserialize = (ObjectInput ds) -&gt; {</span>
<span class="nc" id="L252">            final int size = ds.readInt();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L254">                final long key = ds.readLong();</span>
<span class="nc" id="L255">                final byte mType = ds.readByte();</span>
<span class="nc" id="L256">                final V value = (V) ds.readObject();</span>
<span class="nc" id="L257">                collection.putForMove(key, mType, value);</span>
            }
<span class="nc" id="L259">        };</span>
<span class="nc" id="L260">        mm.request(dest, serialize, deserialize);</span>
<span class="nc" id="L261">    }</span>

    @Override
    public void moveAtSync(Distribution&lt;Long&gt; dist, MoveManager mm) {
<span class="nc" id="L265">        final Function&lt;Long, Place&gt; rule = (Long key) -&gt; {</span>
<span class="nc" id="L266">            return dist.location(key);</span>
        };
<span class="nc" id="L268">        moveAtSync(rule, mm);</span>
<span class="nc" id="L269">    }</span>

    @Override
    public void moveAtSync(Function&lt;Long, Place&gt; rule, MoveManager mm) {
<span class="nc" id="L273">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L274">        final HashMap&lt;Place, ArrayList&lt;Long&gt;&gt; keysToMove = new HashMap&lt;&gt;();</span>
<span class="nc" id="L275">        collection.forEach((Long key, V value) -&gt; {</span>
<span class="nc" id="L276">            final Place destination = rule.apply(key);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (!keysToMove.containsKey(destination)) {</span>
<span class="nc" id="L278">                keysToMove.put(destination, new ArrayList&lt;Long&gt;());</span>
            }
<span class="nc" id="L280">            keysToMove.get(destination).add(key);</span>
<span class="nc" id="L281">        });</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">        for (final Place p : keysToMove.keySet()) {</span>
<span class="nc" id="L283">            moveAtSync(keysToMove.get(p), p, mm);</span>
<span class="nc" id="L284">        }</span>
<span class="nc" id="L285">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSync(final long key, Place dest, MoveManager mm) {
<span class="fc bfc" id="L289" title="All 2 branches covered.">        if (dest.equals(here())) {</span>
<span class="fc" id="L290">            return;</span>
        }

<span class="fc" id="L293">        final DistIdMap&lt;V&gt; toBranch = this;</span>
<span class="fc" id="L294">        final Serializer serialize = (ObjectOutput s) -&gt; {</span>
<span class="fc" id="L295">            final V value = this.removeForMove(key);</span>
<span class="fc" id="L296">            final byte mType = ldist.moveOut(key, dest);</span>
<span class="fc" id="L297">            s.writeLong(key);</span>
<span class="fc" id="L298">            s.writeByte(mType);</span>
<span class="fc" id="L299">            s.writeObject(value);</span>
<span class="fc" id="L300">        };</span>
<span class="fc" id="L301">        final DeSerializer deserialize = (ObjectInput ds) -&gt; {</span>
<span class="fc" id="L302">            final long k = ds.readLong();</span>
<span class="fc" id="L303">            final byte mType = ds.readByte();</span>
<span class="fc" id="L304">            final V v = (V) ds.readObject();</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">            if (_debug_level &gt; 5) {</span>
<span class="nc" id="L306">                System.err.println(&quot;[&quot; + here() + &quot;] putForMove key: &quot; + k + &quot; keyType: &quot; + mType + &quot; value: &quot; + v);</span>
            }
<span class="fc" id="L308">            toBranch.putForMove(k, mType, v);</span>
<span class="fc" id="L309">        };</span>
<span class="fc" id="L310">        mm.request(dest, serialize, deserialize);</span>
<span class="fc" id="L311">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void moveAtSync(Long from, Long to, Place dest, MoveManager mm) {
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (dest.equals(here())) {</span>
<span class="fc" id="L317">            return;</span>
        }

<span class="fc" id="L320">        final DistIdMap&lt;V&gt; toBranch = this;</span>
<span class="fc" id="L321">        final Serializer serialize = (ObjectOutput s) -&gt; {</span>
<span class="fc" id="L322">            final ConcurrentNavigableMap&lt;Long, V&gt; sub = data.subMap(from, to);</span>
<span class="fc" id="L323">            final int num = sub.size();</span>
<span class="fc" id="L324">            s.writeInt(num);</span>
<span class="pc bpc" id="L325" title="1 of 2 branches missed.">            if (num == 0) {</span>
<span class="nc" id="L326">                return;</span>
            }
<span class="fc" id="L328">            final Iterator&lt;Long&gt; iter = sub.keySet().iterator();</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L330">                final Long key = iter.next();</span>
<span class="fc" id="L331">                final V value = this.removeForMove(key);</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">                if (value == null) {</span>
<span class="nc" id="L333">                    throw new NullPointerException(&quot;DistIdMap.moveAtSync null pointer value of key: &quot; + key);</span>
                }
<span class="fc" id="L335">                final byte mType = ldist.moveOut(key, dest);</span>
<span class="fc" id="L336">                s.writeLong(key);</span>
<span class="fc" id="L337">                s.writeByte(mType);</span>
<span class="fc" id="L338">                s.writeObject(value);</span>
<span class="fc" id="L339">            }</span>
<span class="fc" id="L340">        };</span>
<span class="fc" id="L341">        final DeSerializer deserialize = (ObjectInput ds) -&gt; {</span>
<span class="fc" id="L342">            final int num = ds.readInt();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            for (int i = 0; i &lt; num; i++) {</span>
<span class="fc" id="L344">                final long k = ds.readLong();</span>
<span class="fc" id="L345">                final byte mType = ds.readByte();</span>
<span class="fc" id="L346">                final V v = (V) ds.readObject();</span>
<span class="fc" id="L347">                toBranch.putForMove(k, mType, v);</span>
            }
<span class="fc" id="L349">        };</span>
<span class="fc" id="L350">        mm.request(dest, serialize, deserialize);</span>
<span class="fc" id="L351">    }</span>

    @Override
    public void moveAtSync(Long key, Place dest, MoveManager mm) {
<span class="fc" id="L355">        moveAtSync(key.longValue(), dest, mm);</span>
<span class="fc" id="L356">    }</span>

    /**
     * Marks keys inner given range of this local handle for relocation using the
     * provided distribution to determine where each individual keys should go. The
     * transfer is actually performed the next the specified manager's
     * {@link CollectiveMoveManager#sync()} method is called.
     *
     * @param range transfer entries which keys index is range.from or more and less
     *              than range.to.
     * @param rule  the function that determines where each individual range should
     *              be relocated to
     * @param mm    the move manager in charge of the transfer
     */
    public void moveAtSync(LongRange range, LongRangeDistribution rule, MoveManager mm) {
<span class="fc" id="L371">        final Map&lt;LongRange, Place&gt; dest = rule.rangeLocation(range);</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (final Entry&lt;LongRange, Place&gt; entry : dest.entrySet()) {</span>
<span class="fc" id="L373">            moveRangeAtSync(entry.getKey(), entry.getValue(), mm);</span>
<span class="fc" id="L374">        }</span>
<span class="fc" id="L375">    }</span>

    /**
     * Marks all keys of this local handle for relocation using the provided
     * distribution to determine where each individual keys should go. The transfer
     * is actually performed the next the specified manager's
     * {@link CollectiveMoveManager#sync()} method is called.
     *
     * @param rule the function that determines where each individual range should
     *             be relocated to
     * @param mm   the move manager in charge of the transfer
     */
    public void moveAtSync(LongRangeDistribution rule, MoveManager mm) {
<span class="nc" id="L388">        final NavigableMap&lt;Long, V&gt; map = data;</span>
<span class="nc" id="L389">        moveAtSync(new LongRange(map.firstKey(), map.lastKey() + 1), rule, mm);</span>
<span class="nc" id="L390">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSyncCount(int count, Place dest, MoveManager mm) {
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (dest.equals(here())) {</span>
<span class="nc" id="L396">            return;</span>
        }
<span class="nc" id="L398">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L399">        final Serializer serialize = (ObjectOutput s) -&gt; {</span>
<span class="nc" id="L400">            final int size = count;</span>
<span class="nc" id="L401">            s.writeInt(size);</span>
<span class="nc" id="L402">            final long[] keys = new long[size];</span>
<span class="nc" id="L403">            final Object[] values = new Object[size];</span>

<span class="nc" id="L405">            int i = 0;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            for (final Map.Entry&lt;Long, V&gt; entry : data.entrySet()) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                if (i == size) {</span>
<span class="nc" id="L408">                    break;</span>
                }
<span class="nc" id="L410">                keys[i] = entry.getKey();</span>
<span class="nc" id="L411">                values[i] = entry.getValue();</span>
<span class="nc" id="L412">                i += 1;</span>
<span class="nc" id="L413">            }</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L415">                s.writeLong(keys[j]);</span>
            }
<span class="nc bnc" id="L417" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L418">                s.writeObject(values[j]);</span>
            }
<span class="nc bnc" id="L420" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L421">                final long key = keys[j];</span>
<span class="nc" id="L422">                collection.removeForMove(key);</span>
<span class="nc" id="L423">                final byte mType = ldist.moveOut(key, dest);</span>
<span class="nc" id="L424">                s.writeByte(mType);</span>
            }
<span class="nc" id="L426">        };</span>
<span class="nc" id="L427">        final DeSerializer deserialize = (ObjectInput ds) -&gt; {</span>
<span class="nc" id="L428">            final int size = ds.readInt();</span>
<span class="nc" id="L429">            final long[] keys = new long[size];</span>
<span class="nc" id="L430">            final Object[] values = new Object[size];</span>

<span class="nc bnc" id="L432" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L433">                keys[j] = ds.readLong();</span>
            }
<span class="nc bnc" id="L435" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L436">                values[j] = ds.readObject();</span>
            }
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L439">                final byte mType = ds.readByte();</span>
<span class="nc" id="L440">                collection.putForMove(keys[j], mType, (V) values[j]);</span>
            }
<span class="nc" id="L442">        };</span>
<span class="nc" id="L443">        mm.request(dest, serialize, deserialize);</span>
<span class="nc" id="L444">    }</span>

    /**
     * Marks keys inner given range for relocation over to the specified place. The
     * actual transfer will be performed the next time the specified manager's
     * {@link CollectiveMoveManager#sync()} method is called.
     *
     * @param range transfer entries which keys index is range.from or more and less
     *              than range.to.
     * @param dest  the place to which these keys should be relocated
     * @param mm    the manager in charge of performing the relocation
     */
    @Override
    public void moveRangeAtSync(LongRange range, Place dest, MoveManager mm) {
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (dest.equals(here())) {</span>
<span class="fc" id="L459">            return;</span>
        }
<span class="fc" id="L461">        moveAtSync(range.from, range.to, dest, mm);</span>
<span class="fc" id="L462">    }</span>

    /**
     * Put a new entry into the local map entry
     *
     * @param id    a Long type value.
     * @param value a value.
     */
    public V put(long id, V value) throws Exception {
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">        if (data.containsKey(id)) {</span>
<span class="nc" id="L472">            return data.put(id, value);</span>
        }
<span class="fc" id="L474">        ldist.add(id);</span>
<span class="fc" id="L475">        return data.put(id, value);</span>
    }

    @Override
    public V put(Long key, V value) {
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (data.containsKey(key)) {</span>
<span class="nc" id="L481">            return data.put(key, value);</span>
        }
<span class="fc" id="L483">        ldist.add(key);</span>
<span class="fc" id="L484">        return data.put(key, value);</span>
    }

    protected V putForMove(long key, byte mType, V value) throws Exception {
<span class="pc bpc" id="L488" title="2 of 3 branches missed.">        switch (mType) {</span>
        case ElementLocationManager.MOVE_NEW:
<span class="fc" id="L490">            ldist.moveInNew(key);</span>
<span class="fc" id="L491">            break;</span>
        case ElementLocationManager.MOVE_OLD:
<span class="nc" id="L493">            ldist.moveInOld(key);</span>
<span class="nc" id="L494">            break;</span>
        default:
<span class="nc" id="L496">            throw new Exception(&quot;SystemError when calling putForMove &quot; + key);</span>
        }
<span class="fc" id="L498">        return super.putForMove(key, value);</span>
    }

    @Override
    public void registerDistribution(UpdatableDistribution&lt;Long&gt; distributionToUpdate) {
<span class="fc" id="L503">        ldist.registerDistribution(distributionToUpdate);</span>
<span class="fc" id="L504">    }</span>

    /**
     * TODO : move to team operation and global operation
     *
     * @param rule the function that determines where each individual range should
     *             be relocated to
     */
    public void relocate(LongRangeDistribution rule) throws Exception {
<span class="nc" id="L513">        final CollectiveMoveManager mm = new CollectiveMoveManager(placeGroup());</span>
<span class="nc" id="L514">        moveAtSync(rule, mm);</span>
<span class="nc" id="L515">        mm.sync();</span>
<span class="nc" id="L516">    }</span>

    /**
     * TODO : move to team operation and global operation
     *
     * @param rule the function that determines where each individual range should
     *             be relocated to
     * @param mm   the move manager in charge of the transfer
     */
    public void relocate(LongRangeDistribution rule, CollectiveMoveManager mm) throws Exception {
<span class="nc" id="L526">        moveAtSync(rule, mm);</span>
<span class="nc" id="L527">        mm.sync();</span>
<span class="nc" id="L528">    }</span>

    /**
     * Removes a mapping from this distributed map local handle, or
     * &lt;code&gt;null&lt;/code&gt; if the object supplied as parameter is not a {@link Long}.
     *
     * @param key the Long key
     * @return the value to which the key was previously mapped to
     * @throws ParameterErrorException if there are no mappings associated with the
     *                                 specified key
     */
    @Override
    public V remove(Object key) {
<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (key instanceof Long) {</span>
<span class="fc" id="L542">            ldist.remove((Long) key);</span>
<span class="fc" id="L543">            return super.remove(key);</span>
        } else {
<span class="fc" id="L545">            return null;</span>
        }
    }

    private V removeForMove(long id) {
<span class="fc" id="L550">        return data.remove(id);</span>
    }

    /**
     * Update the distribution information of the entries.
     */
    @Override
    public void updateDist() {
<span class="fc" id="L558">        ldist.update(placeGroup);</span>
<span class="fc" id="L559">    }</span>

    @Override
    public Object writeReplace() throws ObjectStreamException {
<span class="fc" id="L563">        final TeamedPlaceGroup pg1 = placeGroup;</span>
<span class="fc" id="L564">        final GlobalID id1 = id;</span>
<span class="fc" id="L565">        return new LazyObjectReference&lt;&gt;(pg1, id1, () -&gt; {</span>
<span class="fc" id="L566">            return new DistIdMap&lt;&gt;(pg1, id1);</span>
        });
    }

    /*
     * //TODO different naming convention of balance methods with DistMap public
     * void balance(MoveManagerLocal mm) throws Exception { int pgSize =
     * placeGroup.size(); ArrayList&lt;IntFloatPair&gt; listPlaceLocality = new
     * ArrayList&lt;&gt;(); float localitySum = 0.0f; long globalDataSize =0; long[]
     * localDataSize = new long[pgSize];
     *
     * for (int i = 0; i&lt;locality.length; i++) { localitySum += locality[i]; }
     *
     *
     * for (int i=0; i&lt; pgSize; i++) { globalDataSize += localDataSize[i]; float
     * normalizeLocality = locality[i] / localitySum; listPlaceLocality.add(new
     * IntFloatPair(i, normalizeLocality)); }
     *
     * listPlaceLocality.sort((IntFloatPair a1, IntFloatPair a2)-&gt;{ return
     * (a1.second &lt; a2.second) ? -1 : (a1.second &gt; a1.second) ? 1 : 0; });
     *
     * if (_debug_level &gt; 5) { for (IntFloatPair pair: listPlaceLocality) {
     * System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; + pair.second + &quot;) &quot;); }
     * System.out.println(); placeGroup.barrier(); // for debug print }
     *
     * IntFloatPair[] cumulativeLocality = new IntFloatPair[pgSize]; float
     * sumLocality = 0.0f; for (int i=0; i&lt;pgSize; i++) { sumLocality +=
     * listPlaceLocality.get(i).second; cumulativeLocality[i] = new
     * IntFloatPair(listPlaceLocality.get(i).first, sumLocality); }
     * cumulativeLocality[pgSize - 1] = new
     * IntFloatPair(listPlaceLocality.get(pgSize - 1).first, 1.0f);
     *
     * if (_debug_level &gt; 5) { for (int i=0; i&lt;pgSize; i++) { IntFloatPair pair =
     * cumulativeLocality[i]; System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; + pair.second
     * + &quot;, &quot; + localDataSize[pair.first] + &quot;/&quot; + globalDataSize + &quot;) &quot;); }
     * System.out.println(); placeGroup.barrier(); // for debug print }
     *
     * ArrayList&lt;ArrayList&lt;IntLongPair&gt;&gt; moveList = new ArrayList&lt;&gt;(pgSize); //
     * ArrayList(index of dest Place, num data to export) LinkedList&lt;IntLongPair&gt;
     * stagedData = new LinkedList&lt;&gt;(); // ArrayList(index of src, num data to
     * export) long previousCumuNumData = 0;
     *
     * for (int i=0; i&lt;pgSize; i++) { moveList.add(new ArrayList&lt;IntLongPair&gt;()); }
     *
     * for (int i=0; i&lt;pgSize; i++) { int placeIdx = cumulativeLocality[i].first;
     * float placeLocality = cumulativeLocality[i].second; long cumuNumData = (long)
     * (((float)globalDataSize) * placeLocality); long targetNumData = cumuNumData -
     * previousCumuNumData; if (localDataSize[placeIdx] &gt; targetNumData) {
     * stagedData.add(new IntLongPair(placeIdx, localDataSize[placeIdx] -
     * targetNumData)); if (_debug_level &gt; 5) { System.out.print(&quot;stage src: &quot; +
     * placeIdx + &quot; num: &quot; + (localDataSize[placeIdx] - targetNumData) + &quot;, &quot;); } }
     * previousCumuNumData = cumuNumData; } if (_debug_level &gt; 5) {
     * System.out.println(); placeGroup.barrier(); // for debug print }
     *
     * previousCumuNumData = 0; for (int i=0; i&lt;pgSize; i++) { int placeIdx =
     * cumulativeLocality[i].first; float placeLocality =
     * cumulativeLocality[i].second; long cumuNumData =
     * (long)(((float)globalDataSize) * placeLocality); long targetNumData =
     * cumuNumData - previousCumuNumData; if (targetNumData &gt;
     * localDataSize[placeIdx]) { long numToImport = targetNumData -
     * localDataSize[placeIdx]; while (numToImport &gt; 0) { IntLongPair pair =
     * stagedData.removeFirst(); if (pair.second &gt; numToImport) {
     * moveList.get(pair.first).add(new IntLongPair(placeIdx, numToImport));
     * stagedData.add(new IntLongPair(pair.first, pair.second - numToImport));
     * numToImport = 0; } else { moveList.get(pair.first).add(new
     * IntLongPair(placeIdx, pair.second)); numToImport -= pair.second; } } }
     * previousCumuNumData = cumuNumData; }
     *
     * if (_debug_level &gt; 5) { for (int i=0; i&lt;pgSize; i++) { for (IntLongPair pair:
     * moveList.get(i)) { System.out.print(&quot;src: &quot; + i + &quot; dest: &quot; + pair.first +
     * &quot; size: &quot; + pair.second + &quot;, &quot;); } } System.out.println();
     * placeGroup.barrier(); // for debug print }
     *
     *
     * if (_debug_level &gt; 5) { long[] diffNumData = new long[pgSize]; for (int i=0;
     * i&lt;pgSize; i++) { for (IntLongPair pair: moveList.get(i)) { diffNumData[i] -=
     * pair.second; diffNumData[pair.first] += pair.second; } } for (IntFloatPair
     * pair: listPlaceLocality) { System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; +
     * pair.second + &quot;, &quot; + (localDataSize[pair.first] + diffNumData[pair.first]) +
     * &quot;/&quot; + globalDataSize + &quot;) &quot;); } System.out.println(); placeGroup.barrier();
     * // for debug print }
     *
     * // Move Data for (int i=0; i&lt;pgSize; i++) { if
     * (placeGroup.get(i).equals(here())) {
     *
     * } }
     *
     * }
     *
     * public void balance(float[] newLocality, MoveManagerLocal mm) throws
     * Exception { System.arraycopy(newLocality, 0, locality, 0, placeGroup().size);
     * balance(mm); }
     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>