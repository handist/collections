<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GlbOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.glb</a> &gt; <span class="el_source">GlbOperation.java</span></div><h1>GlbOperation.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.glb;

import static apgas.Constructs.*;
import static org.junit.Assert.*;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ForkJoinPool;

import apgas.MultipleException;
import apgas.Place;
import apgas.SerializableJob;
import apgas.util.GlobalID;
import handist.collections.dist.DistributedCollection;
import handist.collections.function.SerializableConsumer;
import handist.collections.function.SerializableSupplier;

/**
 * Operation to perform on a distributed collection under the GLB. This class
 * takes four generic type parameters:
 * &lt;ul&gt;
 * &lt;li&gt;the type of the distributed collection at hand C
 * &lt;li&gt;the type of the elements contained in the collection T
 * &lt;li&gt;the type used to designate elements of the collection to relocate
 * &lt;li&gt;the type of the ditributed collection representing the result of the
 * operation
 *
 * @author Patrick Finnerty
 *
 * @param &lt;C&gt; type of the distributed collection
 * @param &lt;T&gt; type of the individual elements contained by the collection
 * @param &lt;K&gt; type used to identify individual elements in the collection
 * @param &lt;D&gt; type used to identify elements for relocation, may be identical to
 *            K
 * @param &lt;R&gt; type of the distributed collection representing the result of the
 *            operation
 * @param &lt;L&gt; interface containing the method that workers need to call as part
 *            of their main routine
 */
@SuppressWarnings(&quot;rawtypes&quot;)
class GlbOperation&lt;C extends DistributedCollection&lt;T, C&gt;, T, K, D, R, L extends Serializable&gt;
        implements Serializable, Comparable&lt;GlbOperation&gt; {

    /**
     * Managed Blocker implementation used when waiting for the completion of an
     * operation which has already started.
     *
     * @author Patrick Finnerty
     * @see GlobalLoadBalancer#startAndWait(GlbOperation)
     */
    static class OperationCompletionManagedBlocker implements ForkJoinPool.ManagedBlocker {
        /** Semaphore instance around which this class is implemented */
        private volatile boolean releasable;

        /**
         * Constructor
         *
         * Builds a new managed blocker ready for use
         */
<span class="fc" id="L75">        public OperationCompletionManagedBlocker() {</span>
<span class="fc" id="L76">            releasable = false;</span>
<span class="fc" id="L77">        }</span>

        @Override
        public synchronized boolean block() throws InterruptedException {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            if (!releasable) {</span>
                try {
<span class="fc" id="L83">                    this.wait();</span>
<span class="nc" id="L84">                } catch (final InterruptedException e) {</span>
                    // Ignore the exception
<span class="fc" id="L86">                }</span>
            }
<span class="fc" id="L88">            return releasable;</span>
        }

        @Override
        public boolean isReleasable() {
<span class="fc" id="L93">            return releasable;</span>
        }

        public synchronized void unblock() {
<span class="fc" id="L97">            releasable = true;</span>
<span class="fc" id="L98">            notify();</span>
<span class="fc" id="L99">        }</span>
    }

    /**
     * Enumerator used to describe the state of the current operation.
     *
     */
<span class="fc" id="L106">    enum State {</span>
        /**
         * Value used to describe an operation as &quot;staged&quot;, i.e. the operation has been
         * submitted to the GLB but the next blocking operation inside the GLB program
         * has not been reached yet
         */
<span class="fc" id="L112">        STAGED,</span>
        /**
         * Value used to describe this operation as running, i.e. either being processed
         * by workers in the GLB or waiting on some dependencies to complete to start
         * computation
         */
<span class="fc" id="L118">        RUNNING,</span>

        /**
         * Value used to describe an operation as &quot;completed&quot;, i.e. all of the
         * assignments have been processed globally.
         */
<span class="fc" id="L124">        TERMINATED</span>
    }

<span class="fc" id="L127">    static int nextPriority = 0;</span>

    /** Serial Version UID */
    private static final long serialVersionUID = -7074061733010237021L;

    /**
     * Adds a completion dependency between the instance provided as parameter and
     * this operation.
     * &lt;p&gt;
     * In case the &quot;before&quot; dependency has already terminated, a dependency/hook
     * pair is not installed as the completion dependency is already satisfied.
     * &lt;p&gt;
     * If the &quot;after&quot; operation was submitted to the GLB before a blocking
     * operation, an {@link IllegalStateException} will be thrown.
     *
     * @param before operation which needs to complete before after can start
     * @param after  operation which will only start when the &quot;before&quot; operation has
     *               completed
     * @throws IllegalStateException if the call attempted to add a dependency on an
     *                               operation which may have already started.
     */
    static void makeDependency(GlbOperation&lt;?, ?, ?, ?, ?, ?&gt; before, GlbOperation&lt;?, ?, ?, ?, ?, ?&gt; after) {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (after.state != State.STAGED) {</span>
<span class="nc" id="L150">            throw new IllegalStateException(</span>
                    &quot;Attempted to add a completion dependency on an operation which may have already started&quot;);
        }

<span class="fc" id="L154">        synchronized (before) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (before.state == State.TERMINATED) {</span>
<span class="fc" id="L156">                return; // Nothing to install as the dependency is already satisfied</span>
            } else {
<span class="fc" id="L158">                synchronized (after) {</span>
<span class="fc" id="L159">                    after.dependencies.add(before); // protected against concurrent after#dependencySatisfied</span>
<span class="fc" id="L160">                }</span>
<span class="fc" id="L161">                before.addHook(() -&gt; after.dependencySatisfied(before));</span>
            }
<span class="fc" id="L163">        }</span>
<span class="fc" id="L164">    }</span>

    /**
     * Static method used to assign a priority to newly created GlbOperations.
     *
     * @return a unique priority level
     */
    /*
     * Implementation note:
     *
     * Even if there are more than the maximum value contained by integers
     * GlbOperations created over the course of an execution, the fact that this
     * counter loops back into negative values is not an issue.
     *
     * What would be an issue is if there were more that the maximum int value of
     * GlbOperation instances submitted to the GLB at the same time. But that would
     * probably be the result of a programming error rather than a real application.
     */
    private static int priority() {
<span class="fc" id="L183">        return nextPriority++;</span>
    }

    /**
     * Priority of this operation compared to other operations
     */
    int priority;

    /**
     * Variable used to keep track of the state of this operation. It will take the
     * following values in order:
     * &lt;ol&gt;
     * &lt;li&gt;{@link #OPERATION_STAGED}
     * &lt;li&gt;{@link #OPERATION_RUNNING}
     * &lt;li&gt;{@link #OPERATION_TERMINATED}
     * &lt;/ol&gt;
     * Any access to this member needs to be done through a synchronized block.
     */
    State state;

    /** Global id for this GlbOperation */
    GlobalID id;

    /** Distributed collection on which this operation is operating */
    C collection;

    /**
     * List of GlbOperations that need to terminate before this one can start.
     * Placing dependencies in this member can be done without protection. However,
     * one a Glb computation has started, no new dependency should be added to this
     * member.
     * &lt;p&gt;
     * When an operation on which this instance depends completes, it removes itself
     * from this member as part of one of its hooks (see member {@link #hooks}). If
     * this member is made empty as a result, that hook will start this instance's
     * computation.
     */
    private final transient Queue&lt;GlbOperation&lt;?, ?, ?, ?, ?, ?&gt;&gt; dependencies;

    /**
     * List of all the errors that were thrown during this operation's execution.
     * This member will remain null until method {@link #getErrors()} is called.
     */
<span class="fc" id="L226">    transient List&lt;Throwable&gt; errors = null;</span>

    /** Indicates if this operation is terminated */
    // private boolean finished = false;

    /**
     * Handle provided to the programmer inside a glb program to manipulate the
     * result of this operation or setup dependencies.
     */
    DistFuture&lt;R&gt; future;

    /** Jobs to do after completion */
    private transient final List&lt;SerializableJob&gt; hooks;

    /**
     * Initializer which will be called on every host if the GlbTask for the
     * operation was not previously initialized by another GlbOperation.
     */
    SerializableSupplier&lt;GlbTask&gt; initializerOfGlbTask;

    /**
     * The method to be called by workers. It expects an instance of the identifier
     * type K to perform the operation. The second argument (WorkerService) is here
     * to provide special services to the operation in case it requires them.
     */
    L operation;

    /**
     * Method to be called on every worker before this operation can start on a
     * host. May be null, in which case no particular action is needed.
     */
    SerializableConsumer&lt;WorkerService&gt; workerInit;

    /**
     * Class that should be used as the lifeline for a collection
     */
    final Class lifelineClass;

    /**
     * Constructor for GLB operation. The distributed collection under consideration
     * and the method to be called on it needs to be specified.
     *
     * @param c                    distributed collection on which this operation
     *                             will be applied
     * @param op                   method to call on each local host to perform the
     *                             computation
     * @param f                    object that is presented to the programmer inside
     *                             the GLB program in which the result will be
     *                             stored.
     * @param glbTaskInit          initializer of the class which will handle the
     *                             progression of this operation. It will be used if
     *                             not previously initialized for this collection
     *                             through another collection.
     * @param workerInitialization initialization to be performed on every worker in
     *                             the system before this operation starts. May be
     *                             null is not needed.
     * @param lifeline             the lifeline class to use with this collection.
     *                             If null, the default lifeline implementation will
     *                             be used. Note that changing the lifeline used by
     *                             a collection within the same GLB programm will
     *                             not work. The lifeline configuration used the
     *                             first time an operation on a collection is
     *                             submitted to the GLB is kept throughout a GLB
     *                             program
     */
    GlbOperation(C c, L op, DistFuture&lt;R&gt; f, SerializableSupplier&lt;GlbTask&gt; glbTaskInit,
            SerializableConsumer&lt;WorkerService&gt; workerInitialization, Class lifeline) {
<span class="fc" id="L293">        this(c, op, f, glbTaskInit, workerInitialization, State.STAGED, new GlobalID(), priority(), lifeline);</span>
<span class="fc" id="L294">    }</span>

    /**
     * Private constructor used when the GlobalID is known.
     *
     * @param c                    the collection on which this operation operates
     * @param op                   the closure which actually performs the work
     * @param f                    the future which will handle the result of this
     *                             operation
     * @param glbTaskInit          initialization that will prepare the manager of
     *                             the assignments of the distributed collection
     * @param workerInitialization initialization that needs to be performed on
     *                             every worker prior to the
     * @param s                    state of the GlbOperation (staged, running or
     *                             terminated)
     * @param gid                  global id
     */
    private GlbOperation(C c, L op, DistFuture&lt;R&gt; f, SerializableSupplier&lt;GlbTask&gt; glbTaskInit,
            SerializableConsumer&lt;WorkerService&gt; workerInitialization, State s, GlobalID gid, int priorityLevel,
<span class="fc" id="L313">            Class lifeline) {</span>
<span class="fc" id="L314">        collection = c;</span>
<span class="fc" id="L315">        operation = op;</span>
<span class="fc" id="L316">        future = f; // We need a 2-way link between the GlbOperation and the</span>
<span class="fc" id="L317">        future.operation = this; // DistFuture</span>
<span class="fc" id="L318">        hooks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L319">        dependencies = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L320">        initializerOfGlbTask = glbTaskInit;</span>
<span class="fc" id="L321">        workerInit = workerInitialization;</span>
<span class="fc" id="L322">        state = s;</span>
<span class="fc" id="L323">        id = gid;</span>
<span class="fc" id="L324">        priority = priorityLevel;</span>
<span class="fc" id="L325">        lifelineClass = lifeline; // may be null</span>
<span class="fc" id="L326">        id.putHere(this);</span>
<span class="fc" id="L327">    }</span>

    /**
     * Adds a hook that will be performed upon global termination of this operation.
     *
     * @param j the job to do after this operation has completed
     */
    void addHook(SerializableJob j) {
<span class="fc" id="L335">        hooks.add(j);</span>
<span class="fc" id="L336">    }</span>

    /**
     * The comparable interface is used so that the GlbOperations can be compared by
     * their priority. This helps us sort the GlbOperations in the various
     * {@link TreeMap} and {@link ConcurrentSkipListMap} used by the GLB runtime
     * which influence the order in which operations are processed.
     */
    @Override
    public int compareTo(GlbOperation o) {
<span class="fc" id="L346">        return priority - o.priority;</span>
    }

    /**
     * Starts this computation and executes the various hooks once it had completed.
     * If an exception occurs during the computation, it will be caught by this
     * method and thrown after all the hooks for this computation are given a chance
     * to be executed. If a hook throws an exception, it will be printed to
     * {@link System#err} but not thrown.
     *
     * @throws MultipleException if an exception was thrown as part of the
     *                           computation
     */
    void compute() {
        // The state &quot;running&quot; needs to be set before calling this method
<span class="fc" id="L361">        assertEquals(State.RUNNING, state);</span>
<span class="fc" id="L362">        MultipleException me = null;</span>
        try {
<span class="fc" id="L364">            collection.placeGroup().broadcastFlat(() -&gt; {</span>
                // The GLB routine for this operation is called from here
<span class="fc" id="L366">                final GlbComputer glb = GlbComputer.getComputer();</span>
<span class="fc" id="L367">                glb.newOperation(this);</span>
<span class="fc" id="L368">            });</span>
<span class="nc" id="L369">        } catch (final MultipleException e) {</span>
<span class="nc" id="L370">            me = e;</span>
<span class="fc" id="L371">        }</span>

<span class="fc" id="L373">        synchronized (this) {</span>
<span class="fc" id="L374">            state = State.TERMINATED;</span>
<span class="fc" id="L375">        }</span>
        // The operation has completed, we execute the various hooks it may have
<span class="fc bfc" id="L377" title="All 2 branches covered.">        for (final SerializableJob h : hooks) {</span>
            try {
<span class="fc" id="L379">                h.run();</span>
<span class="nc" id="L380">            } catch (final Exception e) {</span>
<span class="nc" id="L381">                System.err.println(&quot;Exception was thrown as part of operation&quot; + this);</span>
<span class="nc" id="L382">                e.printStackTrace();</span>
<span class="fc" id="L383">            }</span>
<span class="fc" id="L384">        }</span>

        // finished = true;

        // If a MultipleException was caught, throw it
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if (me != null) {</span>
<span class="nc" id="L390">            throw me;</span>
        }
<span class="fc" id="L392">    }</span>

    /**
     * Method called by a GlbOperation when it has completed and needs to notify
     * this instance which is waiting for that dependency to complete. If all the
     * dependencies of this instance are satisfied as a result, launches the
     * computation of this instance.
     * &lt;p&gt;
     * This method is synchronized to prevent multiple dependencies from
     * concurrently manipulate the {@link #dependencies} collection and launching
     * this computation multiple times.
     *
     * @param dep the operation which has completed
     */
    /*
     * Correct programming of the load balancer ensures that no operation will try
     * to signal that it has completed to an operation of which it is not a
     * dependency, or signal its completion multiple times. However the current
     * implementation elegantly allows such inconsistent cases without any adverse
     * effects. Only when assertions are activated with command line option -ea
     * (enable assertions) that such a case would throw an assertion exception in
     * this method
     */
    private synchronized void dependencySatisfied(GlbOperation&lt;?, ?, ?, ?, ?, ?&gt; dep) {
<span class="fc" id="L416">        final boolean removed = dependencies.remove(dep);</span>
<span class="fc" id="L417">        assertTrue(dep + &quot; was not a dependency of &quot; + this + &quot; attempted to unblock &quot; + this + &quot; anyway.&quot;, removed);</span>

<span class="pc bpc" id="L419" title="1 of 4 branches missed.">        if (state == State.RUNNING &amp;&amp; dependencies.isEmpty()) {</span>
<span class="fc" id="L420">            async(() -&gt; this.compute());</span>
        }
<span class="fc" id="L422">    }</span>

    /**
     * GlbOperation are considered the same if they share the same global id. Other
     * members are not checked. This could a problem if GlobalID instances were
     * re-used carelessly but should otherwise be fine. As GlbOperation's
     * constructor does not allow for an arbitrary id to be given at initialization,
     * this is unlikely to become a problem.
     */
    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        if (o instanceof GlbOperation) {</span>
<span class="fc" id="L434">            return id.equals(((GlbOperation) o).id);</span>
        } else {
<span class="nc" id="L436">            return false;</span>
        }
    }

    /**
     * Indicates if this operation has been completed
     *
     * @return true if this operation has completed, false otherwise
     */
    public boolean finished() {
<span class="fc bfc" id="L446" title="All 2 branches covered.">        return state == State.TERMINATED;</span>
    }

    /**
     * If not previously called, gathers all the Throwables caught on the various
     * hosts and gathers them into a single list which is then returned.
     * &lt;p&gt;
     * This method should only be called AFTER this operation has completed
     * globally, i.e. if calling the {@link #finished()} method returned
     * {@code true}
     *
     * @return a list of all the throwables that were thrown during the operation
     */
    List&lt;Throwable&gt; getErrors() {
<span class="fc" id="L460">        assertEquals(State.TERMINATED, state);</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (errors == null) { // If this method was not previously called</span>
<span class="fc" id="L462">            errors = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">            for (final Place p : collection.placeGroup().places()) {</span>
<span class="fc" id="L464">                final ArrayList&lt;Throwable&gt; remoteErrors = at(p, () -&gt; { // Synchronous call. Maybe we can do better?</span>
<span class="fc" id="L465">                    return GlbComputer.getComputer().operationErrors.get(this);</span>
                });
<span class="fc bfc" id="L467" title="All 2 branches covered.">                if (remoteErrors != null) {</span>
<span class="fc" id="L468">                    errors.addAll(remoteErrors);</span>
                }

<span class="fc" id="L471">            }</span>
        }

<span class="fc" id="L474">        return errors;</span>
    }

    /**
     * Indicates if this operation has uncompleted dependencies.
     *
     * @return true if other operation need to complete before this operation can
     *         start, false otherwise
     */
    public boolean hasDependencies() {
<span class="fc bfc" id="L484" title="All 2 branches covered.">        return !dependencies.isEmpty();</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L489">        return (int) id.gid();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>