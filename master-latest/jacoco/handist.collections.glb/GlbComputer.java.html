<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GlbComputer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.glb</a> &gt; <span class="el_source">GlbComputer.java</span></div><h1>GlbComputer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.glb;

import static apgas.Constructs.*;
import static apgas.ExtendedConstructs.*;
import static handist.collections.glb.GlobalLoadBalancer.*;
import static org.junit.Assert.*;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerArray;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import apgas.GlobalRuntime;
import apgas.Place;
import apgas.impl.Finish;
import apgas.util.PlaceLocalObject;
import handist.collections.Bag;
import handist.collections.dist.DistLog;
import handist.collections.dist.DistributedCollection;
import handist.collections.dist.TeamedPlaceGroup;
import handist.collections.glb.lifeline.Lifeline;
import handist.collections.glb.lifeline.LifelineFactory;
import handist.collections.glb.lifeline.Loop;

/**
 * Distributed object in charge of handling the GLB runtime and the work
 * stealing and between hosts.
 *
 * @author Patrick Finnerty
 *
 */
class GlbComputer extends PlaceLocalObject {

    /**
     * Class representing the fact that a host wants to steal some work from another
     * host.
     *
     * @author Patrick Finnerty
     *
     */
    final static class LifelineToken implements Serializable {
        /** Serial Version UID */
        private static final long serialVersionUID = 1445594155772627013L;
        /** Distributed collection from which assignments are desired */
        @SuppressWarnings(&quot;rawtypes&quot;)
        DistributedCollection collection;
        /**
         * Place performing the steal / answering a lifeline steal
         */
        Place place;

        /**
         * Constructor for a lifeline token. The target collection and the source of the
         * steal are specified as parameters
         *
         * @param c distributed collection from which work is desired
         * @param p place which is trying to steal some work
         */
<span class="fc" id="L78">        private LifelineToken(@SuppressWarnings(&quot;rawtypes&quot;) DistributedCollection c, Place p) {</span>
<span class="fc" id="L79">            collection = c;</span>
<span class="fc" id="L80">            place = p;</span>
<span class="fc" id="L81">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L85">            return &quot;LifelineToken[&quot; + place + &quot;/&quot; + collection + &quot;]&quot;;</span>
        }
    }

    /**
     * Class containing information and logging facilities of an individual worker.
     * As part of the initialization process for the GLB, an instance of this class
     * is prepared for each concurrent worker that may run on the host.
     *
     * @author Patrick Finnerty
     *
     */
    final class WorkerInfo implements WorkerService {

        /**
         * Counts the number of times this worker split its assignment to increase
         * parallelism on the host
         */
        int assignmentSplit;

        /**
         * Counts the number of times this worker tried to split its assignment but
         * failed to do so as the assignment it held was too small
         */
        int assignmentUnabledToSplit;

        /** Current operation being processed by this worker */
        @SuppressWarnings(&quot;rawtypes&quot;)
        GlbOperation currentOperation;

        /** Unique integer identifier */
        final int id;

        /**
         * Number of times the worker made an answer to a remote thief.
         */
        public int lifelineAnswer;

        /**
         * Number of times the worker attempted to make an answer to a lifeline thief
         * but this attempt failed because no assignments were available on the local
         * host.
         */
        public int lifelineCannotAnswer;

        /**
         * Time (in nanoseconds) spent working by this worker. The time spent yielding
         * is not included.
         */
        public long timeWorking;

        /** Time spent yielding to other tasks (not counted in {@link #timeWorking}) */
        public long timeYielding;

        /**
         * Counts the number of times this worker successfully takes an assignment from
         * the reserve for itself
         */
        int tookFromReserve;

        /**
         * In some operations, an object may need to remain bound to a single worker and
         * used throughout the processing of the operation. In such a case, this objects
         * is kept in this collection.
         */
        final Map&lt;Object, Object&gt; workerBoundObjects;

        /**
         * Counts the number of times this worker was spawned
         */
        int workerSpawned;

        /**
         * Constructor
         * &lt;p&gt;
         * The unique identifier of the instance created needs to be specified as
         * parameter.
         *
         * @param workerId identifier for the object to create
         */
<span class="fc" id="L165">        public WorkerInfo(int workerId) {</span>
<span class="fc" id="L166">            id = workerId;</span>
<span class="fc" id="L167">            workerBoundObjects = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L168">        }</span>

        @Override
        public void attachOperationObject(Object key, Object o) {
<span class="fc" id="L172">            workerBoundObjects.put(key, o);</span>
<span class="fc" id="L173">        }</span>

        @Override
        public Object retrieveOperationObject(Object key) {
<span class="fc" id="L177">            return workerBoundObjects.get(key);</span>
        }

        @Override
        public void throwableInOperation(Throwable t) {
            @SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc" id="L183">            final Map&lt;GlbOperation, ArrayList&lt;Throwable&gt;&gt; errors = getComputer().operationErrors;</span>

<span class="fc" id="L185">            synchronized (errors) {</span>
<span class="fc" id="L186">                errors.computeIfAbsent(currentOperation, k -&gt; new ArrayList&lt;&gt;()).add(t);</span>
<span class="fc" id="L187">            }</span>
<span class="fc" id="L188">        }</span>
    }

    /**
     * Class used on each host to hold the work from which workers and remote steals
     * take from.
     * &lt;p&gt;
     * Internally it manages the (multiple) {@link GlbTask} instances that are being
     * processes on the host. Workers obtain pieces of work through an instance of
     * this class
     *
     * @author Patrick Finnerty
     *
     */
    final class WorkReserve {
        /**
         * Lock used to guarantee availability of {@link WorkerInfo} instances inside
         * the {@link #idleWorkers} collection when they fail to take some work from
         * this instance.
         */
        final ReadWriteLock lock;

        /**
         * Map from distributed collection to their respective GlbTask instance. This
         * map is used to keep track of distributed collections that may already have an
         * operation in progress. If that is the case and an additional operation comes
         * along, this operation will need to be added to the existing {@link GlbTask}
         * of this distributed collection.
         */
        Map&lt;Object, GlbTask&gt; allTasks;

        /**
         * Map which contains the operation with work left as keys and the GlbTask is in
         * charge of handling the corresponding assignments. As all the assignments of a
         * certain operations are completed, the mapping in this collection will be
         * removed at the GlbTask's initiative as part of the
         * {@link Assignment#process(int)} method. This map is traversed when workers
         * try to acquire a new assignment from the reserve in method
         * {@link #getAssignment()}.
         */
        @SuppressWarnings(&quot;rawtypes&quot;)
        ConcurrentSkipListMap&lt;GlbOperation, GlbTask&gt; tasksWithWork;

        /**
         * Constructor
         * &lt;p&gt;
         * Prepares the members of WorkReserve to receive the various GLB operations
         */
<span class="fc" id="L236">        WorkReserve() {</span>
<span class="fc" id="L237">            lock = new ReentrantReadWriteLock();</span>
<span class="fc" id="L238">            allTasks = new HashMap&lt;&gt;();</span>
<span class="fc" id="L239">            tasksWithWork = new ConcurrentSkipListMap&lt;&gt;();</span>
<span class="fc" id="L240">        }</span>

        /**
         * Checks the GlbTask of the current host to provide some work to a worker.
         * &lt;p&gt;
         * If at the time this method is called no work could be selected, returns null
         * instead.
         * &lt;p&gt;
         * This implementation uses the natural ordering of class {@link GlbOperation}
         * in a {@link ConcurrentSkipListMap} to favor the higher priority
         * {@link GlbOperation}s.
         *
         * @param wInfo the worker info instance which will be placed back into the
         *              #idleWorkers collection if calling this method did not result in
         *              an Assignment being given to the worker
         * @return the provided instance with updates, or null if no work could be
         *         obtained
         */
        Assignment getAssignment(WorkerInfo wInfo) {
<span class="fc" id="L259">            lock.readLock().lock();</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">            for (final GlbTask t : tasksWithWork.values()) {</span>
                Assignment a;
<span class="fc bfc" id="L262" title="All 2 branches covered.">                if ((a = t.assignWorkToWorker()) != null) {</span>
<span class="fc" id="L263">                    lock.readLock().unlock();</span>
<span class="fc" id="L264">                    return a;</span>
                }
<span class="fc" id="L266">            }</span>
            // Unable to get an assignment for the worker
<span class="fc" id="L268">            idleWorkers.add(wInfo);</span>
<span class="fc" id="L269">            lock.readLock().unlock();</span>

<span class="fc" id="L271">            reserveWasEmptied();</span>
<span class="fc" id="L272">            return null;</span>
        }

        /**
         * Registers a new operation in the local reserve
         *
         * @param op operation newly available to workers
         * @return true if some work was actually made available to workers as a result
         *         of this operation
         */
        @SuppressWarnings(&quot;rawtypes&quot;)
        public synchronized boolean newOperation(GlbOperation op) {
            // There is a GlbTask instance for the underlying collection (either created or
            // retrieved)
            GlbTask toPlaceInAvailable;
<span class="fc bfc" id="L287" title="All 2 branches covered.">            if (!allTasks.containsKey(op.collection)) {</span>
                // We need to create a new GlbTask for the target collection
<span class="fc" id="L289">                toPlaceInAvailable = (GlbTask) op.initializerOfGlbTask.get();</span>
<span class="fc" id="L290">                allTasks.put(op.collection, toPlaceInAvailable);</span>
            } else {
                // We &quot;add&quot; the operation to the existing instance
<span class="fc" id="L293">                toPlaceInAvailable = allTasks.get(op.collection);</span>
            }

<span class="fc" id="L296">            final boolean workCreated = toPlaceInAvailable.newOperation(op);</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if (workCreated) {</span>
                // The GlbTask may already be present in tasksWithWork if another operation is
                // being processed already. HashSet#add will keep the tasksWithWork set
                // unchanged in this case.
<span class="fc" id="L301">                tasksWithWork.put(op, toPlaceInAvailable);</span>
            }
<span class="fc" id="L303">            return workCreated;</span>
        }
    }

    /** Singleton, local handle instance */
<span class="fc" id="L308">    private static GlbComputer computer = null;</span>

    /**
     * Code used in member {@link #lifelineEstablished} to represent the fact that
     * this place had a lifeline established with the remote host
     *
     * @see #establishingLifelineOnRemoteHost(DistributedCollection)
     */
    private static final int LIFELINE_ESTABLISHED = 1;

    /**
     * Code used in member {@link #lifelineEstablished} to represent the fact that
     * this place has not established a lifeline with a remote host
     *
     * @see #establishingLifelineOnRemoteHost(DistributedCollection)
     */
    private static final int LIFELINE_NOT_ESTABLISHED = 0;

    /**
     * Setting describing if tracing is activated. If so, a number of output
     * messages are made to {@link System#err} as GLB events occur.
     */
<span class="fc" id="L330">    static boolean TRACE = Boolean.parseBoolean(System.getProperty(Config.ACTIVATE_TRACE, &quot;false&quot;));</span>

    /**
     * Destroys the GlbComputer singleton on all places. This method should be
     * called before calling method {@link #initializeComputer(DistLog)} or
     * {@link #getComputer()}
     */
    static void destroyGlbComputer() {
<span class="fc" id="L338">        TeamedPlaceGroup.getWorld().broadcastFlat(() -&gt; {</span>
<span class="fc" id="L339">            computer = null;</span>
<span class="fc" id="L340">        });</span>
<span class="fc" id="L341">    }</span>

    /**
     * Method returning the local singleton for GlbComputer. May return null if
     * method {@link #initializeComputer(DistLog)} was not called beforehand.
     *
     * @return GlbComputer local handle
     */
    static GlbComputer getComputer() {
//        if (computer == null) {
//            final DistLog log = new DistLog();
//            computer = PlaceLocalObject.make(TeamedPlaceGroup.getWorld().places(), () -&gt; {
//                final GlbComputer c = new GlbComputer(log);
//                // Assign the static member of class GlbComputer here
//                // Doing so here avoids the need for a second finish/asyncAt block
//                GlbComputer.computer = c;
//                if (TRACE) {
//                    System.err.println(&quot;GlbComputer on &quot; + here() + &quot; is &quot; + c);
//                }
//                return c;
//            });
//        }
<span class="fc" id="L363">        assertNotNull(computer);</span>
<span class="fc" id="L364">        return computer;</span>
    }

    /**
     * Performs the global initialization of a GlbComputer instance on all hosts.
     * Any previous instance must be destroyed before calling this method.
     *
     * @param log the logger instance into which all the event that occur as part of
     *            the GLB program eecution will be recorded
     * @return the GlbComputer instance created locally
     */
    static GlbComputer initializeComputer(DistLog log) {
<span class="fc" id="L376">        return PlaceLocalObject.make(TeamedPlaceGroup.getWorld().places(), () -&gt; {</span>
<span class="fc" id="L377">            final GlbComputer c = new GlbComputer(log);</span>
            // Assign the static member of class GlbComputer here
            // Doing so here avoids the need for a second dedicated finish/asyncAt block
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">            if (computer == null) {</span>
<span class="fc" id="L381">                GlbComputer.computer = c;</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">                if (TRACE) {</span>
<span class="nc" id="L383">                    System.err.println(&quot;GlbComputer on &quot; + here() + &quot; is &quot; + c);</span>
                }
            } else {
<span class="nc" id="L386">                throw new IllegalStateException(&quot;Previous GlbComputer was not destroyed on &quot; + here());</span>
            }
<span class="fc" id="L388">            return c;</span>
        });
    }

    /**
     * Map associating every GlbOperation with the semaphore used to block the
     * thread representing the presence of work for this operation.
     * &lt;p&gt;
     * This member needs to be accessed through a synchronized block as it is not
     * protected against concurrent modifications. As it is not accessed often, the
     * use of a concurrent data structure is not warranted.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    private final Map&lt;GlbOperation, OperationBlocker&gt; blockers;

    /**
     * Atomic array used to signal to workers that they need to place some work back
     * into the {@link #reserve}. Each worker is identified with a unique index.
     * They use this identifier to access this array which is initialized with an
     * initial length of {@link #MAX_WORKERS}.
     * &lt;p&gt;
     * The value used in this array are:
     * &lt;ul&gt;
     * &lt;li&gt;0: the worker can move on in its {@link #worker(Integer, Assignment)}
     * procedure's main loop, the {@link #reserve} does not need to be fed with work
     * &lt;li&gt;1: the worker should feed the {@link #reserve} in its main loop before
     * setting its value back to 0.
     * &lt;/ul&gt;
     */
    private final AtomicIntegerArray feedReserveRequested;

    /**
     * Map associating every GlbOperation with the finish instance in which they are
     * being executed
     */
    /*
     * This member needs to be protected against concurrent modifications as there
     * is a risk that multiple starting operations may try to insert their &quot;finish&quot;
     * value inside this collection concurrently. While we could use synchronized
     * blocks for all accesses made to this object, it would be error-prone as
     * workers making lifeline answer may access this object at any time from
     * outside this object. A concurrent data collection was therefore preferred.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    final ConcurrentHashMap&lt;GlbOperation, Finish&gt; finishes;

    /**
     * Number of elements processed by workers in one gulp before they check the
     * runtime
     */
    volatile int granularity;

    /**
     * Concurrent linked list which contains the inactive workers that may run on
     * the host if they are given an assignment.
     */
    private final ConcurrentLinkedDeque&lt;WorkerInfo&gt; idleWorkers;

    /**
     * Collection used to keep track of the lifelines that are established on remote
     * hosts
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    ConcurrentHashMap&lt;DistributedCollection, ConcurrentHashMap&lt;Place, AtomicInteger&gt;&gt; lifelineEstablished;

    /**
     * Lifeline requests for work coming from remote places in the system.
     * &lt;p&gt;
     * A lifeline request consists in a token which contains the distributed
     * collection which is the target of the steal and the Place which requires the
     * work. Refer to
     */
    ConcurrentLinkedQueue&lt;LifelineToken&gt; lifelineThieves;

    /**
     * Logger for the events occurring on this host
     */
    DistLog logger;

    /**
     * Maximum number of workers that can concurrently run on the local host
     */
    final int MAX_WORKERS;

    /**
     * Member used for book-keeping of the errors that occur during GLB operations.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    final transient Map&lt;GlbOperation, ArrayList&lt;Throwable&gt;&gt; operationErrors;

    /** Fork Join Pool used by the APGAS runtime */
    final ForkJoinPool POOL;

    /**
     * Instance in which the workers on a host take / place work back into
     */
    WorkReserve reserve;

    /**
     * Collection of Locks which contains the locks that are available for workers
     * to pick up to actively yield to other activities.
     */
    private final ConcurrentLinkedQueue&lt;TimeoutBlocker&gt; workerAvailableLocks;

    /**
     * Array containing all the workers initialized on the host Contrary to
     * {@link #idleWorkers}, the contents of this array never change. This array is
     * used to access all the workers irrespective of if they are running or idle.
     * &lt;p&gt;
     * One particular case we need to access all workers is when an operation needs
     * to attach an object to each worker which is needed when this operation is
     * processed by a the workers.
     */
    final WorkerInfo[] workers;

    /**
     * Lock used to force workers to yield execution to allow other activities to
     * run
     */
    private final TimeoutBlocker workerYieldLock;

    /**
     * Private constructor
     * &lt;p&gt;
     * GlbComputer is a global object that follows a singleton design pattern. This
     * constructor is made private to protect this property.
     *
     * @param log the logger instance into which the events that occur on this host
     *            will be recorded throughout the execution
     */
<span class="fc" id="L518">    private GlbComputer(DistLog log) {</span>
        // Set the constants related to runtime environment
<span class="fc" id="L520">        MAX_WORKERS = Config.getMaximumConcurrentWorkers();</span>
<span class="fc" id="L521">        POOL = (ForkJoinPool) GlobalRuntime.getRuntime().getExecutorService();</span>

        // Initialize the single lock used by workers to actively yield to other
        // activities (lifeline steals / other non-GLB activities)
<span class="fc" id="L525">        workerYieldLock = new TimeoutBlocker();</span>
<span class="fc" id="L526">        workerAvailableLocks = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L527">        workerAvailableLocks.add(workerYieldLock);</span>

        // Prepare the worker Ids
<span class="fc" id="L530">        workers = new WorkerInfo[MAX_WORKERS];</span>
<span class="fc" id="L531">        idleWorkers = new ConcurrentLinkedDeque&lt;&gt;();</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        for (int i = 0; i &lt; MAX_WORKERS; i++) {</span>
<span class="fc" id="L533">            final WorkerInfo w = new WorkerInfo(i);</span>
<span class="fc" id="L534">            idleWorkers.add(w);</span>
<span class="fc" id="L535">            workers[i] = w;</span>
        }

        // Prepare the atomic array used as flag to signal to workers that the #reserve
        // needs to be fed
<span class="fc" id="L540">        feedReserveRequested = new AtomicIntegerArray(MAX_WORKERS);</span>

        // Set an initial value for the granularity
<span class="fc" id="L543">        granularity = Config.getGranularity();</span>

        // Initialize the reserve of assignments for this host
<span class="fc" id="L546">        reserve = new WorkReserve();</span>

        // Initialize the map that will contain the errors that may occur during GLB
        // operation
<span class="fc" id="L550">        operationErrors = new HashMap&lt;&gt;();</span>

<span class="fc" id="L552">        finishes = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L553">        blockers = new HashMap&lt;&gt;();</span>

        // Initialize the data structures used to keep track of the lifelines
<span class="fc" id="L556">        lifelineThieves = new ConcurrentLinkedQueue&lt;&gt;();</span>
<span class="fc" id="L557">        lifelineEstablished = new ConcurrentHashMap&lt;&gt;();</span>

        // Setup the logger instance for this local host
<span class="fc" id="L560">        logger = log;</span>
<span class="fc" id="L561">        logger.put(LOGKEY_GLB, LOG_INITIALIZED_WORKERS, Integer.toString(MAX_WORKERS));</span>
<span class="fc" id="L562">        logger.put(LOGKEY_GLB, LOG_INITIALIZED_AT_NANOTIME, Long.toString(System.nanoTime()));</span>
<span class="fc" id="L563">    }</span>

    /**
     * Attempt to spawn a worker (uncounted) with an assignment obtained from the
     * reserve. It is possible all the assignment this operation brought about were
     * already taken up by existing workers, preventing this thread from obtaining
     * work from the reserve. It is also possible that at the time this method is
     * called, there are already the maximum number of workers running, in which
     * case an additional worker is not spawned either. What is guaranteed by the
     * spawn here is that if there were no workers running and some work is
     * available, then a worker is spawned. In case workers are already running but
     * it is possible to spawn an extra one, then it is perfectly fine to spawn an
     * extra one.
     */
    private void attemptToSpawnWorker() {
<span class="fc" id="L578">        final WorkerInfo worker = idleWorkers.poll();</span>
<span class="fc bfc" id="L579" title="All 2 branches covered.">        if (worker != null) {</span>
            // In case getAssignment was not able to deliver an assignment for our worker,
            // the worker instance is placed back into #ifleWorkers as part of this method
<span class="fc" id="L582">            final Assignment forSpawn = reserve.getAssignment(worker);</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if (forSpawn != null) {</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                if (TRACE) {</span>
<span class="nc" id="L585">                    System.err.println(here() + &quot; spawned worker(&quot; + worker.id + &quot;)&quot;);</span>
                }
<span class="fc" id="L587">                uncountedAsyncAt(here(), () -&gt; worker(worker, forSpawn));</span>
            } else {
                // Work could not be taken from the reserve

                // We place the workerInfo back into the #workers collection so that it gets
                // another chance to be spawned later
                // idleWorkers.add(worker); FIXME delete this part

                // We signal all the workers that the #reserve is empty and that every worker
                // needs to place some work back into the reserve
//                reserveWasEmptied(); FIXME delete this part
            }
        }
<span class="fc" id="L600">    }</span>

    /**
     * Procedure called by the thread representing the presence of work for a given
     * operation on this host when all the local assignments have completed and it
     * established lifelines on neighbor nodes to obtain some work.
     * &lt;p&gt;
     * As under our current implementation, lifelines are established on a &quot;per
     * collection&quot; basis, it is possible that an operation which terminates does not
     * actually establish any new lifelines. This is the case if multiple operations
     * on the same collection are ongoing and a previous operation terminated
     * before, establishing the lifelines before this new operation did.
     *
     * @param c the collection on which the operation that has terminated operated
     */
    void establishingLifelineOnRemoteHost(@SuppressWarnings(&quot;rawtypes&quot;) DistributedCollection c) {
<span class="fc" id="L616">        final LifelineToken token = new LifelineToken(c, here());</span>

<span class="fc" id="L618">        final ConcurrentHashMap&lt;Place, AtomicInteger&gt; lifelineStatus = lifelineEstablished.get(c);</span>

<span class="fc bfc" id="L620" title="All 2 branches covered.">        for (final Map.Entry&lt;Place, AtomicInteger&gt; pair : lifelineStatus.entrySet()) {</span>
            // An atomic check is made to avoid establishing a lifeline redundantly
<span class="fc bfc" id="L622" title="All 2 branches covered.">            if (pair.getValue().compareAndSet(LIFELINE_NOT_ESTABLISHED, LIFELINE_ESTABLISHED)) {</span>
                // This thread set the flag to &quot;established&quot;, it can now make the assynchronous
                // call that actually establishes the lifeline on the remote host

                // asyncAt(pair.getKey(), () -&gt; {
<span class="fc" id="L627">                uncountedAsyncAt(pair.getKey(), () -&gt; {</span>
                    try {
<span class="pc bpc" id="L629" title="1 of 2 branches missed.">                        if (TRACE) {</span>
<span class="nc" id="L630">                            System.err.println(token.place + &quot; established lifeline on &quot; + here() + &quot; for collection &quot;</span>
                                    + token.collection);
                        }
<span class="fc" id="L633">                        lifelineThieves.add(token);</span>
<span class="nc" id="L634">                    } catch (final Exception e) {</span>
<span class="nc" id="L635">                        e.printStackTrace();</span>
<span class="fc" id="L636">                    }</span>
<span class="fc" id="L637">                });</span>
            }
<span class="fc" id="L639">        }</span>
<span class="fc" id="L640">    }</span>

    /**
     * Procedure called by a remote host when giving some work as part of a lifeline
     * answer.
     *
     * @param token   token containing the information about the collection and the
     *                place making the answer
     * @param stolen  collection of assignments that will now be under this host
     *                responsibility
     * @param numbers the number of assignments with work that are given for each
     *                operation that the asignments may contain
     */
    void lifelineAnswer(final LifelineToken token, final ArrayList&lt;Assignment&gt; stolen,
            @SuppressWarnings(&quot;rawtypes&quot;) final HashMap&lt;GlbOperation, Integer&gt; numbers,
            @SuppressWarnings(&quot;rawtypes&quot;) final HashMap&lt;GlbOperation, Finish&gt; finish) {
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (TRACE) {</span>
<span class="nc" id="L657">            System.err.println(here() + &quot; received &quot; + stolen.size() + &quot; assignments from &quot; + token.place);</span>
        }

        // The lifeline answer has just been received, we set the lifeline tracker back
        // to &quot;not established&quot;
<span class="fc" id="L662">        final ConcurrentHashMap&lt;Place, AtomicInteger&gt; lifelinesForCollection = lifelineEstablished</span>
<span class="fc" id="L663">                .get(token.collection);</span>
<span class="fc" id="L664">        final AtomicInteger state = lifelinesForCollection.get(token.place);</span>
<span class="fc" id="L665">        final boolean resetLifeline = state.compareAndSet(LIFELINE_ESTABLISHED, LIFELINE_NOT_ESTABLISHED);</span>
<span class="fc" id="L666">        assertTrue(resetLifeline); // Check that the previous operation worked properly</span>

        // Verification that the operations contained by the lifeline answer has been
        // initialized on this host.
        /*
         * Sometimes a lifeline answer will bring assignments that have the progress
         * tracking mechanisms for a newly avaialble operation whose #newOperation call
         * was made on the remote host but it has not been done yet on this host. In
         * this case, this preparation needs to be done before merging any assignments
         * coming from the lifeline answer
         */
<span class="fc" id="L677">        final GlbTask glbTask = reserve.allTasks.get(token.collection);</span>
<span class="fc" id="L678">        synchronized (this) {</span>
            for (@SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc bfc" id="L680" title="All 2 branches covered.">            final GlbOperation op : numbers.keySet()) {</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">                if (null == finishes.get(op)) {</span>
                    // this lifeline answer is the first activity that brings this new operation to
                    // the place.
<span class="nc" id="L684">                    prepareForNewOperation(op, finish.get(op));</span>
                }
<span class="fc" id="L686">            }</span>
<span class="fc" id="L687">        }</span>

        // Merge the assignments
<span class="fc" id="L690">        glbTask.mergeAssignments(numbers, stolen);</span>

        /*
         * I know, this is weird. But allow me to explain. This guarantees that workers
         * which may have failed to take some work from the reserve (before assignments
         * from this lifeline answer were merged into it) have had their WorkerInfo
         * instance placed back into the #idleWorkers collection. See method
         * WorkReserve#getAssignment.
         *
         * In the rare (but not impossible) case where all the workers fail to get work
         * from the reserve just before this lifeline answer merges new assignments,
         * this guarantees that the calls to #attempToSpawnWorker that are made inside
         * method #operationActivity will find these WorkerInfo instances and be able to
         * spawn them.
         */
<span class="fc" id="L705">        reserve.lock.writeLock().lock();</span>
<span class="fc" id="L706">        reserve.lock.writeLock().unlock();</span>

        // For each operation that was transmitted, place an asynchronous task that will
        // wait till operation termination
        for (@SuppressWarnings(&quot;rawtypes&quot;)
<span class="fc bfc" id="L711" title="All 2 branches covered.">        final GlbOperation op : numbers.keySet()) {</span>
<span class="fc" id="L712">            final Finish f = finishes.get(op);</span>
<span class="fc" id="L713">            reserve.tasksWithWork.put(op, glbTask);</span>
<span class="fc" id="L714">            asyncArbitraryFinish(here(), () -&gt; operationActivity(op), f);</span>
<span class="fc" id="L715">        }</span>

<span class="fc" id="L717">    }</span>

    /**
     * Registers a new operation as available to workers and starts workers if they
     * were not already launched. The thread that called this method is then blocked
     * until the computation has terminated globally/locally ?
     *
     * @param op the operation newly available to process
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    void newOperation(GlbOperation op) {
        // Prepare the data structure for tracking the state of the outgoing lifelines
        // if it was not already created. A mapping is actually created if the operation
        // given as parameter operates on a distributed collection which has not
        // previously had any operations run on it.
<span class="fc" id="L732">        lifelineEstablished.computeIfAbsent(op.collection, col -&gt; {</span>
<span class="fc" id="L733">            final ConcurrentHashMap&lt;Place, AtomicInteger&gt; map = new ConcurrentHashMap&lt;&gt;();</span>
            Lifeline l;
            try {
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">                if (op.lifelineClass == null) {</span>
<span class="fc" id="L737">                    l = LifelineFactory.newLifeline(col.placeGroup());</span>
                } else {
<span class="nc" id="L739">                    l = LifelineFactory.newLifeline(col.placeGroup(), op.lifelineClass);</span>
                }
<span class="nc" id="L741">            } catch (final Exception e) {</span>
<span class="nc" id="L742">                e.printStackTrace();</span>
<span class="nc" id="L743">                System.err.println(&quot;Faced a &quot; + e + &quot; when attempting to initialize a new lifeline strategy. Using &quot;</span>
<span class="nc" id="L744">                        + Loop.class.getName() + &quot; instead&quot;);</span>
<span class="nc" id="L745">                l = new Loop(col.placeGroup());</span>
<span class="fc" id="L746">            }</span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">            for (final Place p : l.lifeline(here())) {</span>
<span class="fc" id="L748">                map.put(p, new AtomicInteger(0));</span>
<span class="fc" id="L749">            }</span>
<span class="fc" id="L750">            return map;</span>
        });

        boolean localWorkCreated;
<span class="fc" id="L754">        synchronized (this) {</span>
            // Check for the rare case in which a lifeline answer might have done all this
            // initialization, in which case this thread is not needed and can return
            // immediately
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">            if (null != finishes.get(op)) {</span>
<span class="nc" id="L759">                return;</span>
            }

            // Prepare the GlbTask of the relevant distributed collection
<span class="fc" id="L763">            localWorkCreated = prepareForNewOperation(op, currentFinish());</span>
<span class="fc" id="L764">        }</span>

        // If there was some work created as a result, launch a worker / block until
        // completion
        // There can be cases where a local handle does not hold any element, in which
        // case we simply let this thread return.
<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (localWorkCreated) {</span>
            // Launch workers / block until local termination
<span class="fc" id="L772">            operationActivity(op);</span>
        } else {
            // Go on to work stealing directly.
<span class="fc" id="L775">            establishingLifelineOnRemoteHost(op.collection);</span>
        }
<span class="fc" id="L777">    }</span>

    /**
     * Main activity of an operation. This method is called when an operation
     * becomes available for the global load balancer. It consists of several steps:
     * &lt;ol&gt;
     * &lt;li&gt;&lt;em&gt;Initialization phase&lt;/em&gt; which prepares the GlbTask and other
     * members needed for later synchronization for this new operation
     * &lt;li&gt;&lt;em&gt;Computation phase&lt;/em&gt; during which this activity blocks on a
     * {@link java.util.concurrent.ForkJoinPool.ManagedBlocker} while workers that
     * are not bound to any activity perform the computation. When this operation
     * has been completed locally, this activity will be woken up to perform
     * work-stealing operations through its lifelines.
     * &lt;li&gt;&lt;em&gt;Lifeline phase&lt;/em&gt; in which phase this thread will asynchronously
     * signal the neighboring places that it needs work.
     * &lt;/ol&gt;
     *
     * @param op the operation which is being launched on this host
     */
    void operationActivity(@SuppressWarnings(&quot;rawtypes&quot;) GlbOperation op) {
<span class="fc" id="L797">        attemptToSpawnWorker();</span>

        // As this activity is going to block, it should unblock any potential worker
        // that yielded its execution to allow this activity to run
<span class="fc" id="L801">        workerYieldLock.unblock();</span>

        // Block until operation completes
        try {
            // Take the appropriate SemaphoreBlocker to be waken up by workers
            final OperationBlocker mb;
<span class="fc" id="L807">            synchronized (blockers) {</span>
<span class="fc" id="L808">                mb = blockers.get(op);</span>
<span class="fc" id="L809">            }</span>

<span class="fc bfc" id="L811" title="All 2 branches covered.">            if (mb.allowedToBlock()) {</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">                if (TRACE) {</span>
<span class="nc" id="L813">                    System.err.println(here() + &quot;: thread waiting on operation &quot; + op);</span>
                }
<span class="fc" id="L815">                ForkJoinPool.managedBlock(mb);</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">                if (TRACE) {</span>
<span class="nc" id="L817">                    System.out.println(here() + &quot;: resumed after waiting on &quot; + op);</span>
                }
            } else {
                // There is already another thread blocking on this semaphore.
                // This thread was a lifeline answer and can return safely
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">                if (TRACE) {</span>
<span class="nc" id="L823">                    System.err.println(here() + &quot;: thread already waiting on operation &quot; + op);</span>
                }
<span class="fc" id="L825">                return;</span>
            }
<span class="nc" id="L827">        } catch (final InterruptedException e) {</span>
<span class="nc" id="L828">            System.err.println(</span>
                    &quot;InterruptedException received in operation activity, this should not happen as the managed blocker implementation does not throw this error&quot;);
<span class="nc" id="L830">            e.printStackTrace();</span>
<span class="fc" id="L831">        }</span>

        // The operation has completed. Moving on to establishing lifelines.
<span class="fc" id="L834">        establishingLifelineOnRemoteHost(op.collection);</span>
<span class="fc" id="L835">    }</span>

    /**
     * Sub-routine which is part of {@link #newOperation(GlbOperation)} and
     * {@link #lifelineAnswer(LifelineToken, ArrayList, HashMap)}.
     *
     * @param op the new operation which is now available on the host
     * @param f  the finish which is tracking the completion of this operation
     * @return true if the initialization of the assignments on this host resulted
     *         in work being now available to workers
     */
    @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; })
    private boolean prepareForNewOperation(final GlbOperation op, Finish f) {
        // Put members needed for global termination management
        // This part is made synchronized since the underlying collections are not
        // protected against concurrent accesses.
<span class="fc" id="L851">        synchronized (blockers) {</span>
<span class="fc" id="L852">            blockers.put(op, new OperationBlocker());</span>
<span class="fc" id="L853">        }</span>
<span class="fc" id="L854">        finishes.put(op, f);</span>
        // Prepare every worker with the special initialization (if needed)
<span class="fc bfc" id="L856" title="All 2 branches covered.">        if (op.workerInit != null) {</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">            for (final WorkerInfo wi : workers) {</span>
<span class="fc" id="L858">                op.workerInit.accept(wi);</span>
            }
        }

        // Prepare the GlbTask of the relevant distributed collection
<span class="fc" id="L863">        return reserve.newOperation(op);</span>
    }

    /**
     * Helper procedure used to signal to all workers that they need to place some
     * work back into the {@link #reserve} if they can.
     * &lt;p&gt;
     * This procedure is called by whichever worker notices the fact the
     * {@link #reserve} got empty first. It may be called by multiple workers
     * concurrently without any adverse effect.
     */
    /*
     * It may be possible that if two successive workers are unable to get some work
     * from the reserve and start signaling this fact to other workers that some
     * workers may find themselves repeatedly asked to place some work in the
     * reserve despite the fact they have just done so. This could be alleviated if
     * more restrictive synchronization mechanisms were used but I don't think these
     * would actually bring about any benefit.
     */
    private void reserveWasEmptied() {
<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (int i = 0; i &lt; MAX_WORKERS; i++) {</span>
<span class="fc" id="L884">            feedReserveRequested.set(i, 1);</span>
        }
<span class="fc" id="L886">    }</span>

    /**
     * Sub-routine used to signal to the local work reserve and the local operation
     * thread that an operation has had all its local assignments completed locally.
     *
     * @param op the operation whose assignments were entirely processed
     */
    void signalLocalOperationCompletion(@SuppressWarnings(&quot;rawtypes&quot;) GlbOperation op) {
        // We signal the local reserve instance that this operation has completed
        // locally.
<span class="fc" id="L897">        reserve.tasksWithWork.remove(op);</span>

        // We unblock the operation thread that was waiting
        // This part is protected against concurrent accesses as a concurrent
        // GlbComputer#newOperation call may insert a new value into the map, causing
        // some troubles.
<span class="fc" id="L903">        synchronized (blockers) {</span>
<span class="fc" id="L904">            blockers.get(op).unblock();</span>
<span class="fc" id="L905">        }</span>
<span class="fc" id="L906">    }</span>

    /**
     * Main routine of a worker in the distributed collections library global load
     * balancer
     * &lt;p&gt;
     * In this load balancer, a worker is not bound to any single task. Instead, it
     * takes work from any available operation and continues running until it
     * completely runs out of work. Workers are spawned with an initial assignment.
     * The main steps of this procedure are:
     * &lt;ol&gt;
     * &lt;li&gt;Process a part of the work fragment the worker has, as defined by
     * {@link #granularity}
     * &lt;li&gt;Attempt to spawn a new parallel worker from the work presumably available
     * in the {@link #reserve}
     *
     * &lt;li&gt;Check for any load balancing operation is needed
     * &lt;li&gt;If other asynchronous activities are waiting, yield its execution to
     * allow them to execute NOT IMPLEMENTED YET
     * &lt;/ol&gt;
     * These steps are repeated in a loop until the Assignment held by the worker is
     * completed. When the worker exits that loop, it attempts to get a new
     * Assignment from the {@link #reserve}. If successful, repeat the procedure
     * from step 1. If unsuccessful, the worker stops.
     *
     * @param id {@link Integer} used to identify workers. The type of this
     *           parameter may be changed later to be able to attach some runtime
     *           facilities to the worker specific to some operations. For example
     *           when dealing with operation which consist in placing the results
     *           into {@link Bag}, we may want to initialize a single unique List
     *           for each worker with this list being re-used for multiple
     *           Assignments on this operation.
     * @param a  initial assignment to be processed by this worker
     */
    private void worker(WorkerInfo worker, Assignment a) {
<span class="fc" id="L941">        logger.put(LOGKEY_WORKER, LOG_WORKER_STARTED, Long.toString(System.nanoTime()));</span>

        try {
            for (;;) {
<span class="fc" id="L945">                worker.currentOperation = a.chooseOperationToProgress();</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">                while (a.process(granularity, worker, worker.currentOperation)) { // STEP 1: Work is done here</span>

                    // STEP 2: Attempt to spawn a new worker from work present in the reserve
<span class="fc" id="L949">                    attemptToSpawnWorker();</span>

                    // STEP 3: Load Balance operations
<span class="fc bfc" id="L952" title="All 2 branches covered.">                    if (feedReserveRequested.get(worker.id) == 1) { // If feeding the reserve is requested</span>
<span class="fc bfc" id="L953" title="All 2 branches covered.">                        if (a.isSplittable(granularity)) {</span>
<span class="fc" id="L954">                            a.splitIntoGlbTask();</span>
<span class="fc" id="L955">                            feedReserveRequested.set(worker.id, 0);</span>
<span class="fc" id="L956">                            worker.assignmentSplit++; // Log the action</span>
                        } else {
<span class="fc" id="L958">                            worker.assignmentUnabledToSplit++; // Log</span>
                        }
                    }

                    // STEP 4: Yield if need be
                    TimeoutBlocker l;
<span class="fc bfc" id="L964" title="All 4 branches covered.">                    if (POOL.hasQueuedSubmissions() &amp;&amp; (l = workerAvailableLocks.poll()) != null) {</span>
<span class="fc" id="L965">                        l.reset();</span>
<span class="fc" id="L966">                        logger.put(LOGKEY_WORKER, LOG_WORKER_YIELDING, Long.toString(System.nanoTime()));</span>
<span class="fc" id="L967">                        ForkJoinPool.managedBlock(l);</span>
<span class="fc" id="L968">                        logger.put(LOGKEY_WORKER, LOG_WORKER_RESUMED, Long.toString(System.nanoTime()));</span>
<span class="fc" id="L969">                        workerAvailableLocks.add(l);</span>
                    }

                    // STEP 5: Answer lifeline thieves if there are any and this host is capable of
                    // doing so
<span class="fc" id="L974">                    final LifelineToken steal = lifelineThieves.poll();</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">                    if (steal != null) {</span>
                        // Check if the target collection has some assignments left for the target
                        // collection

                        GlbTask g;
                        // FIXME when using some &quot;After&quot; dependencies, it is possible for a lifeline
                        // request to be received at a time the corresponding operation has not yet gone
                        // through method #newOperation. In this case,
                        // reserve.allTasks.get(steal.collection) will return null. We need to account
                        // for that edge case where the lifeline answer is actually the first to bring
                        // the information to this place that a new operation is available for
                        // computation.
<span class="pc bpc" id="L987" title="1 of 4 branches missed.">                        if ((g = reserve.allTasks.get(steal.collection)) != null &amp;&amp; g.answerLifeline(steal)) {</span>
<span class="fc" id="L988">                            logger.put(LOGKEY_WORKER, LOG_LIFELINE_ANSWERED, Long.toString(System.nanoTime()));</span>
                        } else {
<span class="fc" id="L990">                            logger.put(LOGKEY_WORKER, LOG_LIFELINE_NOT_ANSWERED, Long.toString(System.nanoTime()));</span>
<span class="fc" id="L991">                            lifelineThieves.add(steal);</span>
                        }
                    }
<span class="fc" id="L994">                }</span>
                // Assignment#process method returned false. This worker needs a new assignment.

                // Trying to obtain a new assignment determines if the worker continue or stop
<span class="fc bfc" id="L998" title="All 2 branches covered.">                if ((a = reserve.getAssignment(worker)) == null) {</span>
                    // The reserve returned null, this worker will stop

                    // FIXME potential problem here where the attempt at taking work from the
                    // reserve and placing the worker info back into the idleWorker collection
                    // should be done atomically to protect against concurrent #lifleineAnswer made.
                    // In the current state it is possible (though unlikely) for work to be merged
                    // after workers have failed to take some the operationActivity which attempts
                    // to spawn a worker to make this attempt BEFORE worker's info was placed back
                    // into the collection.
<span class="fc" id="L1008">                    workerYieldLock.unblock(); // As this worker quits, any waiting worker can resume</span>
//                    if (TRACE) {
//                        System.err.println(here() + &quot; worker(&quot; + worker.id + &quot;) stopped --- &quot; + idleWorkers.size()
//                                + &quot; stopped workers&quot;);
//                    }
<span class="fc" id="L1013">                    logger.put(LOGKEY_WORKER, LOG_WORKER_STOPPED, Long.toString(System.nanoTime()));</span>
<span class="fc" id="L1014">                    return;</span>
                } else {
                    // This worker was able to take an assignment from the reserve. It is not
                    // starting the for(;;) loop again.
<span class="fc" id="L1018">                    worker.tookFromReserve++;</span>
                }
            }
<span class="nc" id="L1021">        } catch (final Throwable t) {</span>
<span class="nc" id="L1022">            System.err.println(&quot;Worker number &quot; + worker.id + &quot; on &quot; + here() + &quot; sufferred a &quot; + t);</span>
<span class="nc" id="L1023">            t.printStackTrace();</span>
        }
<span class="nc" id="L1025">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>