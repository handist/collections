<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GlbOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.glb</a> &gt; <span class="el_source">GlbOperation.java</span></div><h1>GlbOperation.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.glb;

import static apgas.Constructs.*;
import static org.junit.Assert.*;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ForkJoinPool;

import apgas.MultipleException;
import apgas.Place;
import apgas.SerializableJob;
import apgas.util.GlobalID;
import handist.collections.dist.DistributedCollection;
import handist.collections.function.SerializableBiConsumer;
import handist.collections.function.SerializableConsumer;
import handist.collections.function.SerializableSupplier;

/**
 * Operation to perform on a distributed collection under the GLB. This class
 * takes four generic type parameters:
 * &lt;ul&gt;
 * &lt;li&gt;the type of the distributed collection at hand C
 * &lt;li&gt;the type of the elements contained in the collection T
 * &lt;li&gt;the type used to designate elements of the collection to relocate
 * &lt;li&gt;the type of the ditributed collection representing the result of the
 * operation
 *
 * @author Patrick Finnerty
 *
 * @param &lt;C&gt; type of the distributed collection
 * @param &lt;T&gt; type of the individual elements contained by the collection
 * @param &lt;K&gt; type used to identify individual elements in the collection
 * @param &lt;D&gt; type used to identify elements for relocation, may be identical to
 *            K
 * @param &lt;R&gt; type of the distributed collection representing the result of the
 *            operation
 */
class GlbOperation&lt;C extends DistributedCollection&lt;T, C&gt;, T, K, D, R&gt; implements Serializable {

    /**
     * Managed Blocker implementation used when waiting for the completion of an
     * operation which has already started.
     *
     * @author Patrick Finnerty
     * @see GlobalLoadBalancer#startAndWait(GlbOperation)
     */
    static class OperationCompletionManagedBlocker implements ForkJoinPool.ManagedBlocker {
        /** Semaphore instance around which this class is implemented */
        private volatile boolean releasable;

        /**
         * Constructor
         *
         * Builds a new managed blocker ready for use
         */
<span class="fc" id="L70">        public OperationCompletionManagedBlocker() {</span>
<span class="fc" id="L71">            releasable = false;</span>
<span class="fc" id="L72">        }</span>

        @Override
        public synchronized boolean block() throws InterruptedException {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">            if (!releasable) {</span>
                try {
<span class="fc" id="L78">                    this.wait();</span>
<span class="nc" id="L79">                } catch (final InterruptedException e) {</span>
                    // Ignore the exception
<span class="fc" id="L81">                }</span>
            }
<span class="fc" id="L83">            return releasable;</span>
        }

        @Override
        public boolean isReleasable() {
<span class="fc" id="L88">            return releasable;</span>
        }

        public synchronized void unblock() {
<span class="fc" id="L92">            releasable = true;</span>
<span class="fc" id="L93">            notify();</span>
<span class="fc" id="L94">        }</span>
    }

    /**
     * Enumerator used to describe the state of the current operation.
     *
     */
<span class="fc" id="L101">    enum State {</span>
        /**
         * Value used to describe an operation as &quot;staged&quot;, i.e. the operation has been
         * submitted to the GLB but the next blocking operation inside the GLB program
         * has not been reached yet
         */
<span class="fc" id="L107">        STAGED,</span>
        /**
         * Value used to describe this operation as running, i.e. either being processed
         * by workers in the GLB or waiting on some dependencies to complete to start
         * computation
         */
<span class="fc" id="L113">        RUNNING,</span>

        /**
         * Value used to describe an operation as &quot;completed&quot;, i.e. all of the
         * assignments have been processed globally.
         */
<span class="fc" id="L119">        TERMINATED</span>
    }

    /** Serial Version UID */
    private static final long serialVersionUID = -7074061733010237021L;

    /**
     * Adds a completion dependency between the instance provided as parameter and
     * this operation.
     * &lt;p&gt;
     * In case the &quot;before&quot; dependency has already terminated, a dependency/hook
     * pair is not installed as the completion dependency is already satisfied.
     * &lt;p&gt;
     * If the &quot;after&quot; operation was submitted to the GLB before a blocking
     * operation, an {@link IllegalStateException} will be thrown.
     *
     * @param before operation which needs to complete before after can start
     * @param after  operation which will only start when the &quot;before&quot; operation has
     *               completed
     * @throws IllegalStateException if the call attempted to add a dependency on an
     *                               operation which may have already started.
     */
    static void makeDependency(GlbOperation&lt;?, ?, ?, ?, ?&gt; before, GlbOperation&lt;?, ?, ?, ?, ?&gt; after) {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (after.state != State.STAGED) {</span>
<span class="nc" id="L143">            throw new IllegalStateException(</span>
                    &quot;Attempted to add a completion dependency on an operation which may have already started&quot;);
        }

<span class="fc" id="L147">        synchronized (before) {</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">            if (before.state == State.TERMINATED) {</span>
<span class="fc" id="L149">                return; // Nothing to install as the dependency is already satisfied</span>
            } else {
<span class="fc" id="L151">                synchronized (after) {</span>
<span class="fc" id="L152">                    after.dependencies.add(before); // protected against concurrent after#dependencySatisfied</span>
<span class="fc" id="L153">                }</span>
<span class="fc" id="L154">                before.addHook(() -&gt; after.dependencySatisfied(before));</span>
            }
<span class="fc" id="L156">        }</span>
<span class="fc" id="L157">    }</span>

    /**
     * Variable used to keep track of the state of this operation. It will take the
     * following values in order:
     * &lt;ol&gt;
     * &lt;li&gt;{@link #OPERATION_STAGED}
     * &lt;li&gt;{@link #OPERATION_RUNNING}
     * &lt;li&gt;{@link #OPERATION_TERMINATED}
     * &lt;/ol&gt;
     * Any access to this member needs to be done through a synchronized block.
     */
    State state;

    /** Global id for this GlbOperation */
    GlobalID id;

    /** Distributed collection on which this operation is operating */
    C collection;

    /**
     * List of GlbOperations that need to terminate before this one can start.
     * Placing dependencies in this member can be done without protection. However,
     * one a Glb computation has started, no new dependency should be added to this
     * member.
     * &lt;p&gt;
     * When an operation on which this instance depends completes, it removes itself
     * from this member as part of one of its hooks (see member {@link #hooks}). If
     * this member is made empty as a result, that hook will start this instance's
     * computation.
     */
    private final transient Queue&lt;GlbOperation&lt;?, ?, ?, ?, ?&gt;&gt; dependencies;

    /**
     * List of all the errors that were thrown during this operation's execution.
     * This member will remain null until method {@link #getErrors()} is called.
     */
<span class="fc" id="L194">    transient List&lt;Throwable&gt; errors = null;</span>

    /** Indicates if this operation is terminated */
    // private boolean finished = false;

    /**
     * Handle provided to the programmer inside a glb program to manipulate the
     * result of this operation or setup dependencies.
     */
    DistFuture&lt;R&gt; future;

    /** Jobs to do after completion */
    private transient final List&lt;SerializableJob&gt; hooks;

    /**
     * Initializer which will be called on every host if the GlbTask for the
     * operation was not previously initialized by another GlbOperation.
     */
    SerializableSupplier&lt;GlbTask&gt; initializerOfGlbTask;

    /**
     * The method to be called by workers. It expects an instance of the identifier
     * type K to perform the operation. The second argument (WorkerService) is here
     * to provide special services to the operation in case it requires them.
     */
    SerializableBiConsumer&lt;K, WorkerService&gt; operation;

    /**
     * Method to be called on every worker before this operation can start on a
     * host. May be null, in which case no particular action is needed.
     */
    SerializableConsumer&lt;WorkerService&gt; workerInit;

    /**
     * Constructor for GLB operation. The distributed collection under consideration
     * and the method to be called on it needs to be specified.
     *
     * @param c                    distributed collection on which this operation
     *                             will be applied
     * @param op                   method to call on each local host to perform the
     *                             computation
     * @param f                    object that is presented to the programmer inside
     *                             the GLB program in which the result will be
     *                             stored.
     * @param glbTaskInit          initializer of the class which will handle the
     *                             progression of this operation. It will be used if
     *                             not previously initialized for this collection
     *                             through another collection.
     * @param workerInitialization initialization to be performed on every worker in
     *                             the system before this operation starts. May be
     *                             null is not needed.
     */
    GlbOperation(C c, SerializableBiConsumer&lt;K, WorkerService&gt; op, DistFuture&lt;R&gt; f,
            SerializableSupplier&lt;GlbTask&gt; glbTaskInit, SerializableConsumer&lt;WorkerService&gt; workerInitialization) {
<span class="fc" id="L248">        this(c, op, f, glbTaskInit, workerInitialization, State.STAGED, new GlobalID());</span>
<span class="fc" id="L249">    }</span>

    /**
     * Private constructor used when the GlobalID is known.
     *
     * @param c                    the collection on which this operation operates
     * @param op                   the closure which actually performs the work
     * @param f                    the future which will handle the result of this
     *                             operation
     * @param glbTaskInit          initialization that will prepare the manager of
     *                             the assignments of the distributed collection
     * @param workerInitialization initialization that needs to be performed on
     *                             every worker prior to the
     * @param s                    state of the GlbOperation (staged, running or
     *                             terminated)
     * @param gid                  global id
     */
    private GlbOperation(C c, SerializableBiConsumer&lt;K, WorkerService&gt; op, DistFuture&lt;R&gt; f,
            SerializableSupplier&lt;GlbTask&gt; glbTaskInit, SerializableConsumer&lt;WorkerService&gt; workerInitialization,
<span class="fc" id="L268">            State s, GlobalID gid) {</span>
<span class="fc" id="L269">        collection = c;</span>
<span class="fc" id="L270">        operation = op;</span>
<span class="fc" id="L271">        future = f; // We need a 2-way link between the GlbOperation and the</span>
<span class="fc" id="L272">        future.operation = this; // DistFuture</span>
<span class="fc" id="L273">        hooks = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L274">        dependencies = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L275">        initializerOfGlbTask = glbTaskInit;</span>
<span class="fc" id="L276">        workerInit = workerInitialization;</span>
<span class="fc" id="L277">        state = s;</span>
<span class="fc" id="L278">        id = gid;</span>

<span class="fc" id="L280">        id.putHere(this);</span>
<span class="fc" id="L281">    }</span>

    /**
     * Adds a hook that will be performed upon global termination of this operation.
     *
     * @param j the job to do after this operation has completed
     */
    void addHook(SerializableJob j) {
<span class="fc" id="L289">        hooks.add(j);</span>
<span class="fc" id="L290">    }</span>

    /**
     * Starts this computation and executes the various hooks once it had completed.
     * If an exception occurs during the computation, it will be caught by this
     * method and thrown after all the hooks for this computation are given a chance
     * to be executed. If a hook throws an exception, it will be printed to
     * {@link System#err} but not thrown.
     *
     * @throws MultipleException if an exception was thrown as part of the
     *                           computation
     */
    void compute() {
        // The state &quot;running&quot; needs to be set before calling this method
<span class="fc" id="L304">        assertEquals(State.RUNNING, state);</span>
<span class="fc" id="L305">        MultipleException me = null;</span>
        try {
<span class="fc" id="L307">            collection.placeGroup().broadcastFlat(() -&gt; {</span>
                // The GLB routine for this operation is called from here
<span class="fc" id="L309">                final GlbComputer glb = GlbComputer.getComputer();</span>
<span class="fc" id="L310">                glb.newOperation(this);</span>
<span class="fc" id="L311">            });</span>
<span class="nc" id="L312">        } catch (final MultipleException e) {</span>
<span class="nc" id="L313">            me = e;</span>
<span class="fc" id="L314">        }</span>

<span class="fc" id="L316">        synchronized (this) {</span>
<span class="fc" id="L317">            state = State.TERMINATED;</span>
<span class="fc" id="L318">        }</span>
        // The operation has completed, we execute the various hooks it may have
<span class="fc bfc" id="L320" title="All 2 branches covered.">        for (final SerializableJob h : hooks) {</span>
            try {
<span class="fc" id="L322">                h.run();</span>
<span class="nc" id="L323">            } catch (final Exception e) {</span>
<span class="nc" id="L324">                System.err.println(&quot;Exception was thrown as part of operation&quot; + this);</span>
<span class="nc" id="L325">                e.printStackTrace();</span>
<span class="fc" id="L326">            }</span>
<span class="fc" id="L327">        }</span>

        // finished = true;

        // If a MultipleException was caught, throw it
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (me != null) {</span>
<span class="nc" id="L333">            throw me;</span>
        }
<span class="fc" id="L335">    }</span>

    /**
     * Method called by a GlbOperation when it has completed and needs to notify
     * this instance which is waiting for that dependency to complete. If all the
     * dependencies of this instance are satisfied as a result, launches the
     * computation of this instance.
     * &lt;p&gt;
     * This method is synchronized to prevent multiple dependencies from
     * concurrently manipulate the {@link #dependencies} collection and launching
     * this computation multiple times.
     *
     * @param dep the operation which has completed
     */
    /*
     * Correct programming of the load balancer ensures that no operation will try
     * to signal that it has completed to an operation of which it is not a
     * dependency, or signal its completion multiple times. However the current
     * implementation elegantly allows such inconsistent cases without any adverse
     * effects. Only when assertions are activated with command line option -ea
     * (enable assertions) that such a case would throw an assertion exception in
     * this method
     */
    private synchronized void dependencySatisfied(GlbOperation&lt;?, ?, ?, ?, ?&gt; dep) {
<span class="fc" id="L359">        final boolean removed = dependencies.remove(dep);</span>
<span class="fc" id="L360">        assertTrue(dep + &quot; was not a dependency of &quot; + this + &quot; attempted to unblock &quot; + this + &quot; anyway.&quot;, removed);</span>

<span class="pc bpc" id="L362" title="1 of 4 branches missed.">        if (state == State.RUNNING &amp;&amp; dependencies.isEmpty()) {</span>
<span class="fc" id="L363">            async(() -&gt; this.compute());</span>
        }
<span class="fc" id="L365">    }</span>

    /**
     * GlbOperation are considered the same if they share the same global id. Other
     * members are not checked. This could a problem if GlobalID instances were
     * re-used carelessly but should otherwise be fine. As GlbOperation's
     * constructor does not allow for an arbitrary id to be given at initialization,
     * this is unlikely to become a problem.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (o instanceof GlbOperation) {</span>
<span class="fc" id="L378">            return id.equals(((GlbOperation) o).id);</span>
        } else {
<span class="nc" id="L380">            return false;</span>
        }
    }

    /**
     * Indicates if this operation has been completed
     *
     * @return true if this operation has completed, false otherwise
     */
    public boolean finished() {
<span class="fc bfc" id="L390" title="All 2 branches covered.">        return state == State.TERMINATED;</span>
    }

    /**
     * If not previously called, gathers all the Throwables caught on the various
     * hosts and gathers them into a single list which is then returned.
     * &lt;p&gt;
     * This method should only be called AFTER this operation has completed
     * globally, i.e. if calling the {@link #finished()} method returned
     * {@code true}
     *
     * @return a list of all the throwables that were thrown during the operation
     */
    List&lt;Throwable&gt; getErrors() {
<span class="fc" id="L404">        assertEquals(State.TERMINATED, state);</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (errors == null) { // If this method was not previously called</span>
<span class="fc" id="L406">            errors = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            for (final Place p : collection.placeGroup().places()) {</span>
<span class="fc" id="L408">                final ArrayList&lt;Throwable&gt; remoteErrors = at(p, () -&gt; { // Synchronous call. Maybe we can do better?</span>
<span class="fc" id="L409">                    return GlbComputer.getComputer().operationErrors.get(this);</span>
                });
<span class="fc bfc" id="L411" title="All 2 branches covered.">                if (remoteErrors != null) {</span>
<span class="fc" id="L412">                    errors.addAll(remoteErrors);</span>
                }

<span class="fc" id="L415">            }</span>
        }

<span class="fc" id="L418">        return errors;</span>
    }

    /**
     * Indicates if this operation has uncompleted dependencies.
     *
     * @return true if other operation need to complete before this operation can
     *         start, false otherwise
     */
    public boolean hasDependencies() {
<span class="fc bfc" id="L428" title="All 2 branches covered.">        return !dependencies.isEmpty();</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L433">        return (int) id.gid();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>