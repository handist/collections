<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Reducer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.reducer</a> &gt; <span class="el_source">Reducer.java</span></div><h1>Reducer.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.reducer;

import java.io.Serializable;
import java.util.HashMap;

import apgas.util.GlobalID;
import handist.collections.dist.TeamedPlaceGroup;
import mpi.Datatype;
import mpi.MPI;
import mpi.Op;
import mpi.User_function;

/**
 * Reducer object. This object provides an abstract reduction operation on some
 * data element T. Implementations should provide the {@link #reduce(Object)},
 * {@link #merge(Reducer)} and {@link #newReducer()} methods.
 * &lt;p&gt;
 * As an example implementation, we provide the example below which performs the
 * sum over {@link Integer}s.
 *
 * &lt;pre&gt;
 * class SumReduction extends Reducer&amp;lt;SumReduction, Integer&amp;gt; {
 *     int runningSum = 0;
 *
 *     public void merge(SumReduction r) {
 *         runningSum += r.runningSum;
 *     }
 *
 *     public void reduce(Integer i) {
 *         runningSum += i;
 *     }
 *
 *     public void newReducer() {
 *         return new SumReduction();
 *     }
 * }
 * &lt;/pre&gt;
 *
 * @author Patrick Finnerty
 *
 * @param &lt;R&gt; the implementing type itself, this is used to correctly implement
 *            reflective methods (methods that act on the implementing type
 *            itself)
 * @param &lt;T&gt; the type from which data is acquired to compute the reduction
 */
<span class="fc" id="L56">public abstract class Reducer&lt;R extends Reducer&lt;R, T&gt;, T&gt; extends User_function implements Serializable {</span>

    /** Serial Version UID */
    private static final long serialVersionUID = 956660189595987110L;

    /**
     * The reduction operations which have been registered for use with the MPI
     * reduce calls. The canonical name of the class implementing the reduction
     * operation is used as key in this map. As calls to methods
     * {@link #globalReduction(TeamedPlaceGroup, GlobalID)} and
     * {@link #teamReduction(TeamedPlaceGroup)} are made, new entries are
     * initialized and added to this map to be reused when a new reduction using the
     * same Reducer implementation is made.
     */
<span class="fc" id="L70">    private static transient HashMap&lt;String, Op&gt; registeredUserOperations = new HashMap&lt;&gt;();</span>

    /**
     * This method is called by the MPI runtime to make the reduction happen between
     * objects. You do not need to override this method, and do so at your own
     * peril.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void Call(Object firstOperandArray, int firstOperandArrayOffset, Object secondOperandAndResultArray,
            int secondOperandArrayOffset, int count, Datatype datatype) {
        // The argument casts are somewhat tedious but Java.lang.ClassCastException
        // are thrown if we try to perform then in one go.
<span class="fc" id="L83">        final Object[] ov = (Object[]) secondOperandAndResultArray;</span>
<span class="fc" id="L84">        final Object[] iv = (Object[]) firstOperandArray;</span>

<span class="fc" id="L86">        for (int i = secondOperandArrayOffset,</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">                j = firstOperandArrayOffset; i &lt; count + secondOperandArrayOffset; i++, j++) {</span>
<span class="fc" id="L88">            final R result = (R) ov[i];</span>
<span class="fc" id="L89">            final R operand = (R) iv[j];</span>
<span class="fc" id="L90">            result.merge(operand);</span>
        }
<span class="fc" id="L92">    }</span>

    /**
     * Performs the global reduction of this instance. This method needs to be
     * called when the reduction operation took place over data distributed across
     * multiple hosts. In such a case, the reducer will have one instance per host
     * in which the local result if contained. This method is used to merge the
     * results of all the local reducers and make them reflect the global result of
     * the reduction.
     * &lt;p&gt;
     * An implementation does not need to override this method. However, users
     * should make sure that method {@link #merge(Reducer)} was appropriately
     * implemented. Otherwise, problems may arise.
     *
     * @param placeGroup the group of places on which &quot;local&quot; reductions have been
     *                   performed
     * @param gid        global id under which each local instance is registered
     * @throws IllegalStateException if this instance is not allowed to perform
     *                               global reductions
     */
    /*
     * This method needs improvements. More likely class Reducer needs some
     * modifications to handle global reduction operations that are not performed
     * under the GLB. Currently, the registering of a local Reducer instance needs
     * to be performed manually by the programmer, which does not satisfactorily
     * provides the global reduction features.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public void globalReduction(TeamedPlaceGroup placeGroup, GlobalID gid) {
<span class="nc bnc" id="L121" title="All 4 branches missed.">        if (placeGroup == null || gid == null) {</span>
<span class="nc" id="L122">            throw new IllegalArgumentException(&quot;Method Reducer#globalReduction does not tolerate null parameters&quot;);</span>
        }

<span class="nc" id="L125">        final int reductionRank = placeGroup.rank();</span>

<span class="nc" id="L127">        placeGroup.broadcastFlat(() -&gt; {</span>
            // Retrieve the local object through the global id
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L130">            final Reducer&lt;R, T&gt; local = (Reducer&lt;R, T&gt;) gid.getHere();</span>

            // Prepare the reduction through the MPI reduceAll call
            // 1. We need to make sure that the reducer instance was registered in the
            // operations
            Op mpiOperation;
<span class="nc" id="L136">            final String s = local.getClass().getCanonicalName();</span>
<span class="nc" id="L137">            synchronized (registeredUserOperations) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                if (!registeredUserOperations.containsKey(s)) {</span>
<span class="nc" id="L139">                    mpiOperation = new Op(local.newReducer(), true);</span>
<span class="nc" id="L140">                    registeredUserOperations.put(s, mpiOperation);</span>
                } else {
<span class="nc" id="L142">                    mpiOperation = registeredUserOperations.get(s);</span>
                }
<span class="nc" id="L144">            }</span>
            // 2. Prepare the local instances into an Object Array
<span class="nc" id="L146">            final Object[] buffer = new Object[1];</span>
<span class="nc" id="L147">            buffer[0] = local;</span>

            // 3. Make the MPI AllReduce call
<span class="nc" id="L150">            placeGroup.comm.Reduce(buffer, 0, buffer, 0, 1, MPI.OBJECT, mpiOperation, reductionRank);</span>
<span class="nc" id="L151">        });</span>
<span class="nc" id="L152">    }</span>

    /**
     * Merges the partial reduction given as parameter into this instance. This
     * method is used by the library when the reduction is being parallelized and
     * multiple instances of the implementing type obtained through method
     * {@link #newReducer()} have been used and the partial result of each of these
     * instances need to be combined into a single instance.
     *
     * @param reducer another instance of the implementing class whose partial
     *                reduction needs to be merged into this instance
     */
    public abstract void merge(R reducer);

    /**
     * Creates a new R instance and returns it. The returned element should be the
     * neutral element of the reduction operation being implemented, that is,
     * calling method {@link #merge(Reducer)} with the object returned by this
     * method without there being any call to {@link #reduce(Object)} should not
     * influence the result of the reduction, or throw any exception.
     *
     * @return a new R instance which is going to be used to parallelize the
     *         reduction
     */
    public abstract R newReducer();

    /**
     * Takes the object given as parameter and performs the reduction operation this
     * object implements.
     *
     * @param input an instance of the object on which the reduction operation is
     *              taking place
     */
    public abstract void reduce(T input);

    /**
     * This
     *
     * @param placeGroup into which this instance is participating
     */
    @SuppressWarnings({ &quot;deprecation&quot;, &quot;unchecked&quot; })
    public R teamReduction(TeamedPlaceGroup placeGroup) {
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (placeGroup == null) {</span>
<span class="nc" id="L195">            throw new IllegalStateException(&quot;This Reducer is not allowed to perform any global reduction&quot;);</span>
        }

        // 1. We need to make sure that the reducer instance was registered in the
        // operations that MPI can handle
        Op mpiOperation;
        // The getCanonicalName method returns the name of the implementing class, not
        // &quot;handist.collections.dist.Reducer&quot;.
<span class="fc" id="L203">        final String s = this.getClass().getCanonicalName();</span>
<span class="fc" id="L204">        synchronized (registeredUserOperations) {</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (!registeredUserOperations.containsKey(s)) {</span>
<span class="fc" id="L206">                mpiOperation = new Op(this.newReducer(), true);</span>
<span class="fc" id="L207">                registeredUserOperations.put(s, mpiOperation);</span>
            } else {
<span class="fc" id="L209">                mpiOperation = registeredUserOperations.get(s);</span>
            }
<span class="fc" id="L211">        }</span>
        // 2. Prepare the local instances into an Object Array
<span class="fc" id="L213">        final Object[] buffer = new Object[1];</span>
<span class="fc" id="L214">        buffer[0] = this;</span>

        // Make the MPI AllReduce call
<span class="fc" id="L217">        placeGroup.comm.Allreduce(buffer, 0, buffer, 0, 1, MPI.OBJECT, mpiOperation);</span>

<span class="fc" id="L219">        return (R) buffer[0];</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>