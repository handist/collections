<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RangedList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">RangedList.java</span></div><h1>RangedList.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;

import handist.collections.function.LongTBiConsumer;

/**
 * Abstract class describing a list defined on long indices. Entries can be
 * defined on any index contained within the {@link LongRange} used to
 * initialize the collection.
 *
 * @param &lt;T&gt; type handled by the collection
 */
<span class="fc" id="L31">public abstract class RangedList&lt;T&gt; implements Iterable&lt;T&gt; {</span>

    static class Box&lt;U&gt; {
        U val;

<span class="fc" id="L36">        Box(U val) {</span>
<span class="fc" id="L37">            this.val = val;</span>
<span class="fc" id="L38">        }</span>
    }

    public static boolean equals(RangedList&lt;?&gt; rlist1, Object o) {
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">        if (o == null) {</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">            return (rlist1 == null);</span>
        }
<span class="fc bfc" id="L45" title="All 2 branches covered.">        if (!(o instanceof RangedList)) {</span>
<span class="fc" id="L46">            return false;</span>
        }
<span class="fc" id="L48">        final RangedList&lt;?&gt; rlist2 = (RangedList&lt;?&gt;) o;</span>
        // TODO this version is too slow,
        // setupFrom will be the good candidate for fast simul scanner.
<span class="fc bfc" id="L51" title="All 2 branches covered.">        if (!rlist1.getRange().equals(rlist2.getRange())) {</span>
<span class="fc" id="L52">            return false;</span>
        }
<span class="fc bfc" id="L54" title="All 2 branches covered.">        for (final long index : rlist1.getRange()) {</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">            if (!rlist1.get(index).equals(rlist2.get(index))) {</span>
<span class="nc" id="L56">                return false;</span>
            }
<span class="fc" id="L58">        }</span>
<span class="fc" id="L59">        return true;</span>
    }

    public static int hashCode(RangedList&lt;?&gt; rlist) {
<span class="fc" id="L63">        int hashCode = 1;</span>
        // code from JavaAPI doc of List
<span class="fc bfc" id="L65" title="All 2 branches covered.">        for (final Object o : rlist) {</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">            hashCode = 31 * hashCode + (o == null ? 0 : o.hashCode());</span>
<span class="fc" id="L67">        }</span>
<span class="fc" id="L68">        return hashCode;</span>
    }

    /**
     * Returns a copy of this instance, restricted to the contents that are included
     * in the specified range.
     *
     * @param range portion of the {@link RangedList} to copy
     * @return a new RangedList which contains the entries of this instance on
     *         provided range
     */
    public abstract RangedList&lt;T&gt; cloneRange(LongRange range);

    /**
     * Indicates if this list contains the provided object. More formally if the
     * list contains at least one object {@code a} such that
     * &lt;code&gt;(a == null) ? o == null : a.equals(o);&lt;/code&gt; is true.
     *
     * @param o the object whose presence is to be checked
     * @return {@code true} if the collection contains {@code o}, {@code false}
     *         otherwise
     */
    public abstract boolean contains(Object o);

    /**
     * Checks if all the elements provided in the collection are present in this
     * instance.
     *
     * @param c collection of all the elements whose presence in the RangedList is
     *          to be checked
     * @return {@code true} if all the elements in the provided collection can be
     *         found in this instance, {@code false} otherwise
     */
    public boolean containsAll(Collection&lt;? extends T&gt; c) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">        for (final T t : c) {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">            if (!contains(t)) {</span>
<span class="fc" id="L104">                return false;</span>
            }
<span class="fc" id="L106">        }</span>
<span class="fc" id="L107">        return true;</span>
    }

    /**
     * Performs the provided action on each element contained by this instance, and
     * potentially collect/extract some information into the provided receiver.
     * &lt;p&gt;
     * The BiConsumer is applied on each element contained in the collection (first
     * parameter of the BiConsumer) with the receiver provided as second parameter
     * of this method as the second parameter of the BiConsumer. This allows you to
     * make modifications to individual elements and potentially extract some
     * information (of type U) and store it in the receiver provided as second
     * parameter.
     * &lt;p&gt;
     * If you do not need to extract any information from the elements contained in
     * this instance, you should use {@link #forEach(Consumer)} instead.
     *
     * @param &lt;U&gt;      type of the collected instances
     * @param action   action to perform on each element, potentially
     * @param receiver collector of information extracted
     */
    public final &lt;U&gt; void forEach(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, Consumer&lt;? super U&gt; receiver) {
<span class="nc" id="L129">        forEach(getRange(), action, receiver);</span>
<span class="nc" id="L130">    }</span>

    /**
     * Performs the provided action on every element in the collection
     */
    @Override
    public void forEach(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L137">        forEach(getRange(), action);</span>
<span class="fc" id="L138">    }</span>

    /**
     * Performs the provided action on elements contained by this instance, and
     * potentially collect/extract some information into the provided receiver. This
     * method has the same effect as {@link #forEach(BiConsumer, Consumer)} but its
     * application is restricted to the range specified as first parameter.
     * &lt;p&gt;
     * The BiConsumer is applied on each element contained in the collection (first
     * parameter of the BiConsumer) with the receiver provided as second parameter
     * of this method as the second parameter of the BiConsumer. This allows you to
     * make modifications to individual elements and potentially extract some
     * information (of type U) and store it in the receiver provided as second
     * parameter.
     * &lt;p&gt;
     * If you do not need to extract any information from the elements contained in
     * this instance, you should use {@link #forEach(LongRange, Consumer)} instead.
     *
     * @param &lt;U&gt;      type of the collected instances
     * @param range    range on which the action is to be applied
     * @param action   action to perform on each element, potentially
     * @param receiver collector of information extracted
     * @see #forEach(LongRange, BiConsumer, Consumer)
     */
    public final &lt;U&gt; void forEach(LongRange range, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            Consumer&lt;? super U&gt; receiver) {
<span class="fc" id="L164">        forEachImpl(range, action, receiver);</span>
<span class="fc" id="L165">    }</span>

    /**
     * Applies the specified action on the elements of this collection that are
     * present in the specified range. This method is similar to
     * {@link #forEach(Consumer)} but the application of the specified action is
     * restricted to the range specified as first parameter
     *
     * @param range  range of application of the action
     * @param action action to perform on individual elements
     */
    public final void forEach(LongRange range, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L177">        forEachImpl(range, action);</span>
<span class="fc" id="L178">    }</span>

    /**
     * Applies the given action on the index/value pairs present in the specified
     * range.
     * &lt;p&gt;
     * This method is almost identical to {@link #forEach(LongTBiConsumer)} but its
     * application is restricted to the range of indices specified as parameter.
     *
     * @param range  range of indices on which to apply the action
     * @param action action to perform taking a long and a T as parameter
     */
    public final void forEach(LongRange range, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L191">        forEachImpl(range, action);</span>
<span class="fc" id="L192">    }</span>

    /**
     * Iterates on the elements of this instance and the {@code target}
     * {@link RangedList} and applies the given function to each pair of this and
     * {@code target} element of matching indices on the specified range
     *
     * @param range  the range on which to apply the method
     * @param target other {@link RangedList} supplying the second parameter of
     *               fuction {@code func}
     * @param func   function that receives two object (type T and U) extracted from
     *               two ranged list and does not return result.
     * @param &lt;U&gt;    the type handled by the {@link RangedList} given as parameter,
     *               second input for the function
     */
    public final &lt;U&gt; void forEach(LongRange range, RangedList&lt;U&gt; target, BiConsumer&lt;T, U&gt; func) {
<span class="fc" id="L208">        rangeCheck(range);</span>
<span class="fc" id="L209">        target.rangeCheck(range);</span>
<span class="fc" id="L210">        final Iterator&lt;T&gt; iter0 = subIterator(range);</span>
<span class="fc" id="L211">        final Iterator&lt;U&gt; iter = target.subList(range).iterator();</span>
<span class="fc" id="L212">        target.subIterator(range);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        while (iter0.hasNext()) {</span>
<span class="fc" id="L214">            func.accept(iter0.next(), iter.next());</span>
        }
<span class="fc" id="L216">    }</span>

    /**
     * Performs the specified action on every index/value pair contained in this
     * collection
     *
     * @param action action to perform taking a long and a T as parameter
     */
    public final void forEach(LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L225">        forEach(getRange(), action);</span>
<span class="fc" id="L226">    }</span>

    protected &lt;U&gt; void forEachImpl(LongRange range, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            Consumer&lt;? super U&gt; receiver) {
<span class="fc" id="L230">        rangeCheck(range);</span>
<span class="fc" id="L231">        final Iterator&lt;T&gt; iter0 = subIterator(range);</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">        while (iter0.hasNext()) {</span>
<span class="fc" id="L233">            action.accept(iter0.next(), receiver);</span>
        }
<span class="fc" id="L235">    }</span>

    protected void forEachImpl(LongRange range, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L238">        rangeCheck(range);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (range.size() == 0) {</span>
<span class="fc" id="L240">            return;</span>
        }
<span class="fc" id="L242">        final Iterator&lt;T&gt; iter0 = subIterator(range);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">        while (iter0.hasNext()) {</span>
<span class="fc" id="L244">            action.accept(iter0.next());</span>
        }
<span class="fc" id="L246">    }</span>

    protected void forEachImpl(LongRange range, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L249">        rangeCheck(range);</span>
<span class="fc" id="L250">        long index = range.from;</span>
<span class="fc" id="L251">        final Iterator&lt;T&gt; iter0 = subIterator(range);</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">        while (iter0.hasNext()) {</span>
<span class="fc" id="L253">            action.accept(index++, iter0.next());</span>
        }
<span class="fc" id="L255">    }</span>

    /**
     * Returns the value associated with the provided {@code long} index.
     *
     * @param index index of the value to return.
     * @return the value associated with this index
     */
    public abstract T get(long index);

    /**
     * Obtain the {@link LongRange} on which this instance is defined.
     *
     * @return the {@link LongRange} object representing the
     */
    public abstract LongRange getRange();

    /**
     * Indicates if this RangedList is empty, i.e. if it cannot contain any entry
     * because it is defined on an empty {@link LongRange}.
     *
     * @return {@code true} is the instance is defined on an empty
     *         {@link LongRange}, {@code false} otherwise.
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L280" title="All 2 branches covered.">        return getRange().size() == 0;</span>
    }

    @Override
    public abstract Iterator&lt;T&gt; iterator();

    public abstract RangedListIterator&lt;T&gt; listIterator();

    public abstract RangedListIterator&lt;T&gt; listIterator(long from);

    /**
     * Creates a new collection from the elements contained in this instance by
     * transforming them into a new type
     *
     * @param &lt;U&gt;  type of the collection to create
     * @param func function that returns a type U from the provided T
     * @return a newly created collection which contains the mapping of the elements
     *         contained by this instance to type U
     */
    public &lt;U&gt; RangedList&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; func) {
<span class="fc" id="L300">        final Chunk&lt;U&gt; result = new Chunk&lt;&gt;(this.getRange());</span>
<span class="fc" id="L301">        result.setupFrom(this, func);</span>
<span class="fc" id="L302">        return result;</span>
    }

    /**
     * Creates a new collection from the elements contained in this instance on the
     * specified range by transforming them into a different type
     *
     * @param &lt;U&gt;   type of the collection to create
     * @param range the range on which to apply the method
     * @param func  function that returns a type U from the provided T
     * @return a newly created collection which contains the mapping of the elements
     *         contained by this instance (restricted to the specified range) to
     *         type U
     */
    public &lt;U&gt; RangedList&lt;U&gt; map(LongRange range, Function&lt;? super T, ? extends U&gt; func) {
<span class="nc" id="L317">        return this.subList(range.from, range.to).map(func);</span>
    }

    public final &lt;S, U&gt; RangedList&lt;U&gt; map(LongRange range, RangedList&lt;S&gt; target, BiFunction&lt;T, S, U&gt; func) {
<span class="fc" id="L321">        final Chunk&lt;U&gt; result = new Chunk&lt;&gt;(range);</span>
<span class="fc" id="L322">        rangeCheck(range);</span>
<span class="fc" id="L323">        target.rangeCheck(range);</span>
<span class="fc" id="L324">        result.setupFrom(range, this, target, func);</span>
<span class="fc" id="L325">        return result;</span>
    }

    /**
     * Checks if the provided {@code long index} is included in the range this
     * instance is defined on, i.e. if method {@link #get(long)}, or
     * {@link #set(long,Object)} can be safely called with the provided parameter.
     *
     * @param target the index to check
     * @throws IndexOutOfBoundsException if the provided index is outside the range
     *                                   this instance is defined on
     */
    public void rangeCheck(long target) {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (!this.getRange().contains(target)) {</span>
<span class="fc" id="L339">            throw new IndexOutOfBoundsException(</span>
<span class="fc" id="L340">                    &quot;[RangedList] range mismatch: &quot; + this.getRange() + &quot; does not include &quot; + target);</span>
        }
<span class="fc" id="L342">    }</span>

    /**
     * Checks if the provided {@link LongRange} is included in the range of this
     * instance.
     *
     * @param target LongRange whose inclusion in this instance is to be checked
     * @throws ArrayIndexOutOfBoundsException if the provided {@link LongRange} is
     *                                        not included in this instance
     */
    public void rangeCheck(LongRange target) {
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (!this.getRange().contains(target)) {</span>
<span class="fc" id="L354">            throw new ArrayIndexOutOfBoundsException(</span>
<span class="fc" id="L355">                    &quot;[RangedList] range mismatch:&quot; + this.getRange() + &quot; must include &quot; + target);</span>
        }
<span class="fc" id="L357">    }</span>

    public T reduce(BiFunction&lt;T, T, T&gt; reduce) {
<span class="fc" id="L360">        final Box&lt;T&gt; box = new Box&lt;&gt;(null);</span>
<span class="fc" id="L361">        forEach((T t) -&gt; {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (box.val == null) {</span>
<span class="fc" id="L363">                box.val = t;</span>
            } else {
<span class="fc" id="L365">                box.val = reduce.apply(box.val, t);</span>
            }
<span class="fc" id="L367">        });</span>
<span class="fc" id="L368">        return box.val;</span>
    }

    public &lt;U&gt; U reduce(BiFunction&lt;U, T, U&gt; reduce, U zero) {
<span class="fc" id="L372">        final Box&lt;U&gt; box = new Box&lt;&gt;(zero);</span>
<span class="fc" id="L373">        box.val = zero;</span>
<span class="fc" id="L374">        forEach((T t) -&gt; {</span>
<span class="fc" id="L375">            box.val = reduce.apply(box.val, t);</span>
<span class="fc" id="L376">        });</span>
<span class="fc" id="L377">        return box.val;</span>
    }

    public &lt;U, S&gt; U reduce(RangedList&lt;S&gt; source2, BiFunction&lt;T, S, U&gt; map, U zero, BiFunction&lt;U, U, U&gt; reduce) {
<span class="fc" id="L381">        final Box&lt;U&gt; box = new Box&lt;&gt;(zero);</span>
<span class="fc" id="L382">        box.val = zero;</span>
<span class="fc" id="L383">        forEach(getRange(), source2, (T t, S s) -&gt; {</span>
<span class="fc" id="L384">            box.val = reduce.apply(box.val, map.apply(t, s));</span>
<span class="fc" id="L385">        });</span>
<span class="fc" id="L386">        return box.val;</span>
    }

    /**
     * Sets the provided value at the specified index
     *
     * @param index index at which the value should be stored
     * @param value value to store at the specified index
     * @return previous value that was stored at this index, {@code null} if there
     *         was no previous value or the previous value stored was {@code null}
     */
    public abstract T set(long index, T value);

    /**
     * Initializes the values in the {code range} of this instance by applying the
     * provided function on the elements contained in {@code source}
     *
     * @param &lt;S&gt;    the type handled by the {@link RangedList} given as parameter,
     *               input for the function
     * @param range  the range where initialization are applied
     * @param source {@link RangedList} instance from which entries for this
     *               instance will be extracted
     * @param func   function that takes an object of type S as parameter and
     *               returns a type T
     */
    public final &lt;S&gt; void setupFrom(LongRange range, RangedList&lt;S&gt; source, Function&lt;? super S, ? extends T&gt; func) {
<span class="fc" id="L412">        setupFromImpl(range, source, func);</span>
<span class="fc" id="L413">    }</span>

    /**
     * Initializes the values in the {code range} of this instance by applying the
     * provided function on the elements contained in {@code source1} and
     * {@code source2}
     *
     * @param &lt;S&gt;     the first type handled by the {@link RangedList} given as
     *                parameter, input for the function
     * @param &lt;U&gt;     the second type handled by the {@link RangedList} given as
     *                parameter, input for the function
     * @param range   the range where initialization are applied
     * @param source1 the first {@link RangedList} instance from which entries for
     *                this instance will be extracted
     * @param source2 the second {@link RangedList} instance from which entries for
     *                this instance will be extracted
     * @param func    function that takes two objects of type S and U as parameter
     *                and returns a type T
     */

    public final &lt;S, U&gt; void setupFrom(LongRange range, RangedList&lt;S&gt; source1, RangedList&lt;U&gt; source2,
            BiFunction&lt;S, U, T&gt; func) {
<span class="fc" id="L435">        setupFromImpl(range, source1, source2, func);</span>
<span class="fc" id="L436">    }</span>

    /**
     * Initializes the values in this instance by applying the provided function on
     * the elements contained in {@code source}
     *
     * @param &lt;S&gt;    the type handled by the {@link RangedList} given as parameter,
     *               input for the function
     * @param source {@link RangedList} instance from which entried for this
     *               instance will be extracted
     * @param func   function that takes an object of type S as parameter and
     *               returns a type T
     */
    public &lt;S&gt; void setupFrom(RangedList&lt;S&gt; source, Function&lt;? super S, ? extends T&gt; func) {
<span class="fc" id="L450">        setupFrom(source.getRange(), source, func);</span>
<span class="fc" id="L451">    }</span>

    protected &lt;S&gt; void setupFromImpl(LongRange range, RangedList&lt;S&gt; source, Function&lt;? super S, ? extends T&gt; func) {
<span class="fc" id="L454">        rangeCheck(range);</span>
<span class="fc" id="L455">        source.rangeCheck(range);</span>
<span class="fc" id="L456">        final RangedListIterator&lt;T&gt; iter0 = subListIterator(range);</span>
<span class="fc" id="L457">        final Iterator&lt;S&gt; iter = source.subIterator(range);</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">        while (iter0.hasNext()) {</span>
<span class="fc" id="L459">            iter0.next();</span>
<span class="fc" id="L460">            iter0.set(func.apply(iter.next()));</span>
        }
        ;
<span class="fc" id="L463">    }</span>

    protected &lt;S, U&gt; void setupFromImpl(LongRange range, RangedList&lt;S&gt; source1, RangedList&lt;U&gt; source2,
            BiFunction&lt;S, U, T&gt; func) {
<span class="fc" id="L467">        rangeCheck(range);</span>
<span class="fc" id="L468">        source1.rangeCheck(range);</span>
<span class="fc" id="L469">        source2.rangeCheck(range);</span>
<span class="fc" id="L470">        final RangedListIterator&lt;T&gt; iter0 = subListIterator(range);</span>
<span class="fc" id="L471">        final Iterator&lt;S&gt; iter1 = source1.subIterator(range);</span>
<span class="fc" id="L472">        final Iterator&lt;U&gt; iter2 = source2.subIterator(range);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">        while (iter0.hasNext()) {</span>
<span class="fc" id="L474">            iter0.next();</span>
<span class="fc" id="L475">            iter0.set(func.apply(iter1.next(), iter2.next()));</span>
        }
<span class="fc" id="L477">    }</span>

    /**
     * Returns the number of entries in this collection as a {@code long}
     *
     * @return size of the collection
     */
    public long size() {
<span class="fc" id="L485">        final LongRange r = getRange();</span>
<span class="fc" id="L486">        return r.to - r.from;</span>
    }

    /**
     * Separates this instance into multiple {@link RangedList}s using the points
     * given as parameter.
     * &lt;p&gt;
     * For instance, if this instance is defined on a range [a,b) and points l, m,
     * and n are given as parameter, this method will return 4 {@link RangedList}
     * defined on [a,l), [l,m), [m,n), and [n,b).
     * &lt;p&gt;
     * The user will be careful to sort the points given as parameter in ascending
     * order. Exceptions during the creation of {@link RangedList} will be thrown
     * otherwise.
     *
     * @param splitPoints the points at which this instance needs to be cut
     * @return this instance entries split into several {@link RangedList}
     */
    public LinkedList&lt;RangedList&lt;T&gt;&gt; splitRange(long... splitPoints) {
<span class="fc" id="L505">        final LinkedList&lt;RangedList&lt;T&gt;&gt; toReturn = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L506">        final LongRange range = getRange();</span>
<span class="fc" id="L507">        long start = range.from;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        for (final long split : splitPoints) {</span>
<span class="fc" id="L509">            toReturn.add(new RangedListView&lt;&gt;(this, new LongRange(start, split)));</span>
<span class="fc" id="L510">            start = split;</span>
        }
<span class="fc" id="L512">        toReturn.add(new RangedListView&lt;&gt;(this, new LongRange(start, range.to)));</span>
<span class="fc" id="L513">        return toReturn;</span>
    }

    protected abstract Iterator&lt;T&gt; subIterator(LongRange range);

    /**
     * Provides a RangedList of the elements contained in this instance from index
     * &lt;em&gt;begin&lt;/em&gt; to index &lt;em&gt;end&lt;/em&gt;.
     * &lt;p&gt;
     * If the provided range exceeds the indices contained in this instance (i.e. if
     * &lt;em&gt;begin&lt;/em&gt; is lower than the lowest index contained in this instance, or
     * if &lt;em&gt;end&lt;/em&gt; is higher than the highest index contained in this instance)
     * the method will return the elements it contains that fit within the provided
     * range.
     *
     * @param begin starting index of the desired sub-list
     * @param end   last index of the desired sub-list (exlusive)
     * @return a ranged list of the elements contained in this {@link RangedList}
     *         that fit in the provided range.
     * @throws IllegalArgumentException  if &lt;em&gt;begin&lt;/em&gt; is superior to
     *                                   &lt;em&gt;end&lt;/em&gt;.
     * @throws IndexOutOfBoundsException if the provided range has no intersection
     *                                   with the range of this instance.
     */
    public RangedList&lt;T&gt; subList(long begin, long end) {
<span class="fc bfc" id="L538" title="All 2 branches covered.">        if (begin &gt; end) {</span>
<span class="fc" id="L539">            throw new IllegalArgumentException(&quot;Cannot obtain a sublist from &quot; + begin + &quot; to &quot; + end);</span>
        }
<span class="fc" id="L541">        final long from = Math.max(begin, getRange().from);</span>
<span class="fc" id="L542">        final long to = Math.min(end, getRange().to);</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (from &gt; to) {</span>
<span class="fc" id="L544">            throw new IndexOutOfBoundsException(&quot;[RangedList] no intersection with [&quot; + begin + &quot;,&quot; + end + &quot;)&quot;);</span>
        }
<span class="fc" id="L546">        final LongRange newRange = new LongRange(from, to);</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (newRange.equals(getRange())) {</span>
<span class="fc" id="L548">            return this;</span>
        }
<span class="fc" id="L550">        return new RangedListView&lt;&gt;(this, newRange);</span>
    }

    /**
     * Provides a RangedList of the elements contained in this instance on the
     * specified {@link LongRange}.
     * &lt;p&gt;
     * If the provided range exceeds the indices contained in this instance (i.e. if
     * lower bound of the {@link LongRange} is lower than the lowest index contained
     * in this instance, or if the upper bound of the provided {@link LongRange} is
     * higher than the highest index contained in this instance) the method will
     * return the elements it contains that fit within the provided range.
     *
     * @param range range of indices of which a copy is desired
     * @return a ranged list of the elements contained in this {@link RangedList}
     *         that fit in the provided range.
     * @throws IllegalArgumentException if &lt;em&gt;begin&lt;/em&gt; is superior to
     *                                  &lt;em&gt;end&lt;/em&gt;.
     */
    public RangedList&lt;T&gt; subList(LongRange range) {
<span class="fc" id="L570">        return subList(range.from, range.to);</span>
    }

    protected abstract RangedListIterator&lt;T&gt; subListIterator(LongRange range);

    protected abstract RangedListIterator&lt;T&gt; subListIterator(LongRange range, long from);

    /**
     * Returns the elements contained in this instance in an array
     *
     * @return array containing the objects contained in this instance
     */
    public abstract Object[] toArray();

    /**
     * Returns the elements contained in this instance in an array
     *
     * @param r the range of elements to take
     * @return an object array containing the elements of this instance within the
     *         specified range
     */
    public abstract Object[] toArray(LongRange r);

    /**
     * Creates a Chunk containing all the elements of this instance
     *
     * @return a new {@link Chunk} with the same range as this instance containing
     *         all the elements of this instance
     */
    public Chunk&lt;T&gt; toChunk() {
<span class="fc" id="L600">        return toChunk(getRange());</span>
    }

    /**
     * Creates a Chunk containing the elements of this instance included in the
     * specified range
     *
     * @param r the range of elements to create a {@link Chunk} with.
     * @return a new {@link Chunk} with the specified range containing the elements
     *         of this instance
     */
    public abstract Chunk&lt;T&gt; toChunk(LongRange r);

    /**
     * Returns the elements contained in this instance in a {@link List}. Note that
     * the indices of the returned list do not reflect the long indices used in this
     * implementation.
     *
     * @return a list containing the elements of this instance within the specified
     *         range
     */
    public List&lt;T&gt; toList() {
<span class="fc" id="L622">        return toList(getRange());</span>
    }

    /**
     * Returns the elements contained in this instance within the specified range in
     * a {@link List}. Note that the indices of the returned list do not reflect the
     * long indices used in this implementation.
     *
     * @param r the range of indices of this instance to include in the returned
     *          list
     * @return a list containing the elements of this instance within the specified
     *         range
     */
    public abstract List&lt;T&gt; toList(LongRange r);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>