<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ChunkedList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">ChunkedList.java</span></div><h1>ChunkedList.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import static apgas.Constructs.*;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NavigableSet;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

import handist.collections.FutureN.ReturnGivenResult;
import handist.collections.accumulator.Accumulator;
import handist.collections.accumulator.Accumulator.ThreadLocalAccumulator;
import handist.collections.function.LongTBiConsumer;
import handist.collections.function.LongTTriConsumer;
import handist.collections.reducer.BoolReducer;
import handist.collections.reducer.DoubleReducer;
import handist.collections.reducer.FloatReducer;
import handist.collections.reducer.IntReducer;
import handist.collections.reducer.LongReducer;
import handist.collections.reducer.Reducer;
import handist.collections.reducer.ShortReducer;

/**
 * Large collection containing multiple {@link Chunk}s. This overcomes the
 * storing limitation of individual {@link Chunk}s. A {@link ChunkedList} can
 * hold multiple {@link Chunk}s, adjacent or not. However, it cannot contain
 * Chunks whose bounds overlap. This is necessary to avoid having potentially
 * multiple values associated with a single ({@code long}) index.
 *
 * @param &lt;T&gt; The type of the elements handled by the {@link Chunk}s the
 *            {@link ChunkedList} contains, and by extension, the type of
 *            elements handled by the {@link ChunkedList}
 */
<span class="fc bfc" id="L60" title="All 2 branches covered.">public class ChunkedList&lt;T&gt; implements Iterable&lt;T&gt;, Serializable {</span>

    /**
     * Iterator class for {@link ChunkedList}. Iterates on two levels between the
     * chunks contained in the {@link ChunkedList} and the elements contained in the
     * {@link Chunk}s.
     *
     * @param &lt;S&gt; type of the elements handled by the {@link ChunkedList}
     */
    private static class It&lt;S&gt; implements Iterator&lt;S&gt; {
        public ConcurrentSkipListMap&lt;LongRange, RangedList&lt;S&gt;&gt; chunks;
        private Iterator&lt;S&gt; cIter;
        private LongRange range;

<span class="fc" id="L74">        public It(ConcurrentSkipListMap&lt;LongRange, RangedList&lt;S&gt;&gt; chunks) {</span>
<span class="fc" id="L75">            this.chunks = chunks;</span>
<span class="fc" id="L76">            final Map.Entry&lt;LongRange, RangedList&lt;S&gt;&gt; firstEntry = chunks.firstEntry();</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            if (firstEntry != null) {</span>
<span class="fc" id="L78">                final RangedList&lt;S&gt; firstChunk = firstEntry.getValue();</span>
<span class="fc" id="L79">                range = firstChunk.getRange();</span>
<span class="fc" id="L80">                cIter = firstChunk.iterator();</span>
<span class="fc" id="L81">            } else {</span>
<span class="fc" id="L82">                range = null;</span>
<span class="fc" id="L83">                cIter = null;</span>
            }
<span class="fc" id="L85">        }</span>

        @Override
        public boolean hasNext() {
<span class="fc bfc" id="L89" title="All 2 branches covered.">            if (range == null) {</span>
<span class="fc" id="L90">                return false;</span>
            }
<span class="fc bfc" id="L92" title="All 2 branches covered.">            if (cIter.hasNext()) {</span>
<span class="fc" id="L93">                return true;</span>
            }
<span class="fc" id="L95">            final Map.Entry&lt;LongRange, RangedList&lt;S&gt;&gt; nextEntry = chunks.higherEntry(range);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">            if (nextEntry == null) {</span>
<span class="fc" id="L97">                range = null;</span>
<span class="fc" id="L98">                cIter = null;</span>
<span class="fc" id="L99">                return false;</span>
            }
<span class="fc" id="L101">            range = nextEntry.getKey();</span>
<span class="fc" id="L102">            cIter = nextEntry.getValue().iterator();</span>
<span class="fc" id="L103">            return cIter.hasNext();</span>
        }

        @Override
        public S next() {
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (hasNext()) {</span>
<span class="fc" id="L109">                return cIter.next();</span>
            }
<span class="fc" id="L111">            throw new IndexOutOfBoundsException();</span>
        }

    }

    /**
     * Class which defines the order in which Chunks are stored in the underlying
     * {@link ConcurrentSkipListMap}. Contrary to the default ordering of class
     * {@link LongRange}, entries in this member will be sorted by increasing
     * {@link LongRange#from} and &lt;em&gt;decreasing&lt;/em&gt; {@link LongRange#to}. This
     * simplifies a number of retrieval operations proposed by class
     * {@link ChunkedList} as retrieving a target range
     *
     * @author Patrick Finnerty
     *
     */
<span class="fc" id="L127">    public static final class LongRangeOrdering implements Comparator&lt;LongRange&gt;, Serializable {</span>
        /** Serial Version UID */
        private static final long serialVersionUID = 8092975204762862773L;

        @Override
        public int compare(LongRange arg0, LongRange arg1) {
<span class="fc" id="L133">            final int fromComparison = (int) (arg0.from - arg1.from);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            return (int) ((fromComparison) == 0 ? arg1.to - arg0.to : fromComparison);</span>
        }

    }

    public static class UnmodifiableView&lt;S&gt; extends ChunkedList&lt;S&gt; {
        /**
         *
         */
        private static final long serialVersionUID = 7195102432562086394L;
        ChunkedList&lt;S&gt; base;

<span class="nc" id="L146">        public UnmodifiableView(ChunkedList&lt;S&gt; base) {</span>
<span class="nc" id="L147">            this.base = base;</span>
<span class="nc" id="L148">        }</span>

        @Override
        public void add(RangedList&lt;S&gt; c) {
<span class="nc" id="L152">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support add()&quot;);</span>
        }

        @Override
        public void add_unchecked(RangedList&lt;S&gt; c) {
<span class="nc" id="L157">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support add_unchecked()&quot;);</span>
        }

        @Override
        public &lt;U&gt; void asyncForEach(BiConsumer&lt;? super S, Consumer&lt;? super U&gt;&gt; action,
                ParallelReceiver&lt;? super U&gt; toStore) {
<span class="nc" id="L163">            base.asyncForEach(action, toStore);</span>
<span class="nc" id="L164">        }</span>

        @Override
        public void asyncForEach(Consumer&lt;? super S&gt; action) {
<span class="nc" id="L168">            base.asyncForEach(action);</span>
<span class="nc" id="L169">        }</span>

        @Override
        public &lt;U&gt; Future&lt;ChunkedList&lt;S&gt;&gt; asyncForEach(ExecutorService pool, int nthreads,
                BiConsumer&lt;? super S, Consumer&lt;? super U&gt;&gt; action, ParallelReceiver&lt;? super U&gt; toStore) {
<span class="nc" id="L174">            return base.asyncForEach(pool, nthreads, action, toStore);</span>
        }

        @Override
        @Deprecated
        public Future&lt;ChunkedList&lt;S&gt;&gt; asyncForEach(ExecutorService pool, int nthreads, Consumer&lt;? super S&gt; action) {
<span class="nc" id="L180">            return base.asyncForEach(pool, nthreads, action);</span>
        }

        @Override
        @Deprecated
        public Future&lt;ChunkedList&lt;S&gt;&gt; asyncForEach(ExecutorService pool, int nthreads,
                LongTBiConsumer&lt;? super S&gt; action) {
<span class="nc" id="L187">            return base.asyncForEach(pool, nthreads, action);</span>
        }

        @Override
        public void asyncForEach(LongTBiConsumer&lt;? super S&gt; action) {
<span class="nc" id="L192">            base.asyncForEach(action);</span>
<span class="nc" id="L193">        }</span>

        @Override
        public &lt;S1&gt; Future&lt;ChunkedList&lt;S1&gt;&gt; asyncMap(ExecutorService pool, int nthreads,
                Function&lt;? super S, ? extends S1&gt; func) {
<span class="nc" id="L198">            return base.asyncMap(pool, nthreads, func);</span>
        }

        @Override
        public boolean attemptSplitChunkAtSinglePoint(LongRange lr) {
<span class="nc" id="L203">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support split operations.&quot;);</span>
        }

        @Override
        public boolean attemptSplitChunkAtTwoPoints(LongRange lr) {
<span class="nc" id="L208">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support split operations.&quot;);</span>
        }

        @Override
        public void clear() {
<span class="nc" id="L213">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support clear().&quot;);</span>
        }

        @Override
        public Object clone() {
<span class="nc" id="L218">            return base.clone();</span>
        }

        @Override
        public boolean contains(Object o) {
<span class="nc" id="L223">            return base.contains(o);</span>
        }

        @Override
        public boolean containsAll(Collection&lt;?&gt; c) {
<span class="nc" id="L228">            return base.containsAll(c);</span>
        }

        @Override
        public boolean containsChunk(RangedList&lt;S&gt; c) {
<span class="nc" id="L233">            return base.containsChunk(c);</span>
        }

        @Override
        public boolean containsIndex(long i) {
<span class="nc" id="L238">            return base.containsIndex(i);</span>
        }

        @Override
        public boolean containsRange(LongRange range) {
<span class="nc" id="L243">            return base.containsRange(range);</span>
        }

        @Override
        public boolean equals(Object o) {
<span class="nc" id="L248">            return base.equals(o);</span>
        }

        @Override
        public List&lt;RangedList&lt;S&gt;&gt; filterChunk(Predicate&lt;RangedList&lt;? super S&gt;&gt; filter) {
<span class="nc" id="L253">            return base.filterChunk(filter);</span>
        }

        @Override
        public &lt;U&gt; void forEach(BiConsumer&lt;? super S, Consumer&lt;? super U&gt;&gt; action,
                ParallelReceiver&lt;? super U&gt; toStore) {
<span class="nc" id="L259">            base.forEach(action, toStore);</span>
<span class="nc" id="L260">        }</span>

        @Override
        public void forEach(Consumer&lt;? super S&gt; action) {
<span class="nc" id="L264">            base.forEach(action);</span>
<span class="nc" id="L265">        }</span>

        @Override
        @Deprecated
        public &lt;U&gt; void forEach(ExecutorService pool, int nthreads, BiConsumer&lt;? super S, Consumer&lt;? super U&gt;&gt; action,
                ParallelReceiver&lt;U&gt; toStore) {
<span class="nc" id="L271">            base.forEach(pool, nthreads, action, toStore);</span>
<span class="nc" id="L272">        }</span>

        @Override
        @Deprecated
        public void forEach(ExecutorService pool, int nthreads, Consumer&lt;? super S&gt; action) {
<span class="nc" id="L277">            base.forEach(pool, nthreads, action);</span>
<span class="nc" id="L278">        }</span>

        @Override
        @Deprecated
        public void forEach(ExecutorService pool, int nthreads, LongTBiConsumer&lt;? super S&gt; action) {
<span class="nc" id="L283">            base.forEach(pool, nthreads, action);</span>
<span class="nc" id="L284">        }</span>

        @Override
        public void forEach(LongRange range, Consumer&lt;? super S&gt; action) {
<span class="nc" id="L288">            base.forEach(range, action);</span>
<span class="nc" id="L289">        }</span>

        @Override
        public void forEach(LongRange range, LongTBiConsumer&lt;? super S&gt; action) {
<span class="nc" id="L293">            base.forEach(range, action);</span>
<span class="nc" id="L294">        }</span>

        @Override
        public void forEach(LongTBiConsumer&lt;? super S&gt; action) {
<span class="nc" id="L298">            base.forEach(action);</span>
<span class="nc" id="L299">        }</span>

        @Override
        public void forEachChunk(Consumer&lt;RangedList&lt;S&gt;&gt; op) {
<span class="nc" id="L303">            base.forEachChunk(op);</span>
<span class="nc" id="L304">        }</span>

        @Override
        public void forEachChunk(LongRange range, Consumer&lt;RangedList&lt;S&gt;&gt; op) {
<span class="nc" id="L308">            base.forEachChunk(range, op);</span>
<span class="nc" id="L309">        }</span>

        @Override
        public S get(long i) {
<span class="nc" id="L313">            return base.get(i);</span>
        }

        @Override
        public RangedList&lt;S&gt; getChunk(LongRange lr) {
<span class="nc" id="L318">            return base.getChunk(lr);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L323">            return base.hashCode();</span>
        }

        @Override
        public boolean isEmpty() {
<span class="nc" id="L328">            return base.isEmpty();</span>
        }

        @Override
        public Iterator&lt;S&gt; iterator() {
<span class="nc" id="L333">            return base.iterator();</span>
        }

        @Override
        public &lt;S1&gt; ChunkedList&lt;S1&gt; map(ExecutorService pool, int nthreads, Function&lt;? super S, ? extends S1&gt; func) {
<span class="nc" id="L338">            return base.map(pool, nthreads, func);</span>
        }

        @Override
        public &lt;S1&gt; ChunkedList&lt;S1&gt; map(Function&lt;? super S, ? extends S1&gt; func) {
<span class="nc" id="L343">            return base.map(func);</span>
        }

        @Override
        public int numChunks() {
<span class="nc" id="L348">            return base.numChunks();</span>
        }

        @Override
        public &lt;U&gt; void parallelForEach(BiConsumer&lt;? super S, Consumer&lt;? super U&gt;&gt; action,
                ParallelReceiver&lt;? super U&gt; toStore) {
<span class="nc" id="L354">            base.parallelForEach(action, toStore);</span>
<span class="nc" id="L355">        }</span>

        @Override
        public void parallelForEach(Consumer&lt;? super S&gt; action) {
<span class="nc" id="L359">            base.parallelForEach(action);</span>
<span class="nc" id="L360">        }</span>

        @Override
        public void parallelForEach(LongTBiConsumer&lt;? super S&gt; action) {
<span class="nc" id="L364">            base.parallelForEach(action);</span>
<span class="nc" id="L365">        }</span>

        @Override
        public boolean parallelReduce(BoolReducer.Op op, Function&lt;S, Boolean&gt; extractFunc) {
<span class="nc" id="L369">            return base.parallelReduce(op, extractFunc);</span>
        }

        @Override
        public double parallelReduce(DoubleReducer.Op op, Function&lt;S, Double&gt; extractFunc) {
<span class="nc" id="L374">            return base.parallelReduce(op, extractFunc);</span>
        }

        @Override
        public float parallelReduce(FloatReducer.Op op, Function&lt;S, Float&gt; extractFunc) {
<span class="nc" id="L379">            return base.parallelReduce(op, extractFunc);</span>
        }

        @Override
        public boolean parallelReduce(int parallelism, BoolReducer.Op op, Function&lt;S, Boolean&gt; extractFunc) {
<span class="nc" id="L384">            return base.parallelReduce(parallelism, op, extractFunc);</span>
        }

        @Override
        public double parallelReduce(int parallelism, DoubleReducer.Op op, Function&lt;S, Double&gt; extractFunc) {
<span class="nc" id="L389">            return base.parallelReduce(parallelism, op, extractFunc);</span>
        }

        @Override
        public float parallelReduce(int parallelism, FloatReducer.Op op, Function&lt;S, Float&gt; extractFunc) {
<span class="nc" id="L394">            return base.parallelReduce(parallelism, op, extractFunc);</span>
        }

        @Override
        public int parallelReduce(int parallelism, IntReducer.Op op, Function&lt;S, Integer&gt; extractFunc) {
<span class="nc" id="L399">            return base.parallelReduce(parallelism, op, extractFunc);</span>
        }

        @Override
        public long parallelReduce(int parallelism, LongReducer.Op op, Function&lt;S, Long&gt; extractFunc) {
<span class="nc" id="L404">            return base.parallelReduce(parallelism, op, extractFunc);</span>
        }

        @Override
        public &lt;R extends Reducer&lt;R, S&gt;&gt; R parallelReduce(int parallelism, R reducer) {
<span class="nc" id="L409">            return base.parallelReduce(parallelism, reducer);</span>
        }

        @Override
        public short parallelReduce(int parallelism, ShortReducer.Op op, Function&lt;S, Short&gt; extractFunc) {
<span class="nc" id="L414">            return base.parallelReduce(parallelism, op, extractFunc);</span>
        }

        @Override
        public int parallelReduce(IntReducer.Op op, Function&lt;S, Integer&gt; extractFunc) {
<span class="nc" id="L419">            return base.parallelReduce(op, extractFunc);</span>
        }

        @Override
        public long parallelReduce(LongReducer.Op op, Function&lt;S, Long&gt; extractFunc) {
<span class="nc" id="L424">            return base.parallelReduce(op, extractFunc);</span>
        }

        @Override
        public &lt;R extends Reducer&lt;R, S&gt;&gt; R parallelReduce(R reducer) {
<span class="nc" id="L429">            return base.parallelReduce(reducer);</span>
        }

        @Override
        public short parallelReduce(ShortReducer.Op op, Function&lt;S, Short&gt; extractFunc) {
<span class="nc" id="L434">            return base.parallelReduce(op, extractFunc);</span>
        }

        @Override
        public Collection&lt;LongRange&gt; ranges() {
<span class="nc" id="L439">            return base.ranges();</span>
        }

        @Override
        public boolean reduce(BoolReducer.Op op, Function&lt;S, Boolean&gt; extractFunc) {
<span class="nc" id="L444">            return base.reduce(op, extractFunc);</span>
        }

        @Override
        public double reduce(DoubleReducer.Op op, Function&lt;S, Double&gt; extractFunc) {
<span class="nc" id="L449">            return base.reduce(op, extractFunc);</span>
        }

        @Override
        public float reduce(FloatReducer.Op op, Function&lt;S, Float&gt; extractFunc) {
<span class="nc" id="L454">            return base.reduce(op, extractFunc);</span>
        }

        @Override
        public int reduce(IntReducer.Op op, Function&lt;S, Integer&gt; extractFunc) {
<span class="nc" id="L459">            return base.reduce(op, extractFunc);</span>
        }

        @Override
        public long reduce(LongReducer.Op op, Function&lt;S, Long&gt; extractFunc) {
<span class="nc" id="L464">            return base.reduce(op, extractFunc);</span>
        }

        @Override
        public &lt;R extends Reducer&lt;R, S&gt;&gt; R reduce(R reducer) {
<span class="nc" id="L469">            return base.reduce(reducer);</span>
        }

        @Override
        public short reduce(ShortReducer.Op op, Function&lt;S, Short&gt; extractFunc) {
<span class="nc" id="L474">            return base.reduce(op, extractFunc);</span>
        }

        @Override
        public &lt;R extends Reducer&lt;R, RangedList&lt;S&gt;&gt;&gt; R reduceChunk(R reducer) {
<span class="nc" id="L479">            return base.reduceChunk(reducer);</span>
        }

        @Override
        public RangedList&lt;S&gt; remove(LongRange range) {
<span class="nc" id="L484">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support remove operations.&quot;);</span>
        }

        @Override
        @Deprecated
        public RangedList&lt;S&gt; remove(RangedList&lt;S&gt; c) {
<span class="nc" id="L490">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support remove operations.&quot;);</span>
        }

        @Override
        public List&lt;ChunkedList&lt;S&gt;&gt; separate(int n) {
<span class="nc" id="L495">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support separate operations.&quot;);</span>
        }

        @Override
        public S set(long i, S value) {
<span class="nc" id="L500">            return base.set(i, value);</span>
        }

        @Override
        public long size() {
<span class="nc" id="L505">            return base.size();</span>
        }

        @Override
        public ArrayList&lt;RangedList&lt;S&gt;&gt; splitChunks(LongRange range) {
<span class="nc" id="L510">            throw new UnsupportedOperationException(&quot;UmmodifiableView does not support split operations.&quot;);</span>
        }

        @Override
        public Spliterator&lt;S&gt; spliterator() {
<span class="nc" id="L515">            return base.spliterator();</span>
        }

        @Override
        public ChunkedList&lt;S&gt; subList(LongRange range) {
<span class="nc" id="L520">            return new UnmodifiableView&lt;&gt;(base.subList(range));</span>
        }

        @Override
        public &lt;U&gt; void toBag(BiConsumer&lt;? super S, Consumer&lt;? super U&gt;&gt; action, Collection&lt;? super U&gt; toStore) {
<span class="nc" id="L525">            base.toBag(action, toStore);</span>
<span class="nc" id="L526">        }</span>

        @Override
        public &lt;U&gt; void toBag(BiConsumer&lt;? super S, Consumer&lt;? super U&gt;&gt; action, Consumer&lt;? super U&gt; receiver) {
<span class="nc" id="L530">            base.toBag(action, receiver);</span>
<span class="nc" id="L531">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L535">            return base.toString();</span>
        }
    }

    /** Serial Version UID */
    private static final long serialVersionUID = 6899796587031337979L;

    /**
     * Chunks contained by this instance. They are sorted using the
     * {@link LongRange} ordering.
     */
    protected final ConcurrentSkipListMap&lt;LongRange, RangedList&lt;T&gt;&gt; chunks;

    /**
     * Running tally of how many elements can be contained in the ChunkedList. It is
     * equal to the sum of the size of each individual chunk.
     */
    private final AtomicLong size;

    /**
     * Default constructor. Prepares the contained for the {@link Chunk}s this
     * instance is going to receive.
     */
<span class="fc" id="L558">    public ChunkedList() {</span>
<span class="fc" id="L559">        chunks = new ConcurrentSkipListMap&lt;&gt;(new LongRangeOrdering());</span>
<span class="fc" id="L560">        size = new AtomicLong(0l);</span>
<span class="fc" id="L561">    }</span>

    /**
     * Constructor which takes an initial {@link ConcurrentSkipListMap} of
     * {@link LongRange} mapped to {@link RangedList}.
     *
     * @param chunks initial mappings of {@link LongRange} and {@link Chunk}s
     * @throws IllegalArgumentException if the provided chunks do not follow the
     *                                  custom ordering used by {@link ChunkedList}.
     */
<span class="fc" id="L571">    public ChunkedList(ConcurrentSkipListMap&lt;LongRange, RangedList&lt;T&gt;&gt; chunks) {</span>
<span class="fc" id="L572">        this.chunks = chunks;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">        if (!(chunks.comparator() instanceof LongRangeOrdering)) {</span>
<span class="fc" id="L574">            throw new IllegalArgumentException(&quot;The provided chunks does not follow the correct ordering&quot;);</span>
        }
<span class="fc" id="L576">        long accumulator = 0l;</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (final LongRange r : chunks.keySet()) {</span>
<span class="fc" id="L578">            accumulator += r.size();</span>
<span class="fc" id="L579">        }</span>
<span class="fc" id="L580">        size = new AtomicLong(accumulator);</span>
<span class="fc" id="L581">    }</span>

    /**
     * Updates the contents of this collection based on the information contained in
     * the provided accumulator.
     *
     * @param &lt;A&gt;    accumulator type
     * @param acc    the accumulator into which information is recorded
     * @param update the closure which given an entry T of this collection and the
     *               corresponding accumulator A, updates the contents of the T
     *               entry.
     */
    public &lt;A&gt; void accept(Accumulator&lt;A&gt; acc, BiConsumer&lt;T, A&gt; update) {
<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (final ThreadLocalAccumulator&lt;A&gt; tla : acc.getAllThreadLocalAccumulator()) {</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">            for (final LongRange lr : tla.ranges()) {</span>
<span class="fc" id="L596">                final ChunkedList&lt;A&gt; accs = tla.acquire(lr);</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">                for (long l = lr.from; l &lt; lr.to; l++) {</span>
<span class="fc" id="L598">                    update.accept(get(l), accs.get(l));</span>
                }
<span class="fc" id="L600">            }</span>
<span class="fc" id="L601">        }</span>
<span class="fc" id="L602">    }</span>

    /**
     * Add a chunk to this instance. The provided chunk should not intersect with
     * any other already present in this instance, a {@link RuntimeException} will
     * be thrown otherwise.
     *
     * @param c the chunk to add to this instance
     * @throws RuntimeException if the range on which the provided {@link Chunk} is
     *                          defined intersects with another {@link Chunk}
     *                          already present in this instance
     */
    public void add(RangedList&lt;T&gt; c) {
<span class="fc" id="L615">        final LongRange desired = c.getRange();</span>
<span class="fc" id="L616">        final LongRange intersection = checkOverlap(desired);</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (intersection != null) {</span>
<span class="fc" id="L618">            throw new ElementOverlapException(&quot;LongRange &quot; + desired + &quot; overlaps &quot; + intersection</span>
                    + &quot; which is already present in this ChunkedList&quot;);
        }
<span class="fc" id="L621">        chunks.put(desired, c);</span>
<span class="fc" id="L622">        size.addAndGet(c.size());</span>
<span class="fc" id="L623">    }</span>

    /**
     * Places the given ranged list without performing any checks.
     * &lt;p&gt;
     * This is useful, particularly when splitting chunks as cannot afford a moment
     * between which the original chunk is removed from the collection and the newer
     * chunks are placed into the collection. As the newer chunks need to be placed
     * first, for a brief instant, the ChunkedList will contain multiple ranges
     * which overlap.
     *
     * @param c the chunk to place in the collection
     */
    protected void add_unchecked(RangedList&lt;T&gt; c) {
<span class="fc" id="L637">        chunks.put(c.getRange(), c);</span>
<span class="fc" id="L638">        size.addAndGet(c.size());</span>
<span class="fc" id="L639">    }</span>

    public &lt;U&gt; void asyncForEach(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            final ParallelReceiver&lt;? super U&gt; toStore) {
<span class="fc" id="L643">        asyncForEach(defaultParallelism(), action, toStore);</span>
<span class="fc" id="L644">    }</span>

    public void asyncForEach(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L647">        asyncForEach(defaultParallelism(), action);</span>
<span class="fc" id="L648">    }</span>

    /**
     * Performs the provided action on every element in the collection
     * asynchronously using the provided executor service and the specified degree
     * of parallelism. This method returns a {@link FutureN.ReturnGivenResult} which
     * will wait on every asynchronous task spawned to complete before returning
     * this instance. The provided action may initialize or extract a type U from
     * the data contained in individual elements and give this type U to its second
     * parameter (a {@link Consumer} of U) which will in turn place these instances
     * in {@code toStore}. Note that if you do not need to extract any information
     * from the elements in this collection, you should use method
     * {@link #asyncForEach(ExecutorService, int, Consumer)} instead.
     *
     * @param &lt;U&gt;      the type of the information to extract from the instances
     * @param pool     executor service in charge or performing the operation
     * @param nthreads the degree of parallelism for this action, corresponds to the
     *                 number of pieces in which this instance contents will be
     *                 split to be handled by parallel threads
     * @param action   to action to perform on each individual element contained in
     *                 this instance, which may include placing a newly created
     *                 instance of type U into the {@link Consumer} (second
     *                 parameter of the lambda expression).
     * @param toStore  instance which supplies the {@link Consumer} used the lambda
     *                 expression to every parallel thread and will collect all the
     *                 U instances given to those {@link Consumer}s.
     * @return a {@link ReturnGivenResult} which waits on the completion of all
     *         asynchronous tasks before returning this instance. Programmers should
     *         also wait on the completion of this {@link FutureN} to make sure that
     *         no more U instances are placed into {@code toStore}.
     */
    @Deprecated
    public &lt;U&gt; Future&lt;ChunkedList&lt;T&gt;&gt; asyncForEach(ExecutorService pool, int nthreads,
            BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, final ParallelReceiver&lt;? super U&gt; toStore) {
<span class="fc" id="L682">        final List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L683">            sub.toBag(action, toStore.getReceiver());</span>
<span class="fc" id="L684">        });</span>
<span class="fc" id="L685">        return new FutureN.ReturnGivenResult&lt;&gt;(futures, this);</span>
    }

    /**
     * Performs the provided action on every element in the collection
     * asynchronously using the provided executor service and the specified degree
     * of parallelism. This method returns a {@link FutureN.ReturnGivenResult} which
     * will wait on every asynchronous task spawned to complete before returning
     * this instance.
     *
     * @param pool     executor service in charge or performing the operation
     * @param nthreads the degree of parallelism for this action, corresponds to the
     *                 number of pieces in which this instance contents will be
     *                 split to be handled by parallel threads
     * @param action   to action to perform on each individual element contained in
     *                 this instance
     * @return a {@link ReturnGivenResult} which waits on the completion of all
     *         asynchronous tasks before returning this instance
     */
    @Deprecated
    public Future&lt;ChunkedList&lt;T&gt;&gt; asyncForEach(ExecutorService pool, int nthreads, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L706">        final List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L707">            sub.forEach(action);</span>
<span class="fc" id="L708">        });</span>
<span class="fc" id="L709">        return new FutureN.ReturnGivenResult&lt;&gt;(futures, this);</span>
    }

    /**
     * Performs the provided action on every (long) key and (T) value in the
     * collection asynchronously using the provided executor service and the
     * specified degree of parallelism. This method returns a
     * {@link FutureN.ReturnGivenResult} which will wait on every asynchronous task
     * spawned to complete before returning this instance.
     *
     * @param pool     executor service in charge or performing the operation
     * @param nthreads the degree of parallelism for this action, corresponds to the
     *                 number of pieces in which this instance contents will be
     *                 split to be handled by parallel threads
     * @param action   to action to perform on each pair of ({@code long} key and
     *                 (T) element contained in this instance
     * @return a {@link ReturnGivenResult} which waits on the completion of all
     *         asynchronous tasks before returning this instance
     */
    @Deprecated
    public Future&lt;ChunkedList&lt;T&gt;&gt; asyncForEach(ExecutorService pool, int nthreads, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L730">        final List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L731">            sub.forEach(action);</span>
<span class="fc" id="L732">        });</span>
<span class="fc" id="L733">        return new FutureN.ReturnGivenResult&lt;&gt;(futures, this);</span>
    }

    /**
     * This method was renamed to
     * {@link #asyncToBag(int, BiConsumer, ParallelReceiver)}
     *
     * @param &lt;U&gt;         type of the object created from each T contained in this
     *                    collection
     * @param parallelism number of threads to use in parallel
     * @param action      the action consisting of extracting a U object from a T
     *                    object of this collection
     * @param toStore     the collection into which the U objects are gathered
     * @see Bag
     */
    @Deprecated
    public &lt;U&gt; void asyncForEach(int parallelism, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            final ParallelReceiver&lt;? super U&gt; toStore) {
<span class="fc" id="L751">        asyncToBag(parallelism, action, toStore);</span>
<span class="fc" id="L752">    }</span>

    public void asyncForEach(int parallelism, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L755">        forEachParallelBody(parallelism, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L756">            sub.forEach(action);</span>
<span class="fc" id="L757">        });</span>
<span class="fc" id="L758">    }</span>

    public void asyncForEach(int parallelism, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L761">        forEachParallelBody(parallelism, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L762">            sub.forEach(action);</span>
<span class="fc" id="L763">        });</span>
<span class="fc" id="L764">    }</span>

    public void asyncForEach(LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L767">        asyncForEach(defaultParallelism(), action);</span>
<span class="fc" id="L768">    }</span>

    /**
     * Creates a new ChunkedList defined on the same {@link LongRange}s as this
     * instance by performing the mapping function on each element contained in this
     * instance. This method applies the user-provided function in parallel using
     * the threads in the provided {@link ExecutorService} with the set degree of
     * parallelism by splitting the values contained in this instance into
     * equal-size portions. These portions correspond to futures that complete when
     * the portion has been dealt with. This method returns a
     * {@link ReturnGivenResult} which will return the newly created
     * {@link ChunkedList} once all the individual futures have completed.
     *
     * @param &lt;S&gt;      the type handled by the newly created map
     * @param pool     the executor service in charge of processing this ChunkedList
     *                 in parallel
     * @param nthreads the degree of parallelism desired for this operation
     * @param func     the mapping function from type T to type S from which the
     *                 elements of the {@link ChunkedList} to create will be
     *                 initialized
     * @return a {@link ReturnGivenResult} which will return the new
     *         {@link ChunkedList} once all parallel mapping operations have
     *         completed
     */
    public &lt;S&gt; Future&lt;ChunkedList&lt;S&gt;&gt; asyncMap(ExecutorService pool, int nthreads,
            Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L794">        final ChunkedList&lt;S&gt; result = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L795">        final List&lt;Future&lt;?&gt;&gt; futures = mapParallelBody(pool, nthreads, func, result);</span>

<span class="fc bfc" id="L797" title="All 2 branches covered.">        for (final Future&lt;?&gt; f : futures) {</span>
            try {
<span class="fc" id="L799">                f.get();</span>
<span class="nc" id="L800">            } catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L801">                throw new ParallelExecutionException(&quot;[ChunkedList] exception raised by worker threads.&quot;, e);</span>
<span class="fc" id="L802">            }</span>
<span class="fc" id="L803">        }</span>
<span class="fc" id="L804">        return new FutureN.ReturnGivenResult&lt;&gt;(futures, result);</span>
    }

    /**
     * Obtain U objects from each T object contained in this collection and collect
     * them into a {@link ParallelReceiver}.
     *
     * @param &lt;U&gt;         type of the object created from each T contained in this
     *                    collection
     * @param parallelism number of threads to use in parallel
     * @param action      the action consisting of extracting a U object from a T
     *                    object of this collection
     * @param bag         the collection into which the U objects are gathered
     * @see Bag
     */
    public &lt;U&gt; void asyncToBag(int parallelism, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            final ParallelReceiver&lt;? super U&gt; bag) {
<span class="fc" id="L821">        forEachParallelBody(parallelism, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L822">            sub.toBag(action, bag.getReceiver());</span>
<span class="fc" id="L823">        });</span>
<span class="fc" id="L824">    }</span>

    /**
     * Method used in preparation before transferring chunks. This method checks if
     * a chunk contained in this object has its range exactly matching the range
     * specified as parameter. If that is the case, returns {@code true}.
     * &lt;p&gt;
     * If that is not the case, i.e. a chunk held by this collection needs to be
     * split so that the specified range can be sent to a remote host, attempts to
     * make the split. If it is successful in splitting the existing chunk so that
     * the specified range has a corresponding chunk stored in this collection,
     * returns {@code true}. If splitting the existing range failed (due to a
     * concurrent attempts to split that range), returns {@code false}. The caller
     * of this method will have to call it again to attempt to make the check again.
     * &lt;p&gt;
     * The synchronizations in this method are made such that multiple calls to this
     * method will run concurrently, as long as different chunks are targeted for
     * splitting.
     * &lt;p&gt;
     * If two (or more) concurrent calls to this method target the same chunk, they
     * should be made with ranges that do not intersect. For instance, assuming this
     * collection holds a chunk mapped to range [0, 100). Calls to this method with
     * ranges [0,50) and [50, 75) and [90, 100) in whichever order (or concurrently)
     * is acceptable. However, calling this method with parameters [0, 50) and [25,
     * 75) is problematic as the second one to be made (or scheduled) will fail to
     * make the splits as the split points will be in two different chunks. However,
     * calling this method with parameters [0, 50) and later on with [25, 50) is
     * acceptable.
     *
     * @param lr the point at which there needs to be a change of chunk. This range
     *           needs to be empty, i.e. its members &quot;from&quot; and &quot;to&quot; need to be
     *           equal
     * @return {@code true} if the specified range can be safely sent to a remote
     *         place, {@code false} if this method needs to be called again to make
     *         it happen
     */
    protected boolean attemptSplitChunkAtSinglePoint(LongRange lr) {
<span class="fc" id="L861">        final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(lr);</span>

        // It is possible for the requested point not to be present in any chunk
<span class="fc bfc" id="L864" title="All 4 branches covered.">        if (entry == null || !entry.getKey().contains(lr.from)) {</span>
<span class="fc" id="L865">            return true;</span>
        }

<span class="fc" id="L868">        final LongRange chunkRange = entry.getKey();</span>
<span class="pc bpc" id="L869" title="1 of 4 branches missed.">        final boolean splitNeeded = chunkRange.from &lt; lr.from &amp;&amp; lr.from &lt; chunkRange.to;</span>

<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (!splitNeeded) {</span>
<span class="fc" id="L872">            return true;</span>
        }

        // Arrived here, we know that the chunk we have needs to be split
        // We synchronize on this specific Chunk
<span class="fc" id="L877">        synchronized (chunkRange) {</span>
            // We restart the chunk acquisition process to check if we obtain the same chunk
            // If that is not the case, another thread has modified the chunks in the
            // ChunkedList and
            // this method has failed to do the modification, which will have to be
            // attempted again
<span class="fc" id="L883">            final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; checkEntry = chunks.floorEntry(lr);</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">            if (!entry.getKey().equals(checkEntry.getKey())) {</span>
<span class="nc" id="L885">                return false;</span>
            }

            // Check passed, we are the only thread which can split the targeted chunk
<span class="fc" id="L889">            final LinkedList&lt;RangedList&lt;T&gt;&gt; splittedChunks = entry.getValue().splitRange(lr.from);</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">            while (!splittedChunks.isEmpty()) {</span>
                // It is important to insert the splitted chunks in reverse order.
                // Otherwise, parts of the original chunk would be shadowed due to the ordering
                // of Chunks used in ChunkedList, concurrently calling ChunkedList(or
                // DistCol)#get(long) would fail.
<span class="fc" id="L895">                add_unchecked(splittedChunks.pollLast());</span>
            }
<span class="fc" id="L897">            remove(chunkRange);</span>
<span class="fc" id="L898">            return true;</span>
        }
    }

    /**
     * Method used in preparation before transferring chunks. This method checks if
     * a chunk contained in this object has its range exactly matching the range
     * specified as parameter. If that is the case, returns {@code true}.
     * &lt;p&gt;
     * If that is not the case, i.e. a chunk held by this collection needs to be
     * split so that the specified range can be sent to a remote host, attempts to
     * make the split. If it is successful in splitting the existing chunk so that
     * the specified range has a corresponding chunk stored in this collection,
     * returns {@code true}. If splitting the existing range failed (due to a
     * concurrent attempts to split that range), returns {@code false}. The caller
     * of this method will have to call it again to attempt to make the check again.
     * &lt;p&gt;
     * The synchronizations in this method are made such that multiple calls to this
     * method will run concurrently, as long as different chunks are targeted for
     * splitting.
     * &lt;p&gt;
     * If two (or more) concurrent calls to this method target the same chunk, they
     * should be made with ranges that do not intersect. For instance, assuming this
     * collection holds a chunk mapped to range [0, 100). Calls to this method with
     * ranges [0,50) and [50, 75) and [90, 100) in whichever order (or concurrently)
     * is acceptable. However, calling this method with parameters [0, 50) and [25,
     * 75) is problematic as the second one to be made (or scheduled) will fail to
     * make the splits as the split points will be in two different chunks. However,
     * calling this method with parameters [0, 50) and later on with [25, 50) is
     * acceptable.
     *
     * @param lr the range of entries which is going to be sent away. It is assumed
     *           that there exists a chunk in this collection which includes this
     *           provided range.
     * @return {@code true} if the specified range can be safely sent to a remote
     *         place, {@code false} if this method needs to be called again to make
     *         it happen
     */
    protected boolean attemptSplitChunkAtTwoPoints(LongRange lr) {
<span class="fc" id="L937">        final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(lr);</span>

<span class="fc" id="L939">        final LongRange chunkRange = entry.getKey();</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">        final boolean leftSplit = chunkRange.from &lt; lr.from;</span>
<span class="fc bfc" id="L941" title="All 2 branches covered.">        final boolean rightSplit = lr.to &lt; chunkRange.to;</span>

        long[] splitPoints;
<span class="fc bfc" id="L944" title="All 4 branches covered.">        if (leftSplit &amp;&amp; rightSplit) {</span>
<span class="fc" id="L945">            splitPoints = new long[2];</span>
<span class="fc" id="L946">            splitPoints[0] = lr.from;</span>
<span class="fc" id="L947">            splitPoints[1] = lr.to;</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">        } else if (leftSplit) {</span>
<span class="fc" id="L949">            splitPoints = new long[1];</span>
<span class="fc" id="L950">            splitPoints[0] = lr.from;</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">        } else if (rightSplit) {</span>
<span class="fc" id="L952">            splitPoints = new long[1];</span>
<span class="fc" id="L953">            splitPoints[0] = lr.to;</span>
        } else {
<span class="fc" id="L955">            return true;</span>
        }

        // Arrived here, we know that the chunk we have needs to be split
        // We synchronize on this specific Chunk
<span class="fc" id="L960">        synchronized (chunkRange) {</span>
            // We restart the chunk acquisition process to check if we obtain the same chunk
            // If that is not the case, another thread has modified the chunks in the
            // ChunkedList and
            // this method has failed to do the modification, which will have to be
            // attempted again
<span class="fc" id="L966">            final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; checkEntry = chunks.floorEntry(lr);</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">            if (!entry.getKey().equals(checkEntry.getKey())) {</span>
<span class="fc" id="L968">                return false;</span>
            }

            // Check passed, we are the only thread which can split the targeted chunk
<span class="fc" id="L972">            final LinkedList&lt;RangedList&lt;T&gt;&gt; splittedChunks = entry.getValue().splitRange(splitPoints);</span>
<span class="fc bfc" id="L973" title="All 2 branches covered.">            while (!splittedChunks.isEmpty()) {</span>
                // It is important to insert the splitted chunks in reverse order.
                // Otherwise, parts of the original chunk would be shadowed due to the ordering
                // of Chunks used in ChunkedList, concurrently calling ChunkedList(or
                // DistCol)#get(long) would fail.
<span class="fc" id="L978">                add_unchecked(splittedChunks.pollLast());</span>
            }
<span class="fc" id="L980">            remove(chunkRange);</span>
<span class="fc" id="L981">            return true;</span>
        }
    }

    /**
     * Checks if the provided {@link LongRange} intersects with the range of one of
     * the chunks contained by this instance. Returns the intersecting
     * {@link LongRange}, or {@code null} if there are no intersecting
     * {@link Chunk}s.
     *
     * @param range the LongRange instance to check
     * @return a LongRange on which one of the Chunks of this object is defined that
     *         intersects with the provided {@link LongRange}, or {@code null} if
     *         there are no such intersecting {@link Chunk}s
     */
    private LongRange checkOverlap(LongRange range) {
<span class="fc" id="L997">        return range.findOverlap(chunks);</span>
    }

    /**
     * Removes all the chunks contained in this instance. This instance is
     * effectively empty as a result and a subsequent call to {@link #isEmpty()}
     * will return {@code true}, calling {@link #size()} will return {@code 0l}.
     */
    public void clear() {
<span class="fc" id="L1006">        size.set(0l);</span>
<span class="fc" id="L1007">        chunks.clear();</span>
<span class="fc" id="L1008">    }</span>

    /**
     * Returns a new {@link ChunkedList} which contains the same {@link Chunk}s as
     * this instance.
     *
     * @return a ChunkedList which holds the same Chunks as this instance
     */
    @Override
    protected Object clone() {
<span class="fc" id="L1018">        final ConcurrentSkipListMap&lt;LongRange, RangedList&lt;T&gt;&gt; newChunks = new ConcurrentSkipListMap&lt;&gt;(</span>
                new LongRangeOrdering());
<span class="fc bfc" id="L1020" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L1021">            newChunks.put(c.getRange(), ((Chunk&lt;T&gt;) c).clone());</span>
<span class="fc" id="L1022">        }</span>
<span class="fc" id="L1023">        return new ChunkedList&lt;&gt;(newChunks);</span>
    }

    /**
     * Checks if the provided object is contained within one of the Chunks this
     * instance holds. More formally, returns true if at least one of the chunks in
     * this instance contains at least one element 'e' such that (o==null ? e==null
     * : o.equals(e)). Of course, there may be several such elements 'e' in this
     * instance located in a single and/or multiple chunks.
     *
     * @param o object whose presence is to be checked
     * @return true if the provided object is contained in at least one of the
     *         chunks contained in this instance
     */
    public boolean contains(Object o) {
<span class="fc bfc" id="L1038" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; chunk : chunks.values()) {</span>
<span class="fc bfc" id="L1039" title="All 2 branches covered.">            if (chunk.contains(o)) {</span>
<span class="fc" id="L1040">                return true;</span>
            }
<span class="fc" id="L1042">        }</span>
<span class="fc" id="L1043">        return false;</span>
    }

    /**
     * Checks if all the elements provided in the collection are present in this
     * instance.
     * &lt;p&gt;
     * In its current implementation, it is equivalent to calling method
     * {@link #contains(Object)} with each element in the collection until either an
     * element is not found in this collection (at which point the method returns
     * {@code false} without checking the remaining objects in the collection) or
     * all the elements in the provided collection are found in this instance (at
     * which point this method returns {@code true}. If programmer can place the
     * elements that are more likely to be absent from this instance at the
     * beginning of the collection (in the order used by the {@link Iterator}, it
     * may save considerable execution time.
     *
     * @param c elements whose presence in this instance is to be checked
     * @return true if every instance in the provided collection is present in this
     *         collection
     */
    public boolean containsAll(Collection&lt;?&gt; c) {
        // cf
        // https://stackoverflow.com/questions/10199772/what-is-the-cost-of-containsall-in-java
<span class="fc" id="L1067">        final Iterator&lt;?&gt; e = c.iterator();</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">        while (e.hasNext()) {</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">            if (!this.contains(e.next())) {</span>
<span class="fc" id="L1070">                return false;</span>
            }
        }
<span class="fc" id="L1073">        return true;</span>
    }

    /**
     * Returns whether this {@link ChunkedList} contains the given
     * {@link RangedList}.
     *
     * @param c the {@link RangedList} whose inclusion in this instance needs to be
     *          checked
     * @return {@code true} if the provided {@link RangedList} is contained in this
     *         instance, {@code false} otherwise
     */
    public boolean containsChunk(RangedList&lt;T&gt; c) {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        if (c == null) {</span>
<span class="fc" id="L1087">            return false;</span>
        }
        // TODO I think we can do better than iterating over every entry in Chunks.
        // Iterating on the Chunks that intersect the range on which the 'c' given
        // as parameter is define would be an improvement.
<span class="fc" id="L1092">        return chunks.containsValue(c);</span>
    }

    public boolean containsIndex(long i) {
<span class="fc" id="L1096">        final LongRange r = new LongRange(i);</span>
<span class="fc" id="L1097">        final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(r);</span>
<span class="fc bfc" id="L1098" title="All 4 branches covered.">        if (entry == null || !entry.getKey().contains(i)) {</span>
//            entry = chunks.ceilingEntry(r);
//            if (entry == null || !entry.getKey().contains(i)) {
<span class="fc" id="L1101">            return false;</span>
//            }
        }
<span class="fc" id="L1104">        return true;</span>
    }

    public boolean containsRange(LongRange range) {
        // TODO same as method #containsChunk, this method needs improvements
<span class="fc" id="L1109">        return range.contained(chunks);</span>
    }

    private int defaultParallelism() {
<span class="fc" id="L1113">        return Runtime.getRuntime().availableProcessors() * 2;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L1118" title="1 of 4 branches missed.">        if (o == null || !(o instanceof ChunkedList)) {</span>
<span class="fc" id="L1119">            return false;</span>
        }
        // FIXME very slow
<span class="fc" id="L1122">        final ChunkedList&lt;?&gt; target = (ChunkedList&lt;?&gt;) o;</span>
<span class="fc bfc" id="L1123" title="All 2 branches covered.">        if (size() != target.size()) {</span>
<span class="fc" id="L1124">            return false;</span>
        }
<span class="fc bfc" id="L1126" title="All 2 branches covered.">        for (final LongRange range : chunks.keySet()) {</span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">            for (final long index : range) {</span>
<span class="fc" id="L1128">                final T mine = get(index);</span>
<span class="fc" id="L1129">                final Object yours = target.get(index);</span>
<span class="fc bfc" id="L1130" title="All 4 branches covered.">                if (mine == null &amp;&amp; yours != null) {</span>
<span class="fc" id="L1131">                    return false;</span>
                }
<span class="fc bfc" id="L1133" title="All 4 branches covered.">                if (mine != null &amp;&amp; !mine.equals(yours)) {</span>
<span class="fc" id="L1134">                    return false;</span>
                }
<span class="fc" id="L1136">            }</span>
<span class="fc" id="L1137">        }</span>
<span class="fc" id="L1138">        return true;</span>
    }

    /**
     * Returns the list of {@link Chunk} that pass the provided filter. Chunks are
     * included if the filter returns {@code true}.
     *
     * @param filter the filter deciding if a given chunk should be included in the
     *               returned list
     * @return the {@link Chunk}s contained in this instance which passed the
     *         provided filter
     */
    public List&lt;RangedList&lt;T&gt;&gt; filterChunk(Predicate&lt;RangedList&lt;? super T&gt;&gt; filter) {
<span class="fc" id="L1151">        final List&lt;RangedList&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">            if (filter.test(c)) {</span>
<span class="fc" id="L1154">                result.add(c);</span>
            }
<span class="fc" id="L1156">        }</span>
<span class="fc" id="L1157">        return result;</span>
    }

    /**
     * Uses this collection entries to accumulate information into the supplied
     * {@link Accumulator}.
     *
     * @param &lt;A&gt;    accumulator type
     * @param acc    the accumulator into which information is recorded
     * @param action the action to perform with regards to each T element contained
     *               in this collection.
     */
    public &lt;A&gt; void forEach(Accumulator&lt;A&gt; acc, BiConsumer&lt;T, ThreadLocalAccumulator&lt;A&gt;&gt; action) {
<span class="nc" id="L1170">        final ThreadLocalAccumulator&lt;A&gt; accumulator = acc.obtainThreadLocalAccumulators(1).get(0);</span>
<span class="nc" id="L1171">        forEach(t -&gt; action.accept(t, accumulator));</span>
<span class="nc" id="L1172">    }</span>

    /**
     * Uses this collection entries to accumulate information into the supplied
     * {@link Accumulator}
     *
     * @param &lt;A&gt;    accumulator type
     * @param acc    the accumulator into which information is recorded
     * @param action the action to perform with regards to each index/T element
     *               contained in this collection, the third argument of this
     *               closure is the thread-local accumulator
     */
    public &lt;A&gt; void forEach(Accumulator&lt;A&gt; acc, LongTTriConsumer&lt;T, ThreadLocalAccumulator&lt;A&gt;&gt; action) {
<span class="fc" id="L1185">        final ThreadLocalAccumulator&lt;A&gt; accumulator = acc.obtainThreadLocalAccumulators(1).get(0);</span>
<span class="fc" id="L1186">        forEach((l, t) -&gt; action.accept(l, t, accumulator));</span>
<span class="fc" id="L1187">    }</span>

    /**
     * This method was renamed to {@link #toBag(BiConsumer, Collection)}
     *
     * @param &lt;U&gt;     the type of the information to extract
     * @param action  action to perform on each element of the collection
     * @param toStore the collection in which the information extracted will be
     *                stored
     */
    @Deprecated
    public &lt;U&gt; void forEach(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, final Collection&lt;? super U&gt; toStore) {
<span class="fc" id="L1199">        toBag(action, toStore);</span>
<span class="fc" id="L1200">    }</span>

    /**
     * This method was renamed to {@link #toBag(BiConsumer, Consumer)}
     *
     * @param &lt;U&gt;      the type of the result extracted from the elements in this
     *                 collection
     * @param action   the action to perform on each element of this collection
     * @param receiver the receiver which will accept the U instances extracted from
     *                 the elements of this collection
     */
    @Deprecated
    public &lt;U&gt; void forEach(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, Consumer&lt;? super U&gt; receiver) {
<span class="fc" id="L1213">        toBag(action, receiver);</span>
<span class="fc" id="L1214">    }</span>

    /**
     * This method was renamed to {@link #toBag(BiConsumer, ParallelReceiver)}
     *
     * @param &lt;U&gt;     type produced from T elements contained in this collection
     * @param action  action consisting of extracting some U information from each
     *                element in this collection and storing them into the
     * @param toStore the {@link ParallelReceiver} into which all U elements will be
     *                placed
     */
    @Deprecated
    public &lt;U&gt; void forEach(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, ParallelReceiver&lt;? super U&gt; toStore) {
<span class="fc" id="L1227">        toBag(action, toStore);</span>
<span class="fc" id="L1228">    }</span>

    /**
     * Performs the provided action on every element contained in this collection.
     *
     * @param action action to perform on each element contained in this instance
     */
    @Override
    public void forEach(Consumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L1237" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L1238">            c.forEach(action);</span>
<span class="fc" id="L1239">        }</span>
<span class="fc" id="L1240">    }</span>

    /**
     * Performs the provided action on each element of this collection in parallel
     * using the provided {@link ExecutorService} with the specified degree of
     * parallelism. This action may involve extracting some information of type U
     * from individual elements and placing these into the Consumer (second argument
     * of the lambda expression). This {@link Consumer} used in the lambda exression
     * is obtained from the provided {@link ParallelReceiver} which will receive all
     * the U instances produced during this method. This method returns when all the
     * elements in the collection have been treated.
     *
     * @param &lt;U&gt;      type of the information extracted from individual elements
     * @param pool     executor service in charge of processing the elements of this
     *                 instance in parallel
     * @param nthreads degree of parallelism desired for this operation
     * @param action   action to perform on individual elements of this collection,
     *                 potentially extracting some information of type U and giving
     *                 it to the {@link Consumer}, the second argument of the action
     * @param toStore  {@link ParallelReceiver} instance which provides the
     *                 {@link Consumer}s of each thread that will process the
     *                 elements of this library and receive all the U elements
     *                 extracted from this collection
     */
    @Deprecated
    public &lt;U&gt; void forEach(ExecutorService pool, int nthreads, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            final ParallelReceiver&lt;U&gt; toStore) {
<span class="fc" id="L1267">        final List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L1268">            sub.toBag(action, toStore.getReceiver());</span>
<span class="fc" id="L1269">        });</span>
<span class="fc" id="L1270">        waitNfutures(futures);</span>
<span class="fc" id="L1271">    }</span>

    /**
     * Performs the provided action on every eleement in the collection in parallel
     * using the provided {@link ExecutorService} and the set degree of parallelism.
     * Returns when all operations have finished.
     *
     * @param pool     executor service in charge or performing the operation
     * @param nthreads the degree of parallelism for this action, corresponds to the
     *                 number of pieces in which this instance contents will be
     *                 split to be handled by parallel threads
     * @param action   to action to perform on element contained in this instance
     */
    @Deprecated
    public void forEach(ExecutorService pool, int nthreads, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L1286">        final List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L1287">            sub.forEach(action);</span>
<span class="fc" id="L1288">        });</span>
<span class="fc" id="L1289">        waitNfutures(futures);</span>
<span class="fc" id="L1290">    }</span>

    /**
     * Performs the provided action on every (long) key and (T) value in the
     * collection in parallel using the provided {@link ExecutorService} and the set
     * degree of parallelism. Returns when all operations have finished.
     *
     * @param pool     executor service in charge or performing the operation
     * @param nthreads the degree of parallelism for this action, corresponds to the
     *                 number of pieces in which this instance contents will be
     *                 split to be handled by parallel threads
     * @param action   to action to perform on each pair of ({@code long} key and
     *                 (T) element contained in this instance
     */
    @Deprecated
    public void forEach(ExecutorService pool, int nthreads, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L1306">        final List&lt;Future&lt;?&gt;&gt; futures = forEachParallelBody(pool, nthreads, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L1307">            sub.forEach(action);</span>
<span class="fc" id="L1308">        });</span>
<span class="fc" id="L1309">        waitNfutures(futures);</span>
<span class="fc" id="L1310">    }</span>

    /**
     * TODO : Still not sure if it works.
     */
    public void forEach(LongRange range, final Consumer&lt;? super T&gt; action) {
<span class="fc" id="L1316">        subList(range).forEach(action);</span>
<span class="fc" id="L1317">    }</span>

    /**
     * TODO : Still not sure if it works.
     */
    public void forEach(LongRange range, final LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L1323">        subList(range).forEach(action);</span>
<span class="fc" id="L1324">    }</span>

    /**
     * Performs the provided action on every (long) key and (T) value in the
     * collection serquentially and returns.
     *
     * @param action to action to perform on each pair of ({@code long} key and (T)
     *               element contained in this instance
     */
    public void forEach(LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc bfc" id="L1334" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L1335">            c.forEach(c.getRange(), action);</span>
<span class="fc" id="L1336">        }</span>
<span class="fc" id="L1337">    }</span>

    /**
     * Performs the provided operation on each {@link Chunk} contained in this
     * instance and returns.
     *
     * @param op operation to make on each chunk
     */
    public void forEachChunk(Consumer&lt;RangedList&lt;T&gt;&gt; op) {
<span class="fc bfc" id="L1346" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L1347">            op.accept(c);</span>
<span class="fc" id="L1348">        }</span>
<span class="fc" id="L1349">    }</span>

    /**
     * Performs the provided operation on each {@link Chunk} contained in this
     * instance and overlapped with the given range, then returns. Note that the
     * {@code op} receives {@link Chunk} that may not be contained in the range. If
     * the {@code range} is {@code null}, all the chunk will be scanned.
     *
     * This method dynamically scans the contained chunks. When searching the next
     * chunk, its search from the end of the previous chunk.
     *
     * @param range range to be scanned
     * @param op    operation to make on each chunk
     */
    public void forEachChunk(LongRange range, Consumer&lt;RangedList&lt;T&gt;&gt; op) {
<span class="pc bpc" id="L1364" title="1 of 2 branches missed.">        LongRange result = (range != null) ? range.findOverlap(chunks) : chunks.firstKey();</span>
        while (true) {
<span class="fc bfc" id="L1366" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc" id="L1367">                break;</span>
            }
<span class="fc" id="L1369">            final LongRange inter = range.intersection(result);</span>
<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">            if (inter != null) {</span>
<span class="fc" id="L1371">                op.accept(chunks.get(result));</span>
            }
<span class="pc bpc" id="L1373" title="1 of 4 branches missed.">            if (range != null &amp;&amp; result.to &gt;= range.to) {</span>
<span class="fc" id="L1374">                break;</span>
            }
<span class="fc" id="L1376">            result = chunks.higherKey(new LongRange(result.to - 1));</span>
<span class="fc" id="L1377">        }</span>
<span class="fc" id="L1378">    }</span>

    @Deprecated
    private List&lt;Future&lt;?&gt;&gt; forEachParallelBody(ExecutorService pool, int nthreads, Consumer&lt;ChunkedList&lt;T&gt;&gt; run) {
<span class="fc" id="L1382">        final List&lt;ChunkedList&lt;T&gt;&gt; separated = this.separate(nthreads);</span>
<span class="fc" id="L1383">        final List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        for (final ChunkedList&lt;T&gt; sub : separated) {</span>
<span class="fc" id="L1385">            futures.add(pool.submit(() -&gt; {</span>
<span class="fc" id="L1386">                run.accept(sub);</span>
<span class="fc" id="L1387">            }));</span>
<span class="fc" id="L1388">        }</span>
<span class="fc" id="L1389">        return futures;</span>
    }

    private void forEachParallelBody(int parallelism, Consumer&lt;ChunkedList&lt;T&gt;&gt; run) {
<span class="fc" id="L1393">        final List&lt;ChunkedList&lt;T&gt;&gt; separated = separate(parallelism);</span>
<span class="fc bfc" id="L1394" title="All 2 branches covered.">        for (final ChunkedList&lt;T&gt; sub : separated) {</span>
<span class="fc" id="L1395">            async(() -&gt; {</span>
<span class="fc" id="L1396">                run.accept(sub);</span>
<span class="fc" id="L1397">            });</span>
<span class="fc" id="L1398">        }</span>
<span class="fc" id="L1399">    }</span>

    /**
     * Finds the chunk containing the provided index and returns the associated
     * value.
     *
     * @param i long index whose associated value should be returned
     * @return the value associated with the provided index
     * @throws IndexOutOfBoundsException if the provided index is not contained by
     *                                   any chunk in this instance
     * @see #containsIndex(long)
     */
    public T get(long i) {
<span class="fc" id="L1412">        final LongRange r = new LongRange(i);</span>
<span class="fc" id="L1413">        final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(r);</span>
<span class="pc bpc" id="L1414" title="1 of 4 branches missed.">        if (entry == null || !entry.getKey().contains(i)) {</span>
//            entry = chunks.ceilingEntry(r);
//            if (entry == null || !entry.getKey().contains(i)) {
<span class="fc" id="L1417">            throw new IndexOutOfBoundsException(&quot;ChunkedList: index &quot; + i + &quot; is not within the range of any chunk&quot;);</span>
//            }
        }
<span class="fc" id="L1420">        final RangedList&lt;T&gt; chunk = entry.getValue();</span>
<span class="fc" id="L1421">        return chunk.get(i);</span>
    }

    /**
     * Returns the chunk in this instance which contain the specified
     * {@link LongRange}.
     * &lt;p&gt;
     * The specified range needs to be fully included into a single chunk contained
     * in this instance, or exactly match the range of an existing chunk. Calling
     * this method with a {@link LongRange} which spans multiple chunks, or which is
     * not (even partially) included into any single chunk is undefined behavior
     * (the method may return an arbitrary chunk or throw a
     * {@link NullPointerException}).
     *
     * @param lr the targeted range
     * @return the chunk that contains the specified range
     */
    public RangedList&lt;T&gt; getChunk(LongRange lr) {
<span class="fc" id="L1439">        return chunks.floorEntry(lr).getValue();</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L1444">        int hashCode = 1;</span>
        // code from JavaAPI doc of List
<span class="fc bfc" id="L1446" title="All 2 branches covered.">        for (final RangedList&lt;?&gt; c : chunks.values()) {</span>
<span class="pc bpc" id="L1447" title="1 of 2 branches missed.">            hashCode = 31 * hashCode + (c == null ? 0 : c.hashCode());</span>
<span class="fc" id="L1448">        }</span>
<span class="fc" id="L1449">        return hashCode;</span>
    }

    /**
     * Indicates if this instance does not contain any chunk
     *
     * @return {@code true} if this instance does not contain any chunk
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1458" title="All 2 branches covered.">        return size.get() == 0;</span>
    }

    /**
     * Returns an iterator on the values contained by every chunk in this instance.
     *
     * @return an iterator on the elements contained in this {@link ChunkedList}
     */
    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L1468">        return new It&lt;&gt;(chunks);</span>
    }

    /**
     * Creates a new {@link ChunkedList} by applying the provided map function in
     * parallel to every element of every {@link Chunk} contained by this instance.
     *
     * @param &lt;S&gt;      the type produced by the map function
     * @param pool     the executor service in charge of realizing the parallel
     *                 operation
     * @param nthreads the degree of parallelism allowed for this operation. The
     *                 {@link ChunkedList}'s Chunks will be split into the specified
     *                 number of portions that contain roughly same number of
     *                 indices.
     * @param func     the mapping function taking a T as parameter and returning a
     *                 S
     * @return a newly created ChunkedList which contains the result of mapping the
     *         elements of this instance
     */
    public &lt;S&gt; ChunkedList&lt;S&gt; map(ExecutorService pool, int nthreads, Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L1488">        final ChunkedList&lt;S&gt; result = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L1489">        final List&lt;Future&lt;?&gt;&gt; futures = mapParallelBody(pool, nthreads, func, result);</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">        for (final Future&lt;?&gt; f : futures) {</span>
            try {
<span class="fc" id="L1492">                f.get();</span>
<span class="nc" id="L1493">            } catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L1494">                throw new ParallelExecutionException(&quot;[ChunkedList] exception raised by worker threads.&quot;, e);</span>
<span class="fc" id="L1495">            }</span>
<span class="fc" id="L1496">        }</span>
<span class="fc" id="L1497">        return result;</span>
    }

    /**
     * Creates a new {@link ChunkedList} by applying the provided map function to
     * every element of every {@link Chunk} contained by this instance.
     *
     * @param &lt;S&gt;  the type produced by the map function
     * @param func the mapping function taking a T as parameter and returning a S
     * @return a newly created ChunkedList which contains the result of mapping the
     *         elements of this instance
     */
    public &lt;S&gt; ChunkedList&lt;S&gt; map(Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L1510">        final ChunkedList&lt;S&gt; result = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L1511">        forEachChunk((RangedList&lt;T&gt; c) -&gt; {</span>
<span class="fc" id="L1512">            final RangedList&lt;S&gt; r = c.map(func);</span>
<span class="fc" id="L1513">            result.add(r);</span>
<span class="fc" id="L1514">        });</span>
<span class="fc" id="L1515">        return result;</span>
    }

    private &lt;S&gt; List&lt;Future&lt;?&gt;&gt; mapParallelBody(ExecutorService pool, int nthreads,
            Function&lt;? super T, ? extends S&gt; func, ChunkedList&lt;S&gt; result) {
<span class="fc" id="L1520">        forEachChunk((RangedList&lt;T&gt; c) -&gt; {</span>
<span class="fc" id="L1521">            result.add(new Chunk&lt;S&gt;(c.getRange()));</span>
<span class="fc" id="L1522">        });</span>
<span class="fc" id="L1523">        final List&lt;ChunkedList&lt;T&gt;&gt; separatedIn = this.separate(nthreads);</span>
<span class="fc" id="L1524">        final List&lt;ChunkedList&lt;S&gt;&gt; separatedOut = result.separate(nthreads);</span>
<span class="fc" id="L1525">        final List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1526" title="All 2 branches covered.">        for (int i = 0; i &lt; nthreads; i++) {</span>
<span class="fc" id="L1527">            final int i0 = i;</span>
<span class="fc" id="L1528">            futures.add(pool.submit(() -&gt; {</span>
<span class="fc" id="L1529">                final ChunkedList&lt;T&gt; from = separatedIn.get(i0);</span>
<span class="fc" id="L1530">                final ChunkedList&lt;S&gt; to = separatedOut.get(i0);</span>
<span class="fc" id="L1531">                from.mapTo(to, func);</span>
<span class="fc" id="L1532">                return null;</span>
            }));
        }
<span class="fc" id="L1535">        return futures;</span>
    }

    private &lt;S&gt; void mapTo(ChunkedList&lt;S&gt; to, Function&lt;? super T, ? extends S&gt; func) {
<span class="fc" id="L1539">        final Iterator&lt;RangedList&lt;T&gt;&gt; fromIter = chunks.values().iterator();</span>
<span class="fc" id="L1540">        final Iterator&lt;RangedList&lt;S&gt;&gt; toIter = to.chunks.values().iterator();</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">        while (fromIter.hasNext()) {</span>
<span class="pc bpc" id="L1542" title="2 of 4 branches missed.">            assert (toIter.hasNext());</span>
<span class="fc" id="L1543">            final RangedList&lt;T&gt; fromChunk = fromIter.next();</span>
<span class="fc" id="L1544">            final RangedList&lt;S&gt; toChunk = toIter.next();</span>
<span class="fc" id="L1545">            toChunk.setupFrom(fromChunk, func);</span>
<span class="fc" id="L1546">        }</span>
<span class="fc" id="L1547">    }</span>

    /**
     * Returns the number of chunks contained in this instance
     *
     * @return number of chunks in this instance
     */
    public int numChunks() {
<span class="fc" id="L1555">        return chunks.size();</span>
    }

    /**
     * Updates the contents of this collection in parallel, based on the information
     * contained in the provided accumulator.
     *
     * @param &lt;A&gt;    accumulator type
     * @param acc    the accumulator into which information is recorded
     * @param update the closure which given an entry T of this collection and the
     *               corresponding accumulator A, updates the contents of the T
     *               entry.
     */
    public &lt;A&gt; void parallelAccept(Accumulator&lt;A&gt; acc, BiConsumer&lt;T, A&gt; update) {
<span class="fc" id="L1569">        parallelAccept(Runtime.getRuntime().availableProcessors(), acc, update);</span>
<span class="fc" id="L1570">    }</span>

    /**
     * Updates the contents of this collection in parallel, based on the information
     * contained in the provided accumulator
     *
     * @param &lt;A&gt;         accumulator type
     * @param parallelism number of threads desired for this collection
     * @param acc         the accumulator into which information was recorded
     * @param update      the closure given every T and matching A type in the
     *                    accumulator comes to update T
     */
    public &lt;A&gt; void parallelAccept(int parallelism, Accumulator&lt;A&gt; acc, BiConsumer&lt;T, A&gt; update) {
<span class="fc" id="L1583">        finish(() -&gt; {</span>
<span class="fc" id="L1584">            forEachParallelBody(parallelism, cl -&gt; {</span>
                // For each TLA in acc
<span class="fc bfc" id="L1586" title="All 2 branches covered.">                for (final ThreadLocalAccumulator&lt;A&gt; tla : acc.getAllThreadLocalAccumulator()) {</span>
                    // Obtain the ranges matching that of assigned `cl`
<span class="fc" id="L1588">                    final ChunkedList&lt;A&gt; tlaChunk = tla.getChunkedList();</span>

                    // Probably a more efficient implementation possible
<span class="fc" id="L1591">                    cl.forEach((l, t) -&gt; {</span>
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">                        if (tlaChunk.containsIndex(l)) {</span>
<span class="fc" id="L1593">                            update.accept(t, tlaChunk.get(l));</span>
                        }
<span class="fc" id="L1595">                    });</span>
<span class="fc" id="L1596">                }</span>
<span class="fc" id="L1597">            });</span>
<span class="fc" id="L1598">        });</span>
<span class="fc" id="L1599">    }</span>

    /**
     * Accumulates information into the provided accumulator, using this
     * collection's element as a source
     * &lt;p&gt;
     * This method is a parallel variant of method
     * {@link #forEach(Accumulator, BiConsumer)}
     *
     * @param &lt;A&gt;    accumulator type
     * @param acc    the accumulator into which information will be stored
     * @param action the action to perform with respect to each T element contained
     *               in this collection
     */
    public &lt;A&gt; void parallelForEach(Accumulator&lt;A&gt; acc, BiConsumer&lt;T, ThreadLocalAccumulator&lt;A&gt;&gt; action) {
<span class="nc" id="L1614">        parallelForEach(Runtime.getRuntime().availableProcessors(), acc, action);</span>
<span class="nc" id="L1615">    }</span>

    /**
     * Accumulates information into the provided accumulator in parallel, using this
     * collection's index/element as a source
     * &lt;p&gt;
     * This method is a parallel variant of method
     * {@link #forEach(Accumulator, LongTTriConsumer)}
     *
     * @param &lt;A&gt;    accumulator type
     * @param acc    the accumulator into which information will be stored
     * @param action the action to perform with respect to each index/T element
     *               contained in this collection
     */
    public &lt;A&gt; void parallelForEach(Accumulator&lt;A&gt; acc, LongTTriConsumer&lt;T, ThreadLocalAccumulator&lt;A&gt;&gt; action) {
<span class="fc" id="L1630">        parallelForEach(Runtime.getRuntime().availableProcessors(), acc, action);</span>
<span class="fc" id="L1631">    }</span>

    /**
     * Performs the provided action on each element of this collection in parallel
     * using the provided {@link ExecutorService} with the specified degree of
     * parallelism. This action may involve extracting some information of type U
     * from individual elements and placing these into the Consumer (second argument
     * of the lambda expression). This {@link Consumer} used in the lambda exression
     * is obtained from the provided {@link ParallelReceiver} which will receive all
     * the U instances produced during this method. This method returns when all the
     * elements in the collection have been treated.
     *
     * @param &lt;U&gt;     type of the information extracted from individual elements
     * @param action  action to perform on individual elements of this collection,
     *                potentially extracting some information of type U and giving
     *                it to the {@link Consumer}, the second argument of the action
     * @param toStore {@link ParallelReceiver} instance which provides the
     *                {@link Consumer}s of each thread that will process the
     *                elements of this library and receive all the U elements
     *                extracted from this collection
     */
    public &lt;U&gt; void parallelForEach(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            final ParallelReceiver&lt;? super U&gt; toStore) {
<span class="fc" id="L1654">        parallelForEach(defaultParallelism(), action, toStore);</span>
<span class="fc" id="L1655">    }</span>

    /**
     * Performs the provided action on every eleement in the collection in parallel
     * using the apgas finish-async. Returns when all operations have finished.
     *
     * @param action to action to perform on element contained in this instance
     */
    public void parallelForEach(Consumer&lt;? super T&gt; action) {
<span class="fc" id="L1664">        parallelForEach(defaultParallelism(), action);</span>
<span class="fc" id="L1665">    }</span>

    /**
     * Accumulates information into the provided accumulator with the specified
     * level of parallelism, using this collection's element as a source.
     *
     * @param parallelism number of threads to use to perform this computation
     * @param acc         the accumulator into which information will be stored
     * @param action      the action to perform with respect to each T element
     *                    contained in the this collection
     */
    public &lt;A&gt; void parallelForEach(int parallelism, Accumulator&lt;A&gt; acc,
            BiConsumer&lt;T, ThreadLocalAccumulator&lt;A&gt;&gt; action) {
<span class="nc" id="L1678">        final List&lt;ThreadLocalAccumulator&lt;A&gt;&gt; accumulators = acc.obtainThreadLocalAccumulators(parallelism);</span>
<span class="nc" id="L1679">        final List&lt;ChunkedList&lt;T&gt;&gt; separated = separate(parallelism);</span>
<span class="nc" id="L1680">        finish(() -&gt; {</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">            for (int threadId = 0; threadId &lt; parallelism; threadId++) {</span>
<span class="nc" id="L1682">                final ThreadLocalAccumulator&lt;A&gt; tla = accumulators.get(threadId);</span>
<span class="nc" id="L1683">                final ChunkedList&lt;T&gt; toProcess = separated.get(threadId);</span>
<span class="nc" id="L1684">                async(() -&gt; {</span>
<span class="nc" id="L1685">                    toProcess.forEach((l, t) -&gt; {</span>
<span class="nc" id="L1686">                        action.accept(t, tla);</span>
<span class="nc" id="L1687">                    });</span>
<span class="nc" id="L1688">                });</span>
            }
<span class="nc" id="L1690">        });</span>
<span class="nc" id="L1691">    }</span>

    /**
     * Accumulates information into the provided accumulator in parallel using the
     * specified parallelism level, using this collection's index/element as a
     * source
     *
     * @param &lt;A&gt;         type of the accumulator
     * @param parallelism number of threads to use to perform this computation
     * @param acc         the accumulator into which information will be stored
     * @param action      the action to perform with respect to each index/T element
     *                    contained in the this collection
     */
    public &lt;A&gt; void parallelForEach(int parallelism, Accumulator&lt;A&gt; acc,
            LongTTriConsumer&lt;T, ThreadLocalAccumulator&lt;A&gt;&gt; action) {
<span class="fc" id="L1706">        final List&lt;ThreadLocalAccumulator&lt;A&gt;&gt; accumulators = acc.obtainThreadLocalAccumulators(parallelism);</span>
<span class="fc" id="L1707">        final List&lt;ChunkedList&lt;T&gt;&gt; separated = separate(parallelism);</span>
<span class="fc" id="L1708">        finish(() -&gt; {</span>
<span class="fc bfc" id="L1709" title="All 2 branches covered.">            for (int threadId = 0; threadId &lt; parallelism; threadId++) {</span>
<span class="fc" id="L1710">                final ThreadLocalAccumulator&lt;A&gt; tla = accumulators.get(threadId);</span>
<span class="fc" id="L1711">                final ChunkedList&lt;T&gt; toProcess = separated.get(threadId);</span>
<span class="fc" id="L1712">                async(() -&gt; {</span>
<span class="fc" id="L1713">                    toProcess.forEach((l, t) -&gt; {</span>
<span class="fc" id="L1714">                        action.accept(l, t, tla);</span>
<span class="fc" id="L1715">                    });</span>
<span class="fc" id="L1716">                });</span>
            }
<span class="fc" id="L1718">        });</span>
<span class="fc" id="L1719">    }</span>

    /**
     * This method was renamed to
     * {@link #parallelToBag(int, BiConsumer, ParallelReceiver)}.
     *
     * @param &lt;U&gt;         the type of objects produced
     * @param parallelism number of threads that will perform this action in
     *                    parallel
     * @param action      the action consisting of extracting a U object and placing
     *                    it into the provided {@link Consumer}
     * @param toStore     the parallel receiver into which U objects will be placed
     */
    @Deprecated
    public &lt;U&gt; void parallelForEach(int parallelism, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            final ParallelReceiver&lt;? super U&gt; toStore) {
<span class="fc" id="L1735">        parallelToBag(parallelism, action, toStore);</span>
<span class="fc" id="L1736">    }</span>

    /**
     * Performs the specified action on each T element of this collection in
     * parallel with the specified number of threads. Returns when all
     *
     * @param parallelism the number of threads desired
     * @param action      the action to perform on each T in the collection
     */
    public void parallelForEach(int parallelism, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L1746">        finish(() -&gt; {</span>
<span class="fc" id="L1747">            forEachParallelBody(parallelism, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L1748">                sub.forEach(action);</span>
<span class="fc" id="L1749">            });</span>
<span class="fc" id="L1750">        });</span>
<span class="fc" id="L1751">    }</span>

    /**
     * Performs the specified action on every (long) index and (T) pair contained in
     * this collection in parallel. The method returns when the action has been
     * performed on every element in this collection.
     *
     * @param parallelism the number of threads to run this
     * @param action      action taking the long index and T object mapped at this
     *                    index as parameter
     */
    public void parallelForEach(int parallelism, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L1763">        finish(() -&gt; {</span>
<span class="fc" id="L1764">            forEachParallelBody(parallelism, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L1765">                sub.forEach(action);</span>
<span class="fc" id="L1766">            });</span>
<span class="fc" id="L1767">        });</span>
<span class="fc" id="L1768">    }</span>

    /**
     * Performs the provided action on every (long) key and (T) value in the
     * collection in parallel using the apgas finish-async. Returns when all
     * operations have finished
     *
     * @param action to action to perform on each pair of ({@code long} key and (T)
     *               element contained in this instance
     */
    public void parallelForEach(LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L1779">        parallelForEach(defaultParallelism(), action);</span>
<span class="fc" id="L1780">    }</span>

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default in this library
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public boolean parallelReduce(BoolReducer.Op op, Function&lt;T, Boolean&gt; extractFunc) {
<span class="nc" id="L1792">        return parallelReduce(defaultParallelism(), op, extractFunc);</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default in this library
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public double parallelReduce(DoubleReducer.Op op, Function&lt;T, Double&gt; extractFunc) {
<span class="nc" id="L1805">        return parallelReduce(defaultParallelism(), op, extractFunc);</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default in this library
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public float parallelReduce(FloatReducer.Op op, Function&lt;T, Float&gt; extractFunc) {
<span class="nc" id="L1818">        return parallelReduce(defaultParallelism(), op, extractFunc);</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default in this library
     *
     * @param parallelism the level of parallelism (i.e. number of threads) desired
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public boolean parallelReduce(int parallelism, BoolReducer.Op op, Function&lt;T, Boolean&gt; extractFunc) {
<span class="fc" id="L1832">        final BoolReducer reducer = new BoolReducer(op);</span>
<span class="fc" id="L1833">        final ConcurrentLinkedQueue&lt;BoolReducer&gt; reducers = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L1835">        final Consumer&lt;ChunkedList&lt;T&gt;&gt; reducerAction = (c) -&gt; {</span>
            // Each thread participating will create its own R instance
<span class="fc" id="L1837">            final BoolReducer threadLocalReducer = new BoolReducer(op);</span>
            // That new instance is kept in the &quot;reducers&quot;
<span class="fc" id="L1839">            reducers.add(threadLocalReducer);</span>
            // For all elements in the assigned ChunkedList, apply the reduction
<span class="fc" id="L1841">            c.forEach(t -&gt; {</span>
<span class="fc bfc" id="L1842" title="All 2 branches covered.">                if (threadLocalReducer.reduce(extractFunc.apply(t))) { // determined result in the middle.</span>
<span class="fc" id="L1843">                    return;</span>
                }
<span class="fc" id="L1845">            });</span>
<span class="fc" id="L1846">        };</span>

<span class="fc" id="L1848">        finish(() -&gt; {</span>
<span class="fc" id="L1849">            forEachParallelBody(parallelism, reducerAction);</span>
<span class="fc" id="L1850">        });</span>

        // All threads have processed their share. We now merge all R instances into the
        // original instance
<span class="fc bfc" id="L1854" title="All 2 branches covered.">        while (!reducers.isEmpty()) {</span>
<span class="fc" id="L1855">            final boolean finish = reducer.reduce(reducers.poll().value());</span>
<span class="fc bfc" id="L1856" title="All 2 branches covered.">            if (finish) {</span>
<span class="fc" id="L1857">                break;</span>
            }
<span class="fc" id="L1859">        }</span>
<span class="fc" id="L1860">        return reducer.value();</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default
     *
     * @param parallelism the level of parallelism (i.e. number of threads) desired
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public double parallelReduce(int parallelism, DoubleReducer.Op op, Function&lt;T, Double&gt; extractFunc) {
<span class="fc" id="L1874">        final DoubleReducer reducer = new DoubleReducer(op);</span>
<span class="fc" id="L1875">        final ConcurrentLinkedQueue&lt;DoubleReducer&gt; reducers = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L1877">        final Consumer&lt;ChunkedList&lt;T&gt;&gt; reducerAction = (c) -&gt; {</span>
            // Each thread participating will create its own R instance
<span class="fc" id="L1879">            final DoubleReducer threadLocalReducer = new DoubleReducer(op);</span>
            // That new instance is kept in the &quot;reducers&quot;
<span class="fc" id="L1881">            reducers.add(threadLocalReducer);</span>
            // For all elements in the assigned ChunkedList, apply the reduction
<span class="fc" id="L1883">            c.forEach(t -&gt; threadLocalReducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L1884">        };</span>

<span class="fc" id="L1886">        finish(() -&gt; {</span>
<span class="fc" id="L1887">            forEachParallelBody(parallelism, reducerAction);</span>
<span class="fc" id="L1888">        });</span>

        // All threads have processed their share. We now merge all R instances into the
        // original instance
<span class="fc bfc" id="L1892" title="All 2 branches covered.">        while (!reducers.isEmpty()) {</span>
<span class="fc" id="L1893">            reducer.reduce(reducers.poll().value());</span>
        }
<span class="fc" id="L1895">        return reducer.value();</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default
     *
     * @param parallelism the level of parallelism (i.e. number of threads) desired
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public float parallelReduce(int parallelism, FloatReducer.Op op, Function&lt;T, Float&gt; extractFunc) {
<span class="fc" id="L1909">        final FloatReducer reducer = new FloatReducer(op);</span>
<span class="fc" id="L1910">        final ConcurrentLinkedQueue&lt;FloatReducer&gt; reducers = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L1912">        final Consumer&lt;ChunkedList&lt;T&gt;&gt; reducerAction = (c) -&gt; {</span>
            // Each thread participating will create its own R instance
<span class="fc" id="L1914">            final FloatReducer threadLocalReducer = new FloatReducer(op);</span>
            // That new instance is kept in the &quot;reducers&quot;
<span class="fc" id="L1916">            reducers.add(threadLocalReducer);</span>
            // For all elements in the assigned ChunkedList, apply the reduction
<span class="fc" id="L1918">            c.forEach(t -&gt; threadLocalReducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L1919">        };</span>

<span class="fc" id="L1921">        finish(() -&gt; {</span>
<span class="fc" id="L1922">            forEachParallelBody(parallelism, reducerAction);</span>
<span class="fc" id="L1923">        });</span>

        // All threads have processed their share. We now merge all R instances into the
        // original instance
<span class="fc bfc" id="L1927" title="All 2 branches covered.">        while (!reducers.isEmpty()) {</span>
<span class="fc" id="L1928">            reducer.reduce(reducers.poll().value());</span>
        }
<span class="fc" id="L1930">        return reducer.value();</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default
     *
     * @param parallelism the level of parallelism (i.e. number of threads) desired
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public int parallelReduce(int parallelism, IntReducer.Op op, Function&lt;T, Integer&gt; extractFunc) {
<span class="fc" id="L1944">        final IntReducer reducer = new IntReducer(op);</span>
<span class="fc" id="L1945">        final ConcurrentLinkedQueue&lt;IntReducer&gt; reducers = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L1947">        final Consumer&lt;ChunkedList&lt;T&gt;&gt; reducerAction = (c) -&gt; {</span>
            // Each thread participating will create its own R instance
<span class="fc" id="L1949">            final IntReducer threadLocalReducer = new IntReducer(op);</span>
            // That new instance is kept in the &quot;reducers&quot;
<span class="fc" id="L1951">            reducers.add(threadLocalReducer);</span>
            // For all elements in the assigned ChunkedList, apply the reduction
<span class="fc" id="L1953">            c.forEach(t -&gt; threadLocalReducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L1954">        };</span>

<span class="fc" id="L1956">        finish(() -&gt; {</span>
<span class="fc" id="L1957">            forEachParallelBody(parallelism, reducerAction);</span>
<span class="fc" id="L1958">        });</span>

        // All threads have processed their share. We now merge all R instances into the
        // original instance
<span class="fc bfc" id="L1962" title="All 2 branches covered.">        while (!reducers.isEmpty()) {</span>
<span class="fc" id="L1963">            reducer.reduce(reducers.poll().value());</span>
        }
<span class="fc" id="L1965">        return reducer.value();</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default
     *
     * @param parallelism the level of parallelism (i.e. number of threads) desired
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public long parallelReduce(int parallelism, LongReducer.Op op, Function&lt;T, Long&gt; extractFunc) {
<span class="fc" id="L1979">        final LongReducer reducer = new LongReducer(op);</span>
<span class="fc" id="L1980">        final ConcurrentLinkedQueue&lt;LongReducer&gt; reducers = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L1982">        final Consumer&lt;ChunkedList&lt;T&gt;&gt; reducerAction = (c) -&gt; {</span>
            // Each thread participating will create its own R instance
<span class="fc" id="L1984">            final LongReducer threadLocalReducer = new LongReducer(op);</span>
            // That new instance is kept in the &quot;reducers&quot;
<span class="fc" id="L1986">            reducers.add(threadLocalReducer);</span>
            // For all elements in the assigned ChunkedList, apply the reduction
<span class="fc" id="L1988">            c.forEach(t -&gt; threadLocalReducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L1989">        };</span>

<span class="fc" id="L1991">        finish(() -&gt; {</span>
<span class="fc" id="L1992">            forEachParallelBody(parallelism, reducerAction);</span>
<span class="fc" id="L1993">        });</span>

        // All threads have processed their share. We now merge all R instances into the
        // original instance
<span class="fc bfc" id="L1997" title="All 2 branches covered.">        while (!reducers.isEmpty()) {</span>
<span class="fc" id="L1998">            reducer.reduce(reducers.poll().value());</span>
        }
<span class="fc" id="L2000">        return reducer.value();</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements present in this collection.
     *
     * @param &lt;R&gt;         the type of the reducer used
     * @param parallelism the level of parallelism (i.e. number of threads) desired
     * @param reducer     the instance into which the result will be stored
     * @return the instance provided as parameter containing the result of the
     *         reduction
     */
    public &lt;R extends Reducer&lt;R, T&gt;&gt; R parallelReduce(int parallelism, R reducer) {
<span class="fc" id="L2014">        final ConcurrentLinkedQueue&lt;R&gt; reducers = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L2016">        final Consumer&lt;ChunkedList&lt;T&gt;&gt; reducerAction = (c) -&gt; {</span>
            // Each thread participating will create its own R instance
<span class="fc" id="L2018">            final R threadLocalReducer = reducer.newReducer();</span>
            // That new instance is kept in the &quot;reducers&quot;
<span class="fc" id="L2020">            reducers.add(threadLocalReducer);</span>

            // For all elements in the assigned ChunkedList, apply the reduction
<span class="fc" id="L2023">            c.forEach(t -&gt; threadLocalReducer.reduce(t));</span>
<span class="fc" id="L2024">        };</span>

<span class="fc" id="L2026">        finish(() -&gt; {</span>
<span class="fc" id="L2027">            forEachParallelBody(parallelism, reducerAction);</span>
<span class="fc" id="L2028">        });</span>

        // All threads have processed their share. We now merge all R instances into the
        // original instance
<span class="fc bfc" id="L2032" title="All 2 branches covered.">        while (!reducers.isEmpty()) {</span>
<span class="fc" id="L2033">            reducer.merge(reducers.poll());</span>
        }

<span class="fc" id="L2036">        return reducer;</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default
     *
     * @param parallelism the level of parallelism (i.e. number of threads) desired
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public short parallelReduce(int parallelism, ShortReducer.Op op, Function&lt;T, Short&gt; extractFunc) {
<span class="fc" id="L2050">        final ShortReducer reducer = new ShortReducer(op);</span>
<span class="fc" id="L2051">        final ConcurrentLinkedQueue&lt;ShortReducer&gt; reducers = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L2053">        final Consumer&lt;ChunkedList&lt;T&gt;&gt; reducerAction = (c) -&gt; {</span>
            // Each thread participating will create its own R instance
<span class="fc" id="L2055">            final ShortReducer threadLocalReducer = new ShortReducer(op);</span>
            // That new instance is kept in the &quot;reducers&quot;
<span class="fc" id="L2057">            reducers.add(threadLocalReducer);</span>
            // For all elements in the assigned ChunkedList, apply the reduction
<span class="fc" id="L2059">            c.forEach(t -&gt; threadLocalReducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L2060">        };</span>

<span class="fc" id="L2062">        finish(() -&gt; {</span>
<span class="fc" id="L2063">            forEachParallelBody(parallelism, reducerAction);</span>
<span class="fc" id="L2064">        });</span>

        // All threads have processed their share. We now merge all R instances into the
        // original instance
<span class="fc bfc" id="L2068" title="All 2 branches covered.">        while (!reducers.isEmpty()) {</span>
<span class="fc" id="L2069">            reducer.reduce(reducers.poll().value());</span>
        }
<span class="fc" id="L2071">        return reducer.value();</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default in this library
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public int parallelReduce(IntReducer.Op op, Function&lt;T, Integer&gt; extractFunc) {
<span class="nc" id="L2084">        return parallelReduce(defaultParallelism(), op, extractFunc);</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default in this library
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public long parallelReduce(LongReducer.Op op, Function&lt;T, Long&gt; extractFunc) {
<span class="nc" id="L2097">        return parallelReduce(defaultParallelism(), op, extractFunc);</span>
    }

    /**
     * Performs a parallel reduction on all the elements of contained in this
     * {@link ChunkedList}.
     *
     * @param &lt;R&gt;     the type of the reducer used
     * @param reducer the instance into which the final result will be stored
     * @return the instance provided as parameter containing the result of the
     *         reduction
     */
    public &lt;R extends Reducer&lt;R, T&gt;&gt; R parallelReduce(R reducer) {
<span class="fc" id="L2110">        return parallelReduce(Runtime.getRuntime().availableProcessors(), reducer);</span>
    }

    /**
     * Performs a parallel reduction with the specified level of parallelism on the
     * elements contained in this {@link ChunkedList}, using an operation provided
     * by default in this library
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public short parallelReduce(ShortReducer.Op op, Function&lt;T, Short&gt; extractFunc) {
<span class="nc" id="L2123">        return parallelReduce(defaultParallelism(), op, extractFunc);</span>
    }

    /**
     * Extracts an U object from each (T) object contained in this collection and
     * places it into the provided {@link ParallelReceiver}. This action is
     * performed in parallel by the specified number of threads.
     *
     * @param &lt;U&gt;         type of the object obtained from individual objects of
     *                    this collection and placed into the
     *                    {@link ParallelReceiver} given as argument
     * @param parallelism number of threads to run this computation in parallel on
     *                    the elements contained in this collection
     * @param action      action consisting of extracting a U object and placing
     *                    into the {@link Consumer} provided as second argument to
     *                    this action.
     * @param bag         {@link ParallelReceiver} in which all U objects produced
     *                    during this operation will be stored.
     */
    public &lt;U&gt; void parallelToBag(int parallelism, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
            final ParallelReceiver&lt;? super U&gt; bag) {
<span class="fc" id="L2144">        finish(() -&gt; {</span>
<span class="fc" id="L2145">            forEachParallelBody(parallelism, (ChunkedList&lt;T&gt; sub) -&gt; {</span>
<span class="fc" id="L2146">                sub.toBag(action, bag.getReceiver());</span>
<span class="fc" id="L2147">            });</span>
<span class="fc" id="L2148">        });</span>
<span class="fc" id="L2149">    }</span>

    /**
     * Return the ranges on which the chunks of this instance are defined in a
     * collection
     *
     * @return the {@link LongRange}s on which each {@link Chunk} contains in this
     *         instance are defined, in a collection
     */
    public Collection&lt;LongRange&gt; ranges() {
<span class="fc" id="L2159">        return chunks.keySet();</span>
    }

    /**
     * Sequentially reduces all the elements contained in this {@link ChunkedList},
     * using an operation provided by default
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public boolean reduce(BoolReducer.Op op, Function&lt;T, Boolean&gt; extractFunc) {
<span class="fc" id="L2171">        final BoolReducer reducer = new BoolReducer(op);</span>
<span class="fc" id="L2172">        forEach((t) -&gt; {</span>
<span class="fc bfc" id="L2173" title="All 2 branches covered.">            if (reducer.reduce(extractFunc.apply(t))) { // the result is determined in the middle.</span>
<span class="fc" id="L2174">                return;</span>
            }
<span class="fc" id="L2176">        });</span>
<span class="fc" id="L2177">        return reducer.value();</span>
    }

    /**
     * Sequentially reduces all the elements contained in this {@link ChunkedList},
     * using an operation provided by default
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public double reduce(DoubleReducer.Op op, Function&lt;T, Double&gt; extractFunc) {
<span class="fc" id="L2189">        final DoubleReducer reducer = new DoubleReducer(op);</span>
<span class="fc" id="L2190">        forEach(t -&gt; reducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L2191">        return reducer.value();</span>
    }

    /**
     * Sequentially reduces all the elements contained in this {@link ChunkedList},
     * using an operation provided by default
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public float reduce(FloatReducer.Op op, Function&lt;T, Float&gt; extractFunc) {
<span class="fc" id="L2203">        final FloatReducer reducer = new FloatReducer(op);</span>
<span class="fc" id="L2204">        forEach(t -&gt; reducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L2205">        return reducer.value();</span>
    }

    /**
     * Sequentially reduces all the elements contained in this {@link ChunkedList},
     * using an operation provided by default
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public int reduce(IntReducer.Op op, Function&lt;T, Integer&gt; extractFunc) {
<span class="fc" id="L2217">        final IntReducer reducer = new IntReducer(op);</span>
<span class="fc" id="L2218">        forEach(t -&gt; reducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L2219">        return reducer.value();</span>
    }

    /**
     * Sequentially reduces all the elements contained in this {@link ChunkedList},
     * using an operation provided by default
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public long reduce(LongReducer.Op op, Function&lt;T, Long&gt; extractFunc) {
<span class="fc" id="L2231">        final LongReducer reducer = new LongReducer(op);</span>
<span class="fc" id="L2232">        forEach(t -&gt; reducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L2233">        return reducer.value();</span>
    }

    /**
     * Sequentially reduces all the elements contained in this {@link ChunkedList}
     * using the reducer provided as parameter
     *
     * @param &lt;R&gt;     type of the reducer
     * @param reducer reducer to be used to reduce this parameter
     * @return the reducer provided as parameter after the reduction has completed
     */
    public &lt;R extends Reducer&lt;R, T&gt;&gt; R reduce(R reducer) {
<span class="fc" id="L2245">        forEach(t -&gt; reducer.reduce(t));</span>
<span class="fc" id="L2246">        return reducer;</span>
    }

    /**
     * Sequentially reduces all the elements contained in this {@link ChunkedList},
     * using an operation provided by default
     *
     * @param op          specifies the type of reduction operation
     * @param extractFunc defines the value to be reduced
     * @return the value after the reduction has completed
     */
    public short reduce(ShortReducer.Op op, Function&lt;T, Short&gt; extractFunc) {
<span class="fc" id="L2258">        final ShortReducer reducer = new ShortReducer(op);</span>
<span class="fc" id="L2259">        forEach(t -&gt; reducer.reduce(extractFunc.apply(t)));</span>
<span class="fc" id="L2260">        return reducer.value();</span>
    }

    /**
     * Sequentially reduces all the Chunks of Ts contained in this
     * {@link ChunkedList} into the provided reducer and returns that reducer.
     *
     * @param &lt;R&gt;     the type of the reducer
     * @param reducer the reducer into which this bag needs to be reduced
     * @return the reducer given as parameter after it has been applied to every
     *         list in this {@link Bag}
     */
    public &lt;R extends Reducer&lt;R, RangedList&lt;T&gt;&gt;&gt; R reduceChunk(R reducer) {
<span class="fc" id="L2273">        forEachChunk(rl -&gt; reducer.reduce(rl));</span>
<span class="fc" id="L2274">        return reducer;</span>
    }

    /**
     * Removes and returns the chunk contained in this instance which is defined the
     * range provided as parameter. The specified range must match the exact bounds
     * of a chunk contained in this instance. If there are no chunks defined on the
     * specified range contained in this instance, returns null.
     *
     * @param range the range needs to be removed
     * @return the removed chunk, or null if there was no such chunk contained in
     *         this instance
     */
    public RangedList&lt;T&gt; remove(LongRange range) {
<span class="fc" id="L2288">        final RangedList&lt;T&gt; removed = chunks.remove(range);</span>
<span class="fc bfc" id="L2289" title="All 2 branches covered.">        if (removed != null) {</span>
<span class="fc" id="L2290">            size.addAndGet(-removed.size());</span>
        }
<span class="fc" id="L2292">        return removed;</span>
    }

    /**
     * Removes and returns a chunk whose {@link LongRange} on which it is defined
     * matches the one on which the provided {@link RangedList} is defined.
     *
     * @param c the chunk whose matching range needs to be removed
     * @return the removed chunk, or null if there was no such chunk contained in
     *         this instance
     * @deprecated programmers should use method {@link #remove(LongRange)} instead
     */
    @Deprecated
    public RangedList&lt;T&gt; remove(RangedList&lt;T&gt; c) {
<span class="fc" id="L2306">        return remove(c.getRange());</span>
//        final RangedList&lt;T&gt; removed = chunks.remove(c.getRange());
//        if (removed != null) {
//            size.addAndGet(-removed.size());
//        }
//        return removed;
    }

    /**
     * Separates the contents of the ChunkedList in &lt;em&gt;n&lt;/em&gt; parts. This can be
     * used to apply a forEach method in parallel using 'n' threads for instance.
     * The method returns &lt;em&gt;n&lt;/em&gt; lists, each containing a {@link ChunkedList} of
     * &lt;em&gt;T&lt;/em&gt;s.
     *
     * @param n the number of parts in which to split the ChunkedList
     * @return &lt;em&gt;n&lt;/em&gt; {@link ChunkedList}s containing the same number of
     *         elements
     */
    public List&lt;ChunkedList&lt;T&gt;&gt; separate(int n) {
<span class="fc" id="L2325">        final long totalNum = size();</span>
<span class="fc" id="L2326">        final long rem = totalNum % n;</span>
<span class="fc" id="L2327">        final long quo = totalNum / n;</span>
<span class="fc" id="L2328">        final List&lt;ChunkedList&lt;T&gt;&gt; result = new ArrayList&lt;&gt;(n);</span>
<span class="fc bfc" id="L2329" title="All 2 branches covered.">        if (chunks.isEmpty()) {</span>
<span class="fc" id="L2330">            return result;</span>
        }
<span class="fc" id="L2332">        RangedList&lt;T&gt; c = chunks.firstEntry().getValue();</span>
<span class="fc" id="L2333">        long used = 0;</span>

<span class="fc bfc" id="L2335" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2336">            final ChunkedList&lt;T&gt; r = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L2337">            result.add(r);</span>
<span class="fc bfc" id="L2338" title="All 2 branches covered.">            long rest = quo + ((i &lt; rem) ? 1 : 0);</span>
<span class="fc bfc" id="L2339" title="All 2 branches covered.">            while (rest &gt; 0) {</span>
<span class="fc" id="L2340">                final LongRange range = c.getRange();</span>
<span class="fc bfc" id="L2341" title="All 2 branches covered.">                if (c.size() - used &lt; rest) { // not enough</span>
<span class="fc" id="L2342">                    final long from = range.from + used;</span>
<span class="fc bfc" id="L2343" title="All 2 branches covered.">                    if (from != range.to) {</span>
<span class="fc" id="L2344">                        r.add(c.subList(from, range.to));</span>
                    }
<span class="fc" id="L2346">                    rest -= c.size() - used;</span>
<span class="fc" id="L2347">                    used = 0;</span>
                    // TODO should we use iterator instead ?
<span class="fc" id="L2349">                    c = chunks.higherEntry(range).getValue();</span>
<span class="fc" id="L2350">                } else {</span>
<span class="fc" id="L2351">                    final long from = range.from + used;</span>
<span class="fc" id="L2352">                    final long to = from + rest;</span>
<span class="pc bpc" id="L2353" title="1 of 2 branches missed.">                    if (from != to) {</span>
<span class="fc" id="L2354">                        r.add(c.subList(from, to));</span>
                    }
<span class="fc" id="L2356">                    used += rest;</span>
<span class="fc" id="L2357">                    rest = 0;</span>
                }

<span class="fc" id="L2360">            }</span>
        }
<span class="fc" id="L2362">        return result;</span>
    }

    /**
     * Finds the matching chunk and sets the provided value at the specified index.
     *
     * @param i     the index at which the value should be set
     * @param value the value to set at the specified index
     * @return the former value stored at this index, {@code null} if there were no
     *         previous value or if the previous value was {@code null}
     */
    public T set(long i, T value) {
<span class="fc" id="L2374">        final LongRange r = new LongRange(i);</span>
<span class="fc" id="L2375">        final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; entry = chunks.floorEntry(r);</span>
<span class="pc bpc" id="L2376" title="1 of 4 branches missed.">        if (entry == null || !entry.getKey().contains(i)) {</span>
//            entry = chunks.ceilingEntry(r);
//            if (entry == null || !entry.getKey().contains(i)) {
<span class="fc" id="L2379">            throw new IndexOutOfBoundsException(&quot;ChunkedList: index &quot; + i + &quot; is not with the range of any chunk&quot;);</span>
//            }
        }
<span class="fc" id="L2382">        final RangedList&lt;T&gt; chunk = entry.getValue();</span>
<span class="fc" id="L2383">        return chunk.set(i, value);</span>
    }

    /**
     * Return to total number of mappings contained in this instance, i.e. the sum
     * of the size of each individual {@link Chunk} this instance holds.
     *
     * @return size of this instance as a {@code long}
     */
    public long size() {
<span class="fc" id="L2393">        return size.get();</span>
    }

    /**
     * TODO : Still not sure if it works.
     */
    public ArrayList&lt;RangedList&lt;T&gt;&gt; splitChunks(LongRange range) {
<span class="fc" id="L2400">        final ArrayList&lt;RangedList&lt;T&gt;&gt; chunksToRet = new ArrayList&lt;&gt;();</span>
        // Two cases to handle here, whether the specified range fits into a single
        // existing chunk or whether it spans multiple chunks
<span class="fc" id="L2403">        final Map.Entry&lt;LongRange, RangedList&lt;T&gt;&gt; lowSideEntry = chunks.floorEntry(range);</span>
<span class="pc bpc" id="L2404" title="1 of 6 branches missed.">        if (lowSideEntry != null &amp;&amp; lowSideEntry.getKey().from &lt;= range.from &amp;&amp; range.to &lt;= lowSideEntry.getKey().to) {</span>
            // The given range is included in (or identical) to an existing Chunk.
            // Only one Chunk needs to be split (if any).
<span class="fc bfc" id="L2407" title="All 2 branches covered.">            while (!attemptSplitChunkAtTwoPoints(range)) {</span>
                ;
            }
<span class="fc" id="L2410">            chunksToRet.add(chunks.get(range));</span>
        } else {
            // The given range spans multiple ranges, the check on whether chunks need to be
            // split needs to be done separately on single points
<span class="fc" id="L2414">            final LongRange leftSplit = new LongRange(range.from);</span>
<span class="fc" id="L2415">            final LongRange rightSplit = new LongRange(range.to);</span>

<span class="pc bpc" id="L2417" title="1 of 2 branches missed.">            while (!attemptSplitChunkAtSinglePoint(leftSplit)) {</span>
                ;
            }
<span class="pc bpc" id="L2420" title="1 of 2 branches missed.">            while (!attemptSplitChunkAtSinglePoint(rightSplit)) {</span>
                ;
            }

            // Accumulate all the chunks that are spanned by the range specified as
            // parameter
<span class="fc" id="L2426">            final NavigableSet&lt;LongRange&gt; keySet = chunks.keySet();</span>
<span class="fc" id="L2427">            LongRange rangeToAdd = keySet.ceiling(range);</span>

<span class="fc bfc" id="L2429" title="All 4 branches covered.">            while (rangeToAdd != null &amp;&amp; rangeToAdd.to &lt;= range.to) {</span>
<span class="fc" id="L2430">                chunksToRet.add(chunks.get(rangeToAdd));</span>
<span class="fc" id="L2431">                rangeToAdd = keySet.higher(rangeToAdd);</span>
            }
        }

<span class="fc" id="L2435">        return chunksToRet;</span>
    }

    /**
     * TODO : Still not sure if it works.
     */
    public ChunkedList&lt;T&gt; subList(LongRange range) {
<span class="fc" id="L2442">        final ChunkedList&lt;T&gt; sub = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L2443">        LongRange result = range.findOverlap(chunks);</span>
        while (true) {
<span class="fc bfc" id="L2445" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc" id="L2446">                break;</span>
            }
<span class="fc" id="L2448">            final LongRange inter = range.intersection(result);</span>
<span class="pc bpc" id="L2449" title="1 of 2 branches missed.">            if (inter != null) {</span>
<span class="fc" id="L2450">                sub.add(new RangedListView&lt;&gt;(chunks.get(result), inter));</span>
            }
<span class="fc bfc" id="L2452" title="All 2 branches covered.">            if (result.to &gt;= range.to) {</span>
<span class="fc" id="L2453">                break;</span>
            }
<span class="fc" id="L2455">            result = chunks.higherKey(result);</span>
<span class="fc" id="L2456">        }</span>
<span class="fc" id="L2457">        return sub;</span>
    }

    /**
     * Returns a continuous RangedList with the given {@code range} from this
     * {@link ChunkedList}
     *
     * @param range range of the desired view
     * @return {@code null} if the specified range is not present in this
     *         {@link ChunkedList}
     */
    public RangedList&lt;T&gt; subList1(LongRange range) {
<span class="nc" id="L2469">        final LongRange result = range.findOverlap(chunks);</span>
<span class="nc bnc" id="L2470" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L2471">            return null;</span>
        }
<span class="nc bnc" id="L2473" title="All 2 branches missed.">        if (result.contains(range)) {</span>
<span class="nc" id="L2474">            return chunks.get(result).subList(range);</span>
        }
<span class="nc" id="L2476">        return null;</span>
    }

    /**
     * Performs the provided action on each element of this collection. As part of
     * this operation, some information of type U can be created or extracted from
     * elements and potentially stored into the provided collection using the
     * Consumer of U (second argument of the lambda expression). These elements will
     * be added using method {@link Collection#add(Object)}.
     * &lt;p&gt;
     * As a variant, you may also directly supply a Consumer&amp;lt;U&amp;gt; rather than a
     * collection using method {@link #toBag(BiConsumer, Consumer)}
     *
     * @param &lt;U&gt;     the type of the information to extract
     * @param action  action to perform on each element of the collection
     * @param toStore the collection in which the information extracted will be
     *                stored
     * @see #toBag(BiConsumer, Consumer)
     */
    public &lt;U&gt; void toBag(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, final Collection&lt;? super U&gt; toStore) {
<span class="fc" id="L2496">        final Consumer&lt;? super U&gt; consumer = u -&gt; toStore.add(u);</span>
<span class="fc" id="L2497">        toBag(action, consumer);</span>
<span class="fc" id="L2498">    }</span>

    /**
     * Performs the provided action on each element of this collection. As part of
     * this operation, some information of type U can be created or extracted from
     * elements and given to the Consumer&amp;lt;U&amp;gt; (second argument of the lambda
     * expression). This {@link Consumer} available in the lambda expression is the
     * one given as second parameter of this method.
     * &lt;p&gt;
     * As an alternative, you can use method {@link #toBag(BiConsumer, Collection)}
     * to provide a {@link Collection} rather than a {@link Consumer} as the second
     * argument of the method.
     *
     * @param &lt;U&gt;      the type of the result extracted from the elements in this
     *                 collection
     * @param action   the action to perform on each element of this collection
     * @param receiver the receiver which will accept the U instances extracted from
     *                 the elements of this collection
     */
    public &lt;U&gt; void toBag(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, Consumer&lt;? super U&gt; receiver) {
<span class="fc bfc" id="L2518" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L2519">            c.forEach(t -&gt; action.accept(t, receiver));</span>
<span class="fc" id="L2520">        }</span>
<span class="fc" id="L2521">    }</span>

    /**
     * Performs the provided action sequentially on the instances contained by this
     * {@link ChunkedList}, allowing for the by-product of the operation to be
     * stored in the specified {@link ParallelReceiver}.
     * &lt;p&gt;
     * This method is necessary as the manner in which instances are placed inside a
     * {@link ParallelReceiver} differs from that of a normal collection. Although
     * the features that handle parallel insertion of values are not leveraged in
     * this sequential method, the preparations needed to insert instances into the
     * {@link ParallelReceiver} remain necessary.
     *
     * @param &lt;U&gt;    the type of the data produced from the instances contained in
     *               this collection and stored in the provided
     *               {@link ParallelReceiver}
     * @param action the action performed on all the elements contained in this
     *               collection. U instances may be created and given to the
     *               Consumer&amp;lt;U&amp;gt; as part of this action
     * @param bag    the parallel receiver which will receive all the U instances
     *               which are created as part of the action applied on the elements
     *               of this collection
     */
    public &lt;U&gt; void toBag(BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action, ParallelReceiver&lt;? super U&gt; bag) {
<span class="fc" id="L2545">        final Consumer&lt;? super U&gt; receiver = bag.getReceiver();</span>
<span class="fc" id="L2546">        toBag(action, receiver);</span>
<span class="fc" id="L2547">    }</span>

    @Override
    public String toString() {
<span class="fc" id="L2551">        final StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L2552">        sb.append(&quot;[ChunkedList(&quot; + chunks.size() + &quot;)&quot;);</span>
<span class="fc bfc" id="L2553" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; c : chunks.values()) {</span>
<span class="fc" id="L2554">            sb.append(&quot;,&quot; + c);</span>
<span class="fc" id="L2555">        }</span>
<span class="fc" id="L2556">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L2557">        return sb.toString();</span>
    }

    private void waitNfutures(List&lt;Future&lt;?&gt;&gt; futures) {
<span class="fc bfc" id="L2561" title="All 2 branches covered.">        for (final Future&lt;?&gt; f : futures) {</span>
            try {
<span class="fc" id="L2563">                f.get();</span>
<span class="nc" id="L2564">            } catch (InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L2565">                throw new ParallelExecutionException(&quot;[ChunkedList] exception raised by worker threads.&quot;, e);</span>
<span class="fc" id="L2566">            }</span>
<span class="fc" id="L2567">        }</span>
<span class="fc" id="L2568">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>