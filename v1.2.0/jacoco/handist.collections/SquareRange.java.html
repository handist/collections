<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SquareRange.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">SquareRange.java</span></div><h1>SquareRange.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentSkipListMap;

import handist.collections.function.SquareIndexConsumer;

/**
 * Class {@link SquareRange} describes an interval over {@code long} values.
 * &lt;p&gt;
 * The lower bound is included and the upper bound is excluded from the
 * interval, meaning that for two {@code long} values a and b (a&amp;lt;b), all the
 * {@code long} values l such that a &amp;le; l &amp;lt; b are contained within the
 * {@link SquareRange} [a,b).
 * &lt;p&gt;
 * It is possible to create &quot;empty&quot; {@link SquareRange} instances where the
 * lower bound is equal to the upper bound. In this case it is considered that
 * there are no {@code long} values included in the {@link SquareRange}.
 */
public class SquareRange implements Serializable {

    /** Serial Version UID */
    private static final long serialVersionUID = 6430187870603427655L;

    /**
     * Splits the {@link SquareRange} provided in the list into &lt;em&gt;n&lt;/em&gt; lists of
     * {@link SquareRange} instances such that the accumulated size of each list's
     * {@link SquareRange} are the same.
     * &lt;p&gt;
     * To achieve this, {@link SquareRange} instances may be split into several
     * instances that will placed in different lists.
     * &lt;p&gt;
     * The {@link SquareRange} instances given as parameter are not
     *
     * @param n            number of lists of equal sizes
     * @param squareRanges {@link SquareRange} instances to distribute into the
     *                     lists
     * @return lists of {@link SquareRange} instances of equivalent
     */
    public static List&lt;List&lt;SquareRange&gt;&gt; splitList(int n, List&lt;SquareRange&gt; squareRanges) {
<span class="nc" id="L53">        throw new UnsupportedOperationException(&quot;not implemented yet&quot;);</span>
    }

    /** the range of the first dimension */
    public final LongRange outer;

    /** the range of the second dimension */
    public final LongRange inner;

    // TODO more variations...
    /**
     * the shape formed by inner and outer becomes uppertriangle
     */
    boolean isUpperTriangle;
    /** */
    long triangleDiff;

    /**
     * Constructs a LongRange with the provided parameters.
     *
     * @param outer the range of the first range (outer loop)
     * @param inner the range of the second dimension (inner loop#
     * @throws IllegalArgumentException if the range of the first or the second
     *                                  dimension is null
     */
<span class="fc" id="L78">    public SquareRange(LongRange outer, LongRange inner) {</span>
<span class="fc" id="L79">        this.outer = outer;</span>
<span class="fc" id="L80">        this.inner = inner;</span>
<span class="fc" id="L81">        this.isUpperTriangle = false;</span>
<span class="fc" id="L82">    }</span>

    /**
     * Constructs a LongRange with the provided parameters.
     *
     * @param outer           the range of the first range (outer loop)
     * @param inner           the range of the second dimension (inner loop#
     * @param isUpperTriangle if true, the shape formed by inner and outer becomes
     *                        uppertriangle not square. the same index value of
     *                        inner and outer is not included.
     * @throws IllegalArgumentException if the range of the first or the second
     *                                  dimension is null
     */
<span class="fc" id="L95">    public SquareRange(LongRange outer, LongRange inner, boolean isUpperTriangle) {</span>
<span class="fc" id="L96">        this.outer = outer;</span>
<span class="fc" id="L97">        this.inner = inner;</span>
<span class="fc" id="L98">        this.isUpperTriangle = isUpperTriangle;</span>
<span class="fc" id="L99">        this.triangleDiff = inner.from - outer.from;</span>
<span class="fc" id="L100">    }</span>

    /**
     * Constructs a LongRange with the provided parameters.
     *
     * @param outer           the range of the first range (outer loop)
     * @param inner           the range of the second dimension (inner loop#
     * @param isUpperTriangle iif true, the shape formed by inner and outer becomes
     *                        uppertriangle. the same index value of inner and outer
     *                        is not included.
     * @param tri             aa
     * @throws IllegalArgumentException if the range of the first or the second
     *                                  dimension is null
     */
<span class="fc" id="L114">    private SquareRange(LongRange outer, LongRange inner, boolean isUpperTriangle, long tri) {</span>
<span class="fc" id="L115">        this.outer = outer;</span>
<span class="fc" id="L116">        this.inner = inner;</span>
<span class="fc" id="L117">        this.isUpperTriangle = isUpperTriangle;</span>
<span class="fc" id="L118">        this.triangleDiff = tri;</span>
<span class="fc" id="L119">    }</span>

    /**
     * Returns the range of non-empty columns at the specified row
     *
     * @param row the index of the row within this squared range
     * @return the range of non-empty columns at the specified row
     */
    public LongRange columnRange(long row) {
<span class="fc" id="L128">        return new LongRange(startColumn(row), endColumn(row));</span>
    }

    /**
     * Indicates if the provided index point is included in this instance.
     *
     * @param outer0 the long value whose represents the outer index of the point
     * @param inner0 the long value whose represents the inner index of the point
     * @return {@code true} if the index point is included within the bounds of this
     *         {@link SquareRange}, {@code false} otherwise
     */
    public boolean contains(long outer0, long inner0) {
<span class="fc bfc" id="L140" title="All 4 branches covered.">        return outer.contains(outer0) &amp;&amp; columnRange(outer0).contains(inner0);</span>
    }

    /**
     * Indicates if the provided {@link SquareRange} is included within this
     * instance. A SquareRange is included inside the outer and inner ranges of this
     * instance contains the outer and inner ranges of the provided instance
     * respectively.
     *
     * @param range the square range whose inclusion into this instance needs to be
     *              checked
     * @return true if all the indices of the provided long range are present in
     *         this instance.
     */
    public boolean contains(SquareRange range) {
<span class="pc bpc" id="L155" title="2 of 4 branches missed.">        if (range.isUpperTriangle || this.isUpperTriangle) {</span>
<span class="nc" id="L156">            throw new UnsupportedOperationException(&quot;not implemented yet&quot;);</span>
        }
<span class="fc bfc" id="L158" title="All 4 branches covered.">        return outer.contains(range.outer) &amp;&amp; inner.contains(range.inner);</span>
    }

    /**
     * Alternative to {@link #contains(long, long)} which throws an exception is the
     * specified coordinates are not included within this range
     *
     * @param outer0 outer index (row index)
     * @param inner0 inner index (column index)
     * @throws IndexOutOfBoundsException if the specified coordinates are not
     *                                   contained within this square range
     * @see #contains(long, long)
     */
    public void containsCheck(long outer0, long inner0) {
<span class="fc" id="L172">        final boolean result = contains(outer0, inner0);</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (!result) {</span>
<span class="fc" id="L174">            throw new IndexOutOfBoundsException(</span>
                    &quot;ContainsCheck: &quot; + this + &quot; does not contains [&quot; + outer0 + &quot;, &quot; + inner0 + &quot;].&quot;);
        }
<span class="nc" id="L177">    }</span>

    /**
     * Alternative to {@link #contains(SquareRange)} which thrown an exception if
     * the square range of points specified as parameter are not contained within
     * this square range
     *
     * @param range square range of points to check
     * @throws IndexOutOfBoundsException if the specified square range is not
     *                                   contained within this range
     * @see #contains(SquareRange)
     */
    public void containsCheck(SquareRange range) {
<span class="fc" id="L190">        final boolean result = contains(range);</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">        if (!result) {</span>
<span class="fc" id="L192">            throw new IndexOutOfBoundsException(&quot;ContainsCheck: &quot; + this + &quot; does not contains &quot; + range);</span>
        }
<span class="fc" id="L194">    }</span>

    /**
     * Checks if the specified column is present in this square range
     *
     * @param column the column to check
     * @throws IndexOutOfBoundsException if the specified column is not present
     *                                   within this range
     */
    public void containsColumnCheck(long column) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (this.isUpperTriangle) {</span>
<span class="nc" id="L205">            throw new UnsupportedOperationException(&quot;not implemented yet&quot;);</span>
        }
<span class="nc" id="L207">        final boolean result = inner.contains(column);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (!result) {</span>
<span class="nc" id="L209">            throw new IndexOutOfBoundsException(&quot;ContainsColumnCheck: &quot; + this + &quot; does not contains column &quot; + column);</span>
        }
<span class="nc" id="L211">    }</span>

//    /**
//     * TK: needless??
//     * Compares the provided instance to this instance and returns an integer
//     * indicating if the provided instance is less than, equal to, or greater than
//     * this instance.
//     * &lt;p&gt;
//     * The implementation relies on ordering the lower bounds first before using the
//     * ordering of the upper bounds. The implemented ordering of {@link SquareRange}
//     * is consistent with equals. To illustrate the ordering, consider the following
//     * examples:
//     * &lt;ul&gt;
//     * &lt;li&gt;[0,0) &amp;lt; [0,100) &amp;lt; [1,1) &amp;lt; [1,20) &amp;lt; [1,21)
//     * &lt;li&gt;[0,0) == [0,0)
//     * &lt;li&gt;[0,10) == [0,10)
//     * &lt;/ul&gt;
//     * &lt;p&gt;
//     *
//     * @param r the object to be compared
//     * @return a negative integer, zero, or a positive integer as this object is
//     *         less than, equal to, or greater than the specified object
//     * @throws NullPointerException if the instance given as parameter is null
//     */
//    @Override
//    public int compareTo(SquareRange r) {
//        if (to &lt;= r.from &amp;&amp; from != to ) {
//          return -1;
//        } else if (r.to &lt;= from &amp;&amp; from != to) {
//          return 1;
//        }
//        // The LongRange instances overlap,
//        // We order them based on &quot;from&quot; first and &quot;to&quot; second
//        final int fromComparison = Long.compare(from, r.from);
//        return (fromComparison == 0) ? Long.compare(to, r.to) : fromComparison;
//    }

//    /**
//     * Checks if all the indices in this range are included in one of the keys
//     * contained by the provided {@code ConcurrentSkipListMap}.
//     *
//     * @param rmap the ConcurrentSkipListMap instance to check
//     * @return a LongRange key of the provided ConcurrentSkipListMap instance that
//     *         intersects this instance, or {@code null} if there are so such key.
//     */
//    public boolean contained(ConcurrentSkipListMap&lt;SquareRange, ?&gt; rmap) {
//        throws new UnsupportedOperationException(&quot;not implmented yet&quot;);
//    }

    /**
     * &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Checks if the specified row is present in this square range
     *
     * @param row the index of the row to check
     * @throws IndexOutOfBoundsException if the specified row is not contained
     *                                   within this square range
     */
    public void containsRowCheck(long row) {
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (this.isUpperTriangle) {</span>
<span class="nc" id="L269">            throw new UnsupportedOperationException(&quot;not implemented yet&quot;);</span>
        }
<span class="nc" id="L271">        final boolean result = outer.contains(row);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (!result) {</span>
<span class="nc" id="L273">            throw new IndexOutOfBoundsException(&quot;ContainsRowCheck: &quot; + this + &quot; does not contains row &quot; + row);</span>
        }
<span class="nc" id="L275">    }</span>

    /**
     * Returns the index of the last column within this square range
     *
     * @param row the index of the row considered
     * @return the index of the last column included within this range
     */
    public long endColumn(long row) {
<span class="fc" id="L284">        return inner.to;</span>
    }

    /**
     * Returns the last row with values contained within this squared range at the
     * specified column
     *
     * @param column the column considered
     * @return the index of the last row with values within this range at the
     *         specified column
     */
    public long endRow(long column) {
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (isUpperTriangle) {</span>
<span class="fc" id="L297">            return Math.min(column - triangleDiff, outer.to);</span>
        }
<span class="fc" id="L299">        return outer.to;</span>
    }

    /**
     * Checks whether the provided instance and this instance are equal. Two
     * {@link SquareRange} instances are equal if they share the same upper and
     * lower bounds.
     *
     * @return true if the provided instance and this instance are equal
     */
    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (!(o instanceof SquareRange)) {</span>
<span class="nc" id="L312">            return false;</span>
        }
<span class="fc" id="L314">        final SquareRange sqrange2 = (SquareRange) o;</span>
<span class="pc bpc" id="L315" title="4 of 8 branches missed.">        return inner.equals(sqrange2.inner) &amp;&amp; outer.equals(sqrange2.outer)</span>
                &amp;&amp; isUpperTriangle == sqrange2.isUpperTriangle &amp;&amp; triangleDiff == sqrange2.triangleDiff;
    }

    // TODO
    // I cannot find a way to convert ConcurrentSkipListMap to TreeSet (or something
    // having
    // floor/ceiling).
    // (I think TreeSet used ConcurrentSkipListMap in its implementation.)
    // prepare TreeSet version of the following methods
    // OR
    // prepare LongRangeSet having such facilities
    /**
     * Checks if this instance intersects with one of the keys contained by the
     * provided {@code ConcurrentSkipListMap&lt;LongRange, S&gt; rmap}. Returns the
     * smallest of the intersecting keys, or {@code null} if there are no such
     * intersecting key.
     *
     * @param rmap the ConcurrentSkipListMap instance to check
     * @return a LongRange key of the provided ConcurrentSkipListMap instance that
     *         intersects this instance, or {@code null} if there are so such key.
     */
    public SquareRange findOverlap(ConcurrentSkipListMap&lt;SquareRange, ?&gt; rmap) {
<span class="nc" id="L338">        final SquareRange floorKey = rmap.floorKey(this);</span>
<span class="nc bnc" id="L339" title="All 4 branches missed.">        if (floorKey != null &amp;&amp; floorKey.isOverlapped(this)) {</span>
<span class="nc" id="L340">            return floorKey;</span>
        }
<span class="nc" id="L342">        final SquareRange nextKey = rmap.higherKey(this);</span>
<span class="nc bnc" id="L343" title="All 4 branches missed.">        if (nextKey != null &amp;&amp; nextKey.isOverlapped(this)) {</span>
<span class="nc" id="L344">            return nextKey;</span>
        }
<span class="nc" id="L346">        return null;</span>
    }

    /**
     * Calls the provided function with every {@code long} index contained in this
     * instance.
     * &lt;p&gt;
     * Calling this function on empty {@link SquareRange} instances will not result
     * in any call to the function.
     *
     * @param func the function to apply with every index of this instance
     */
    public void forEach(SquareIndexConsumer func) {
<span class="fc" id="L359">        outer.forEach((long i) -&gt; {</span>
<span class="fc" id="L360">            columnRange(i).forEach((long j) -&gt; {</span>
<span class="fc" id="L361">                func.accept(i, j);</span>
<span class="fc" id="L362">            });</span>
<span class="fc" id="L363">        });</span>
<span class="fc" id="L364">    }</span>

    /**
     * Returns a hash code for the {@link SquareRange}. The hash-code is generated
     * based on some bit shift operations on the {@link #outer lower} and
     * {@link #inner upper bound} of the {@link SquareRange}.
     *
     * @return hash-code for this instance
     */
    @Override
    public int hashCode() {
<span class="nc" id="L375">        return ((inner.hashCode() &lt;&lt; 4) + (inner.hashCode() &gt;&gt; 16) + outer.hashCode());</span>
    }

    /**
     * Return the intersection range of this instance and the provided one. If there
     * are no index regions that belongs to either ranges, returns null;
     *
     * @param range the square range whose intersection with this instance is to be
     *              checked
     * @return a {@link SquareRange} representing the intersection between this and
     *         the provided instance, {@code null} if there is no intersection
     */
    public SquareRange intersection(SquareRange range) {
<span class="fc" id="L388">        final LongRange interOut = outer.intersection(range.outer);</span>
<span class="fc" id="L389">        final LongRange interInn = inner.intersection(range.inner);</span>
<span class="pc bpc" id="L390" title="4 of 8 branches missed.">        if (interOut == null || interOut.size() == 0 || interInn == null || interInn.size() == 0) {</span>
<span class="nc" id="L391">            return null;</span>
        }
<span class="pc bpc" id="L393" title="1 of 4 branches missed.">        final boolean isUpper = this.isUpperTriangle || range.isUpperTriangle;</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (!isUpper) {</span>
<span class="fc" id="L395">            return new SquareRange(interOut, interInn, false);</span>
        }
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">        final long triDiff = isUpperTriangle</span>
<span class="pc" id="L398">                ? (range.isUpperTriangle ? Math.max(triangleDiff, range.triangleDiff) : triangleDiff)</span>
                : // TODO min will be used for lowerTriangle
                range.triangleDiff;
<span class="fc" id="L401">        return new SquareRange(interOut, interInn, isUpper, triDiff).normalizeTriangle();</span>
    }

    public SquareRange intersectionCheck(SquareRange subrange) {
<span class="fc" id="L405">        containsCheck(subrange);</span>
        // TODO
        // upper rect care...
<span class="fc" id="L408">        return intersection(subrange);</span>
    }

    /**
     * Returns true if the provided {@link SquareRange} and this instance are
     * overlapped. This operation is symmetric, meaning that calling this method
     * with two instances a and b, the result produced by {@code a.isOverlapped(b)}
     * is the same as {@code b.isOverlapped(a)}.
     * &lt;p&gt;
     * Two {@link SquareRange} a and b are overlapped if they share some indices,
     * that is if there exist a {@code long} l such that a.contains(l) and
     * b.contains(l) return true.
     * &lt;p&gt;
     * In cases where an empty {@link SquareRange} and a non-empty
     * {@link SquareRange} are considered, this method returns true if the lower
     * bound (or upper bound as it has the same value) of the empty instance is
     * between the lower bound (included) and the upper bound (excluded) of the
     * other instance.
     * &lt;p&gt;
     * If both considered {@link SquareRange} are empty, returns true if they have
     * the same bounds.
     *
     * @param range the range whose overlap with this instance is to be checked
     * @return true if the provided LongRange and this instance overlap
     */
    public boolean isOverlapped(SquareRange range) {
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (equals(range)) {</span>
<span class="nc" id="L435">            return true;</span>
        }
<span class="nc bnc" id="L437" title="All 4 branches missed.">        return (inner.isOverlapped(range.inner) &amp;&amp; outer.isOverlapped(range.outer));</span>
    }

    private SquareRange normalizeTriangle() {
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (startColumn(outer.from) &gt;= inner.to) {</span>
<span class="fc" id="L442">            return null;</span>
        }
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">        if (startColumn(outer.to) &lt; inner.from) {</span>
<span class="nc" id="L445">            return new SquareRange(inner, outer); // normal rec</span>
        }
<span class="fc" id="L447">        return new SquareRange(rowRange(inner.to), columnRange(outer.from - 1), true, triangleDiff);</span>
    }

    /**
     * Returns the range of rows that have values within this squared range at the
     * specified column
     *
     * @param column the column considered
     * @return the range of rows included within this squared range that have values
     *         at the specified column
     */
    public LongRange rowRange(long column) {
<span class="fc" id="L459">        return new LongRange(startRow(column), endRow(column));</span>
    }

    /**
     * Returns the size of the this instance.
     *
     * @return size of the {@link SquareRange}
     */
    public long size() {
        // TODO : uppertriangle
<span class="fc" id="L469">        return inner.size() * outer.size();</span>
    }

//    /**
//     * Returns true if the provided {@link SquareRange} and this instance are
//     * overlapped. This operation is symmetric, meaning that calling this method
//     * with two instances a and b, the result produced by {@code a.isOverlapped(b)}
//     * is the same as {@code b.isOverlapped(a)}.
//     * &lt;p&gt;
//     * Two {@link SquareRange} a and b are overlapped if they share some indices, that
//     * is if there exist a {@code long} l such that a.contains(l) and b.contains(l)
//     * return true.
//     * &lt;p&gt;
//     * In cases where an empty {@link SquareRange} and a non-empty {@link SquareRange}
//     * are considered, this method returns true if the lower bound (or upper bound
//     * as it has the same value) of the empty instance is between the lower bound
//     * (included) and the upper bound (excluded) of the other instance.
//     * &lt;p&gt;
//     * If both considered {@link SquareRange} are empty, returns true if they have the
//     * same bounds.
//     *
//     * @return a {@link LongStream} of every index contained in this instance
//     */
//    public LongStream stream() {
//        return LongStream.range(from, to);
//    }

    /**
     * Splits this range into a grid with the specified number of
     *
     * @param outerN number of vertical tiles into which to split this range
     * @param innerN number of horizontal tiles into which to split this range
     * @return list of smaller {@link SquareRange}, the union of which covers this
     *         {@link SquareRange}
     */
    public List&lt;SquareRange&gt; split(int outerN, int innerN) {
        // TODO
        // more smart split for upper rectangle
        // lazy way??
<span class="fc" id="L508">        final List&lt;SquareRange&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L509">        final List&lt;LongRange&gt; splitOuters = outer.split(outerN);</span>
<span class="fc" id="L510">        final List&lt;LongRange&gt; splitInners = inner.split(innerN);</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">        for (final LongRange out0 : splitOuters) {</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">            for (final LongRange in0 : splitInners) {</span>
<span class="fc" id="L513">                final SquareRange sq = intersection(new SquareRange(out0, in0));</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">                if (sq != null) {</span>
<span class="fc" id="L515">                    results.add(sq);</span>
                }
<span class="fc" id="L517">            }</span>
<span class="fc" id="L518">        }</span>
<span class="fc" id="L519">        return results;</span>
    }

    /**
     * Returns the first column index at the specified row.
     *
     * @param row the index of the row within the square range
     * @return the index of the first non-empty column in this square range
     */
    public long startColumn(long row) {
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (isUpperTriangle) {</span>
<span class="fc" id="L530">            return Math.max(row + triangleDiff + 1, inner.from);</span>
        }
<span class="fc" id="L532">        return inner.from;</span>
    }

//    /**
//    TODO
//     * Returns an iterator on the {@code long} indices contained in this instance
//     *
//     * @return a new iterator starting at {@link #from} and whose last value is the
//     *         long preceding {@link #to}
//     */
//    @Override
//    public Iterator&lt;Long&gt; iterator() {
//        return new It();
//    }

//    /**
//     * Splits the LongRange into &lt;em&gt;n&lt;/em&gt; LongRange instances of equal size (or
//     * near equal size if the size of this instance is not divisible by &lt;em&gt;n&lt;/em&gt;.
//     *
//     * @param n the number of LongRange instance in which to split this instance
//     * @return a list of &lt;em&gt;n&lt;/em&gt; consecutive LongRange instances
//     */
//    public List&lt;SquareRange&gt; split(int n) {
//        final ArrayList&lt;SquareRange&gt; result = new ArrayList&lt;&gt;();
//        final long rem = size() % n;
//        final long quo = size() / n;
//        long c = from;
//
//        for (int i = 0; i &lt; n; i++) {
//            final long given = quo + ((i &lt; rem) ? 1 : 0);
//            result.add(new SquareRange(c, c + given));
//            c += given;
//        }
//        return result;
//    }

//    /**
//     * Streams every {@code long} index contained in this instance.
//     *
//     * @return a {@link LongStream} of every index contained in this instance
//     */
//    public LongStream stream() {
//        return LongStream.range(from, to);
//    }

    /**
     * Returns the index of the first row with values for the specified column
     *
     * @param column the index of the column considered
     * @return the index of the first row with values at the specified column
     *         contained within this range
     */
    public long startRow(long column) {
<span class="fc" id="L585">        return outer.from;</span>
    }

    /**
     * Returns this SquareRange printed in the following format:
     * [outerRange,innerRange]
     *
     * @return the range of this {@link SquareRange} as &quot;[ outerRange, innerRange] &quot;
     */
    @Override
    public String toString() {
<span class="fc" id="L596">        return &quot;[&quot; + outer + &quot;,&quot; + inner + &quot;]&quot;;</span>
    }

    /**
     * Returns a {@link SquareRange} that is translated by the provided outer and
     * inner. This method does not change the value of this instance.
     *
     * @param outer translates in the outer direction.
     * @param inner translates in the outer direction.
     * @return translated {@link SquareRange}
     */
    public SquareRange translate(long outer, long inner) {
<span class="fc" id="L608">        return new SquareRange(new LongRange(this.outer.from + outer, this.outer.to + outer),</span>
                new LongRange(this.inner.from + inner, this.inner.to + inner));
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>