<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SquareChunk.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">SquareChunk.java</span></div><h1>SquareChunk.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.KryoSerializable;
import com.esotericsoftware.kryo.io.Input;
import com.esotericsoftware.kryo.io.Output;

import handist.collections.function.LongTBiConsumer;
import handist.collections.function.SquareIndexTConsumer;
import handist.collections.function.SquareIndexTFunction;

/**
 * @author yoshikikawanishi
 *
 * @param &lt;T&gt; type handled by the collection
 */
public class SquareChunk&lt;T&gt; implements Serializable, SquareRangedList&lt;T&gt;, KryoSerializable {

    /**
     * The class to create view for the specific column range in Square.
     *
     * @param &lt;T&gt; type handled by the collection
     */
    static class ColumnView&lt;T&gt; extends MyView&lt;T&gt; {
        private final int offset;
        private final LongRange baseRange;
        private final int stride;
        private final Object[] a;
        // TODO sublist based impl of iterators.

<span class="fc" id="L55">        public ColumnView(int offset, int stride, LongRange baseRange, Object[] a) {</span>
<span class="fc" id="L56">            this.offset = offset;</span>
<span class="fc" id="L57">            this.baseRange = baseRange;</span>
<span class="fc" id="L58">            this.stride = stride;</span>
<span class="fc" id="L59">            this.a = a;</span>
<span class="fc" id="L60">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public &lt;U&gt; void forEachImpl(LongRange range, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
                Consumer&lt;? super U&gt; receiver) {
<span class="nc" id="L66">            rangeCheck(range);</span>
<span class="nc" id="L67">            long current = range.from;</span>
<span class="nc" id="L68">            int index = offset + (int) (range.from - baseRange.from);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            while (current++ &lt; range.to) {</span>
<span class="nc" id="L70">                action.accept((T) a[index], receiver);</span>
<span class="nc" id="L71">                index += stride;</span>
            }
<span class="nc" id="L73">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void forEachImpl(LongRange range, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L78">            rangeCheck(range);</span>
<span class="fc" id="L79">            long current = range.from;</span>
<span class="fc" id="L80">            int index = offset + (int) (range.from - baseRange.from);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">            while (current++ &lt; range.to) {</span>
<span class="fc" id="L82">                action.accept((T) a[index]);</span>
<span class="fc" id="L83">                index += stride;</span>
            }
<span class="fc" id="L85">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void forEachImpl(LongRange range, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L90">            rangeCheck(range);</span>
<span class="fc" id="L91">            long current = range.from;</span>
<span class="fc" id="L92">            int index = offset + (int) (range.from - baseRange.from) * stride;</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">            while (current &lt; range.to) {</span>
<span class="fc" id="L94">                action.accept(current++, (T) a[index]);</span>
<span class="fc" id="L95">                index += stride;</span>
            }
<span class="fc" id="L97">        }</span>

        @Override
        public LongRange getRange() {
<span class="fc" id="L101">            return baseRange;</span>
        }

        @Override
        public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L106">            return new ColumnIterator&lt;&gt;(offset, baseRange, a, stride);</span>
        }

        @Override
        public RangedListIterator&lt;T&gt; listIterator() {
<span class="nc" id="L111">            return new ColumnListIterator&lt;&gt;(offset, baseRange, a, stride);</span>
        }

        @Override
        public RangedListIterator&lt;T&gt; listIterator(long from) {
<span class="nc" id="L116">            return new ColumnListIterator&lt;&gt;(offset, baseRange, from, a, stride);</span>
        }

        @Override
        public void rangeCheck(LongRange range) {
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (!baseRange.contains(range)) {</span>
<span class="fc" id="L122">                throw new IndexOutOfBoundsException(</span>
<span class="fc" id="L123">                        &quot;[ColumnView] range mismatch: &quot; + this.getRange() + &quot; does not include range&quot;);</span>
            }
<span class="fc" id="L125">        }</span>

        @Override
        protected Iterator&lt;T&gt; subIterator(LongRange range) {
            // TODO check
<span class="nc" id="L130">            final int newOffset = offset + (int) (range.from - baseRange.from) * stride;</span>
<span class="nc" id="L131">            return new ColumnIterator&lt;&gt;(newOffset, range, a, stride);</span>
        }

        @Override
        protected RangedListIterator&lt;T&gt; subListIterator(LongRange range) {
<span class="nc" id="L136">            final int newOffset = offset + (int) (range.from - baseRange.from) * stride;</span>
<span class="nc" id="L137">            return new ColumnListIterator&lt;&gt;(newOffset, range, a, stride);</span>
        }

        @Override
        protected RangedListIterator&lt;T&gt; subListIterator(LongRange range, long from) {
<span class="nc" id="L142">            final int newOffset = offset + (int) (range.from - baseRange.from) * stride;</span>
<span class="nc" id="L143">            return new ColumnListIterator&lt;&gt;(newOffset, range, from, a, stride);</span>
        }
    }

    /**
     * The class to convert 1D to 2D.
     *
     * @param &lt;T&gt; type handled by the collection
     */
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">    static class MySquareSiblingAccessor&lt;T&gt; implements SquareSiblingAccessor&lt;T&gt; {</span>
        private final int offset;
        private final int innerSize;
        private final Object[] a;

        /**
         * @param offset    the offset of index
         * @param innerSize the size of inner loop
         * @param a         the base array
         */
<span class="fc" id="L162">        public MySquareSiblingAccessor(int offset, int innerSize, Object[] a) {</span>
<span class="fc" id="L163">            this.offset = offset;</span>
<span class="fc" id="L164">            this.innerSize = innerSize;</span>
<span class="fc" id="L165">            this.a = a;</span>
<span class="fc" id="L166">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public T get(int x, int y) {
<span class="nc bnc" id="L171" title="All 6 branches missed.">            assert (x &lt;= 1 &amp;&amp; x &gt;= -1);</span>
<span class="nc bnc" id="L172" title="All 6 branches missed.">            assert (y &lt;= 1 &amp;&amp; y &gt;= -1);</span>
<span class="nc" id="L173">            return (T) a[offset + x * innerSize + y];</span>
        }

        @Override
        public void put(T v) {
<span class="fc" id="L178">            a[offset] = v;</span>
<span class="fc" id="L179">        }</span>
    }

    /**
     * The class for implementing view of row and column.
     *
     * @param &lt;T&gt; type handled by the collection
     */
<span class="fc" id="L187">    static abstract class MyView&lt;T&gt; extends RangedList&lt;T&gt; {</span>
        @Override
        public RangedList&lt;T&gt; cloneRange(LongRange range) {
<span class="nc" id="L190">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }

        @Override
        public boolean contains(Object o) {
<span class="nc" id="L195">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }

        @Override
        public T get(long index) {
<span class="nc" id="L200">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }

        @Override
        public abstract void rangeCheck(LongRange range);

        @Override
        public T set(long index, T value) {
<span class="nc" id="L208">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }

        @Override
        public Object[] toArray() {
<span class="nc" id="L213">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }

        @Override
        public Object[] toArray(LongRange r) {
<span class="nc" id="L218">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }

        @Override
        public Chunk&lt;T&gt; toChunk(LongRange r) {
<span class="nc" id="L223">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }

        @Override
        public List&lt;T&gt; toList(LongRange r) {
<span class="nc" id="L228">            throw new UnsupportedOperationException(&quot;not implemented yet. may be shared abst class will be needed&quot;);</span>
        }
    }

    /**
     * The class to create view for the specific row range in Square.
     */
    static class RowView&lt;T&gt; extends MyView&lt;T&gt; {
        private final int offset;
        private final LongRange baseRange;
        private final Object[] a;
        // TODO sublist based impl of iterators.

<span class="fc" id="L241">        public RowView(int offset, LongRange baseRange, Object[] a) {</span>
<span class="fc" id="L242">            this.offset = offset;</span>
<span class="fc" id="L243">            this.baseRange = baseRange;</span>
<span class="fc" id="L244">            this.a = a;</span>
<span class="fc" id="L245">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public &lt;U&gt; void forEachImpl(LongRange range, BiConsumer&lt;? super T, Consumer&lt;? super U&gt;&gt; action,
                Consumer&lt;? super U&gt; receiver) {
<span class="fc" id="L251">            rangeCheck(range);</span>
<span class="fc" id="L252">            long current = range.from;</span>
<span class="fc" id="L253">            int index = offset + (int) (range.from - baseRange.from);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            while (current++ &lt; range.to) {</span>
<span class="fc" id="L255">                action.accept((T) a[index++], receiver);</span>
            }
<span class="fc" id="L257">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void forEachImpl(LongRange range, Consumer&lt;? super T&gt; action) {
<span class="fc" id="L262">            rangeCheck(range);</span>
<span class="fc" id="L263">            long current = range.from;</span>
<span class="fc" id="L264">            int index = offset + (int) (range.from - baseRange.from);</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            while (current++ &lt; range.to) {</span>
<span class="fc" id="L266">                action.accept((T) a[index++]);</span>
            }
<span class="fc" id="L268">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        @Override
        public void forEachImpl(LongRange range, LongTBiConsumer&lt;? super T&gt; action) {
<span class="fc" id="L273">            rangeCheck(range);</span>
<span class="fc" id="L274">            long current = range.from;</span>
<span class="fc" id="L275">            int index = offset + (int) (range.from - baseRange.from);</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            while (current &lt; range.to) {</span>
<span class="fc" id="L277">                action.accept(current++, (T) a[index++]);</span>
            }
<span class="fc" id="L279">        }</span>

        @Override
        public LongRange getRange() {
<span class="fc" id="L283">            return baseRange;</span>
        }

        @Override
        public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L288">            return new ChunkIterator&lt;&gt;(offset, baseRange, a);</span>
        }

        @Override
        public RangedListIterator&lt;T&gt; listIterator() {
<span class="nc" id="L293">            return new ChunkListIterator&lt;&gt;(offset, baseRange, a);</span>
        }

        @Override
        public RangedListIterator&lt;T&gt; listIterator(long from) {
<span class="nc" id="L298">            return new ChunkListIterator&lt;&gt;(offset, baseRange, from, a);</span>
        }

        @Override
        public void rangeCheck(LongRange range) {
<span class="fc bfc" id="L303" title="All 2 branches covered.">            if (!baseRange.contains(range)) {</span>
<span class="fc" id="L304">                throw new IndexOutOfBoundsException(</span>
<span class="fc" id="L305">                        &quot;[RowView] range mismatch: &quot; + this.getRange() + &quot; does not include range&quot;);</span>
            }
<span class="fc" id="L307">        }</span>

        @Override
        protected Iterator&lt;T&gt; subIterator(LongRange range) {
<span class="nc" id="L311">            rangeCheck(range);</span>
<span class="nc" id="L312">            final int newOffset = offset + (int) (range.from - baseRange.from);</span>
<span class="nc" id="L313">            return new ChunkIterator&lt;&gt;(newOffset, range, a);</span>
        }

        @Override
        protected RangedListIterator&lt;T&gt; subListIterator(LongRange range) {
<span class="nc" id="L318">            rangeCheck(range);</span>
<span class="nc" id="L319">            final int newOffset = offset + (int) (range.from - baseRange.from);</span>
<span class="nc" id="L320">            return new ChunkListIterator&lt;&gt;(newOffset, range, a);</span>
        }

        @Override
        protected RangedListIterator&lt;T&gt; subListIterator(LongRange range, long from) {
<span class="nc" id="L325">            rangeCheck(range);</span>
<span class="nc" id="L326">            final int newOffset = offset + (int) (range.from - baseRange.from);</span>
<span class="nc" id="L327">            return new ChunkListIterator&lt;&gt;(newOffset, range, from, a);</span>
        }
    }

    private static final long serialVersionUID = -8282656629771334491L;

    /** Array containing the T objects */
    private Object[] a;
    /** Range on which this instance is defined */
    private SquareRange range;
    /**  */
    private long innerSize;

    /**
     * Builds a SquareChunk with the given range and no mapping.
     * &lt;p&gt;
     * The given SquareRange should have a strictly positive size. Giving a
     * {@link SquareRange} instance with identical lower and upper bounds will
     * result in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link SquareRange} provided has a range that exceeds
     * {@link Config#maxChunkSize} , an {@link IllegalArgumentException} will be be
     * thrown.
     *
     * @param range the range of the chunk to build
     * @throws IllegalArgumentException if a {@link SquareChunk} cannot be built
     *                                  with the provided range.
     */
<span class="fc" id="L355">    public SquareChunk(SquareRange range) {</span>
<span class="fc" id="L356">        final long outerSize = range.outer.size();</span>
<span class="fc" id="L357">        this.innerSize = range.inner.size();</span>
<span class="fc" id="L358">        final long size = outerSize * innerSize;</span>
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (range.isUpperTriangle) {</span>
<span class="nc" id="L360">            throw new IllegalArgumentException(&quot;Rectangle ranges are not supported by SquareChunk yet.&quot;);</span>
        }
        // FIXME
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">        if (size &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L364">            throw new RuntimeException(&quot;array size overflow&quot;);</span>
        }
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">        if (size &gt; Config.maxChunkSize) {</span>
<span class="nc" id="L367">            throw new IllegalArgumentException(</span>
                    &quot;The given range &quot; + range + &quot; exceeds the maximum Chunk size &quot; + Config.maxChunkSize);
        }
<span class="fc" id="L370">        a = new Object[(int) size];</span>
<span class="fc" id="L371">        this.range = range;</span>
<span class="fc" id="L372">    }</span>

    /**
     * Builds a {@link SquareChunk} with the provided {@link SquareRange} and an
     * initial mapping for each long in the object array. The provided
     * {@link SquareRange} and Object array should have the same size. An
     * {@link IllegalArgumentException} will be thrown otherwise.
     * &lt;p&gt;
     * The given {@link SquareRange} should have a strictly positive size. Giving a
     * {@link SquareRange} instance with identical lower and upper bounds will
     * result in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link SquareRange} provided has a range that exceeds
     * {@link Config#maxChunkSize}, an {@link IllegalArgumentException} will be be
     * thrown.
     *
     * @param range the range of the chunk to build
     * @param a     array with the initial mapping for every long in the provided
     *              range
     * @throws IllegalArgumentException if a {@link SquareChunk} cannot be built
     *                                  with the provided range and object array.
     */
    public SquareChunk(SquareRange range, Object[] a) {
<span class="fc" id="L395">        this(range);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (a.length != range.size()) {</span>
<span class="fc" id="L397">            throw new IllegalArgumentException(&quot;The length of the provided &quot; + &quot;array &lt;&quot; + a.length</span>
<span class="fc" id="L398">                    + &quot;&gt; does not match the size of the &quot; + &quot;LongRange &lt;&quot; + range.size() + &quot;&gt;&quot;);</span>
        }
        // TODO Do we check for objects in array a that are not of type T?
        // We can leave as is and let the code fail later in methods get and
        // others where a ClassCastException should be thrown.
<span class="fc" id="L403">        this.a = a;</span>
<span class="fc" id="L404">    }</span>

    /**
     * Builds a {@link SquareChunk} with the provided {@link SquareRange}. The
     * provided initializer generates the initial value of the element for each
     * index. The given SquareRange should have a strictly positive size. Giving a
     * {@link SquareRange} instance with identical lower and upper bounds will
     * result in a {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link SquareRange} provided has a range that exceeds
     * {@link Config#maxChunkSize}, an {@link IllegalArgumentException} will be be
     * thrown.
     *
     * @param range       the range of the Squarechunk to build
     * @param initializer generates the initial value of the element for each index.
     * @throws IllegalArgumentException if a {@link SquareChunk} cannot be built
     *                                  with the provided range.
     */
    public SquareChunk(SquareRange range, SquareIndexTFunction&lt;T&gt; initializer) {
<span class="fc" id="L423">        this(range);</span>
<span class="fc" id="L424">        range.forEach((long index, long index2) -&gt; {</span>
<span class="fc" id="L425">            set(index, index2, initializer.apply(index, index2));</span>
<span class="fc" id="L426">        });</span>
<span class="fc" id="L427">    }</span>

    /**
     * Builds a {@link SquareChunk} with the provided {@link SquareRange} with each
     * long in the provided range mapped to object t. The given LongRange should
     * have a strictly positive size. Giving a {@link SquareRange} instance with
     * identical lower and upper bounds will result in a
     * {@link IllegalArgumentException} being thrown.
     * &lt;p&gt;
     * If the {@link SquareRange} provided has a range that exceeds
     * {@link Config#maxChunkSize}, an {@link IllegalArgumentException} will be be
     * thrown.
     *
     * @param range the range of the chunk to build
     * @param t     initial mapping for every long in the provided range
     * @throws IllegalArgumentException if a {@link SquareChunk} cannot be built
     *                                  with the provided range.
     */
    public SquareChunk(SquareRange range, T t) {
<span class="fc" id="L446">        this(range);</span>
        // TODO Is this what we really want to do?
        // The mapping will be on the SAME OBJECT for every long in LongRange.
        // Don't we need a Generator&lt;T&gt; generator as argument and create an
        // instance for each key with Arrays.setAll(a, generator) ?
<span class="fc" id="L451">        Arrays.fill(a, t);</span>
<span class="fc" id="L452">    }</span>

    @Override
    public RangedList&lt;RangedList&lt;T&gt;&gt; asColumnList() {
<span class="fc" id="L456">        return new Chunk&lt;&gt;(range.inner, (Long columnIndex) -&gt; {</span>
<span class="fc" id="L457">            return getColumnView(columnIndex);</span>
        });
    }

    @Override
    public RangedList&lt;RangedList&lt;T&gt;&gt; asRowList() {
<span class="fc" id="L463">        return new Chunk&lt;&gt;(range.outer, (Long rowIndex) -&gt; {</span>
<span class="fc" id="L464">            return getRowView(rowIndex); // OK filter dependet</span>
        });
    }

//  /**
//  * Returns a new Chunk defined on the same {@link LongRange} and with the same
//  * contents as this instance.
//  *
//  * @return a copy of this instance
//  */
//     @Override
//     public SquareChunk&lt;T&gt; clone() {
//         // Object[] aClone = a.clone();
//         final Object[] aClone = new Object[a.length];
//
//         //// FIXME: 2018/09/19 Need deep copy?
//         // for (int i = 0; i &lt; a.length; i++) {
//         // try {
//         // aClone[i] = ((Cloneable) a[i]).clone();
//         // } catch (CloneNotSupportedException e) {
//         // e.printStackTrace();
//         // }
//         // }
//
//         Arrays.fill(aClone, a[0]);
//         System.arraycopy(a, 0, aClone, 0, a.length);
//
//         return new SquareChunk&lt;&gt;(this.range, aClone);
//     }

//    @Override
//    public SquareChunk&lt;T&gt; cloneRange(LongRange newRange) {
//        return range == newRange ? clone() : toChunk(newRange);
//    }
//
    @Override
    public boolean contains(Object v) {
<span class="fc bfc" id="L501" title="All 2 branches covered.">        for (final Object e : a) {</span>
<span class="pc bpc" id="L502" title="3 of 6 branches missed.">            if (v == null ? e == null : v.equals(e)) {</span>
<span class="fc" id="L503">                return true;</span>
            }
        }
<span class="fc" id="L506">        return false;</span>
    }

    /**
     * (&lt;em&gt;&amp;lt;tag&amp;gt;&lt;/em&gt;), row:&amp;lt;rowIndex&amp;gt; -&gt;
     * [&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;][&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;]...&lt;br&gt;
     * (&lt;em&gt;&amp;lt;tag&amp;gt;&lt;/em&gt;), row:&amp;lt;rowIndex&amp;gt; -&gt;
     * [&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;][&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;]...&lt;br&gt;
     * ...
     *
     * @param tag header tag
     */
    void debugPrint(String tag) {
<span class="nc" id="L519">        debugPrint(tag, new PrintWriter(System.out));</span>
<span class="nc" id="L520">    }</span>

    /**
     * (&lt;em&gt;&amp;lt;tag&amp;gt;&lt;/em&gt;), row:&amp;lt;rowIndex&amp;gt; -&gt;
     * [&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;][&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;]...&lt;br&gt;
     * (&lt;em&gt;&amp;lt;tag&amp;gt;&lt;/em&gt;), row:&amp;lt;rowIndex&amp;gt; -&gt;
     * [&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;][&amp;lt;columnIndex&amp;gt:&amp;lt;element&amp;gt;]...&lt;br&gt;
     * ...
     *
     * @param tag header tag
     * @param out {@link PrintWriter} to output
     */
    void debugPrint(String tag, PrintWriter out) {
<span class="nc" id="L533">        forEachRow((long index, RangedList&lt;T&gt; row) -&gt; {</span>
<span class="nc" id="L534">            out.print(&quot;(&quot; + tag + &quot;), row:&quot; + index + &quot;-&gt;&quot;);</span>
<span class="nc" id="L535">            row.forEach((long i, T e) -&gt; {</span>
<span class="nc" id="L536">                out.print(&quot;[&quot; + i + &quot;:&quot; + e + &quot;]&quot;);</span>
<span class="nc" id="L537">            });</span>
<span class="nc" id="L538">            out.println();</span>
<span class="nc" id="L539">        });</span>
<span class="nc" id="L540">    }</span>

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L545">            return false;</span>
        }
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        if (!(o instanceof AbstractSquareRangedList)) {</span>
<span class="nc" id="L548">            return false;</span>
        }
<span class="fc" id="L550">        final SquareRangedList&lt;?&gt; target = (SquareRangedList&lt;?&gt;) o;</span>
        // TODO this version is too slow,
        // setupFrom will be the good candidate for fast simul scanner.
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (!getRange().equals(target.getRange())) {</span>
<span class="nc" id="L554">            return false;</span>
        }
<span class="fc bfc" id="L556" title="All 2 branches covered.">        for (final long i : getRange().outer) {</span>
<span class="fc bfc" id="L557" title="All 2 branches covered.">            for (final long j : getRange().inner) {</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">                if (!get(i, j).equals(target.get(i, j))) {</span>
<span class="fc" id="L559">                    return false;</span>
                }
<span class="fc" id="L561">            }</span>
<span class="fc" id="L562">        }</span>
<span class="fc" id="L563">        return true;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void forEach(final Consumer&lt;? super T&gt; action) {
<span class="fc" id="L569">        rangeCheck(range);</span>
        // TODO
        // IntStream.range(begin, end).forEach();
<span class="fc bfc" id="L572" title="All 2 branches covered.">        for (final Object o : a) {</span>
<span class="fc" id="L573">            action.accept((T) o); // TODO filter dependent</span>
        }
<span class="fc" id="L575">    }</span>

    @Override
    public void forEach(final SquareIndexTConsumer&lt;? super T&gt; action) {
<span class="fc" id="L579">        rangeCheck(range);</span>
        // TODO
        // IntStream.range(begin, end).forEach();
<span class="fc" id="L582">        long index = range.outer.from;</span>
<span class="fc" id="L583">        long index2 = range.inner.from;</span>
<span class="fc" id="L584">        int offset = 0;</span>
        while (true) {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L587">            final T v = (T) a[offset];</span>
<span class="fc" id="L588">            action.accept(index, index2, v);</span>
<span class="fc" id="L589">            index2++;</span>
<span class="fc" id="L590">            offset++;</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">            if (index2 == range.inner.to) {</span>
<span class="fc" id="L592">                index2 = range.inner.from;</span>
<span class="fc" id="L593">                index++;</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                if (index == range.outer.to) {</span>
<span class="fc" id="L595">                    return;</span>
                }
            }
<span class="fc" id="L598">        }</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void forEach(SquareRange range, final Consumer&lt;? super T&gt; action) {
<span class="fc" id="L604">        rangeCheck(range);</span>
        // TODO
        // IntStream.range(begin, end).forEach();
<span class="fc" id="L607">        long index1 = range.outer.from;</span>
<span class="fc" id="L608">        long index2 = range.inner.from;</span>
<span class="fc" id="L609">        long offset1 = index1 - getRange().outer.from;</span>
<span class="fc" id="L610">        final long offset2 = index2 - getRange().inner.from;</span>
        // TODO overflow assert
<span class="fc" id="L612">        int offset = (int) (offset1 * innerSize + offset2);</span>
        while (true) {
            // TODO overflow assert
<span class="fc" id="L615">            action.accept((T) a[offset]);</span>
<span class="fc" id="L616">            index2++;</span>
<span class="fc" id="L617">            offset++;</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">            if (index2 == range.inner.to) {</span>
<span class="fc" id="L619">                index2 = range.inner.from; // TODO filter dependent</span>
<span class="fc" id="L620">                index1++;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">                if (index1 == range.outer.to) {</span>
<span class="fc" id="L622">                    return;</span>
                }
<span class="fc" id="L624">                offset1++;</span>
<span class="fc" id="L625">                offset = (int) (offset1 * innerSize + offset2);</span>
            }
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public void forEach(SquareRange range, final SquareIndexTConsumer&lt;? super T&gt; action) {
<span class="fc" id="L633">        rangeCheck(range);</span>
        // TODO
        // IntStream.range(begin, end).forEach();
<span class="fc" id="L636">        long index1 = range.outer.from;</span>
<span class="fc" id="L637">        long index2 = range.inner.from;</span>
<span class="fc" id="L638">        long offset1 = index1 - getRange().outer.from;</span>
<span class="fc" id="L639">        final long offset2 = index2 - getRange().inner.from;</span>
        // TODO overflow assert
<span class="fc" id="L641">        int offset = (int) (offset1 * innerSize + offset2);</span>
        while (true) {
            // TODO overflow assert
<span class="fc" id="L644">            action.accept(index1, index2, (T) a[offset]);</span>
<span class="fc" id="L645">            index2++;</span>
<span class="fc" id="L646">            offset++;</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">            if (index2 == range.inner.to) { // TODO filter dependent</span>
<span class="fc" id="L648">                index2 = range.inner.from;</span>
<span class="fc" id="L649">                index1++;</span>
<span class="fc bfc" id="L650" title="All 2 branches covered.">                if (index1 == range.outer.to) {</span>
<span class="fc" id="L651">                    return;</span>
                }
<span class="fc" id="L653">                offset1++;</span>
<span class="fc" id="L654">                offset = (int) (offset1 * innerSize + offset2);</span>
            }
        }
    }

    @Override
    public void forEachColumn(LongRange range, LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; columnAction) {
        // TODO filter support
<span class="fc" id="L662">        range = getRange().inner.intersection(range);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">        for (long index = range.from; index &lt; range.to; index++) {</span>
<span class="fc" id="L664">            final RangedList&lt;T&gt; cView = getColumnView(index);</span>
<span class="fc" id="L665">            columnAction.accept(index, cView);</span>
        }
<span class="fc" id="L667">    }</span>

    @Override
    public void forEachColumn(LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; columnAction) {
<span class="fc bfc" id="L671" title="All 2 branches covered.">        for (long index = getRange().inner.from; index &lt; getRange().inner.to; index++) {</span>
<span class="fc" id="L672">            final RangedList&lt;T&gt; cView = getColumnView(index);</span>
<span class="fc" id="L673">            columnAction.accept(index, cView);</span>
        }
<span class="fc" id="L675">    }</span>

    @Override
    public void forEachRow(LongRange rRange, LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; rowAction) {
<span class="fc" id="L679">        rRange = getRange().outer.intersection(rRange);</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">        for (long index = rRange.from; index &lt; rRange.to; index++) {</span>
<span class="fc" id="L681">            final RangedList&lt;T&gt; rView = getRowView(index);</span>
<span class="fc" id="L682">            rowAction.accept(index, rView);</span>
        }
<span class="fc" id="L684">    }</span>

    @Override
    public void forEachRow(LongTBiConsumer&lt;RangedList&lt;T&gt;&gt; rowAction) {
<span class="fc bfc" id="L688" title="All 2 branches covered.">        for (long index = getRange().outer.from; index &lt; getRange().outer.to; index++) {</span>
<span class="fc" id="L689">            final RangedList&lt;T&gt; rView = getRowView(index);</span>
<span class="fc" id="L690">            rowAction.accept(index, rView);</span>
        }
<span class="fc" id="L692">    }</span>

    @Override
    public void forEachWithSiblings(SquareRange range, final Consumer&lt;SquareSiblingAccessor&lt;T&gt;&gt; action) {
<span class="fc" id="L696">        rangeCheck(range);</span>
        // TODO
        // IntStream.range(begin, end).forEach();
<span class="fc" id="L699">        long index1 = range.outer.from;</span>
<span class="fc" id="L700">        long index2 = range.inner.from;</span>
<span class="fc" id="L701">        long offset1 = index1 - getRange().outer.from;</span>
<span class="fc" id="L702">        final long offset2 = index2 - getRange().inner.from;</span>
        // TODO overflow assert
<span class="fc" id="L704">        int offset = (int) (offset1 * innerSize + offset2);</span>
        while (true) {
            // TODO overflow assert
            // System.out.println(&quot;index:&quot; + index1 + &quot;,&quot; + index2 + &quot;, offset&quot; + offset1 +
            // &quot;,&quot; + offset2 + &quot;,&quot; + offset);
<span class="fc" id="L709">            final SquareSiblingAccessor&lt;T&gt; acc = new MySquareSiblingAccessor&lt;&gt;(offset, (int) innerSize, a);</span>
<span class="fc" id="L710">            action.accept(acc);</span>
<span class="fc" id="L711">            index2++;</span>
<span class="fc" id="L712">            offset++;</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">            if (index2 == range.inner.to) { // TODO filter dependent</span>
<span class="fc" id="L714">                index2 = range.inner.from;</span>
<span class="fc" id="L715">                index1++;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">                if (index1 == range.outer.to) {</span>
<span class="fc" id="L717">                    return;</span>
                }
<span class="fc" id="L719">                offset1++;</span>
                // TODO overflow assert
<span class="fc" id="L721">                offset = (int) (offset1 * innerSize + offset2);</span>
            }
<span class="fc" id="L723">        }</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T get(long index, long index2) { // TODO filter dependent
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (!getRange().outer.contains(index)) {</span>
<span class="fc" id="L732">            throw new IndexOutOfBoundsException(/* rangeMsg(index) */ index + &quot; is outof &quot; + getRange().outer);</span>
        }
<span class="fc bfc" id="L734" title="All 2 branches covered.">        if (!getRange().inner.contains(index2)) {</span>
<span class="fc" id="L735">            throw new IndexOutOfBoundsException(/* rangeMsg(index2) */ index2 + &quot; is outof &quot; + getRange().inner);</span>
        }
<span class="fc" id="L737">        return getUnsafe(index, index2);</span>
    }

    @Override
    public RangedList&lt;T&gt; getColumnView(long column) {
<span class="fc bfc" id="L742" title="All 2 branches covered.">        if (!getRange().inner.contains(column)) {</span>
<span class="fc" id="L743">            throw new IndexOutOfBoundsException(&quot;column &quot; + column + &quot; is outof &quot; + getRange());</span>
        }
<span class="fc" id="L745">        final int offset = (int) (column - getRange().inner.from);</span>
<span class="fc" id="L746">        return new ColumnView&lt;&gt;(offset, (int) innerSize, getRange().outer, a); // TODO filter dependent</span>
    }

    @Override
    public SquareRange getRange() {
<span class="fc" id="L751">        return range;</span>
    }

    @Override
    public RangedList&lt;T&gt; getRowView(long row) {
<span class="fc bfc" id="L756" title="All 2 branches covered.">        if (!getRange().outer.contains(row)) {</span>
<span class="fc" id="L757">            throw new IndexOutOfBoundsException(&quot;row &quot; + row + &quot; is outof &quot; + getRange());</span>
        }
<span class="fc" id="L759">        final int offset = (int) (innerSize * (row - getRange().outer.from));</span>
<span class="fc" id="L760">        return new RowView&lt;&gt;(offset, getRange().inner, a); // TODO filter dependent</span>
    }

    /**
     * Returns the element located at the provided index. The provided index is
     * presumed valid and as such, no bound checking is done.
     *
     * @param index  outer index whose value should be returned
     * @param index2 inner index whose value should be returned
     * @return the object stored at the provided index, possibly {@code null}
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    final T getUnsafe(long index, long index2) { // when range check was done
<span class="fc" id="L773">        final long offset1 = index - range.outer.from;</span>
<span class="fc" id="L774">        final long offset2 = index2 - range.inner.from;</span>
<span class="fc" id="L775">        return (T) a[(int) (offset1 * innerSize + offset2)];</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int hashCode() {
<span class="nc" id="L783">        return AbstractSquareRangedList.hashCode(this);</span>
    }

    @Override
    public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L788">        return new SquareChunkIterator&lt;&gt;(range, a);</span>
    }

    @Deprecated
    @Override
    public void read(Kryo kryo, Input input) {
<span class="fc" id="L794">        this.innerSize = input.readLong();</span>
<span class="fc" id="L795">        this.range = (SquareRange) kryo.readClassAndObject(input);</span>
<span class="fc" id="L796">        this.a = (Object[]) kryo.readClassAndObject(input);</span>
<span class="fc" id="L797">    }</span>

    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
<span class="fc" id="L800">        this.innerSize = in.readLong();</span>
<span class="fc" id="L801">        this.range = (SquareRange) in.readObject();</span>
<span class="fc" id="L802">        this.a = (Object[]) in.readObject();</span>
<span class="fc" id="L803">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public T set(long index, long index2, T value) {
<span class="fc bfc" id="L810" title="All 2 branches covered.">        if (!getRange().outer.contains(index)) {</span>
<span class="fc" id="L811">            throw new IndexOutOfBoundsException(/* rangeMsg(index) */ index + &quot; is outof &quot; + getRange().outer);</span>
        }
<span class="fc bfc" id="L813" title="All 2 branches covered.">        if (!getRange().inner.contains(index2)) {</span>
<span class="fc" id="L814">            throw new IndexOutOfBoundsException(/* rangeMsg(index2) */ index2 + &quot; is outof &quot; + getRange().inner);</span>
        }
<span class="fc" id="L816">        return setUnsafe(index, index2, value);</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private T setUnsafe(long index, long index2, T v) { // when range check was done
<span class="fc" id="L821">        final long offset1 = index - range.outer.from;</span>
<span class="fc" id="L822">        final long offset2 = index2 - range.inner.from;</span>
<span class="fc" id="L823">        final long offset = offset1 * innerSize + offset2;</span>
<span class="fc" id="L824">        final T prev = (T) a[(int) offset];</span>
<span class="fc" id="L825">        a[(int) offset] = v;</span>
<span class="fc" id="L826">        return prev;</span>
    }

    /**
     * Initializes the values in this instance by applying the provided function on
     * the elements contained in {@code source}
     *
     * @param &lt;S&gt;    the type handled by the {@link RangedList} given as parameter,
     *               input for the function
     * @param source {@link SquareChunk} instance from which entried for this
     *               instance will be extracted
     * @param func   function that takes an object of type S as parameter and
     *               returns a type T
     */
    public &lt;S&gt; void setupFrom(SquareChunk&lt;S&gt; source, Function&lt;? super S, ? extends T&gt; func) {
        // TODO 'source' should be SquareRangedList
        // and this method also should be declared in SquareRangedList
<span class="fc" id="L843">        rangeCheck(source.getRange());</span>
        // TODO filter dependent
<span class="fc" id="L845">        final SquareIndexTConsumer&lt;S&gt; consumer = (long index1, long index2, S s) -&gt; {</span>
<span class="fc" id="L846">            final T r = func.apply(s);</span>
<span class="fc" id="L847">            final long offset1 = index1 - getRange().outer.from;</span>
<span class="fc" id="L848">            final long offset2 = index2 - getRange().inner.from;</span>
<span class="fc" id="L849">            final long offset = offset1 * innerSize + offset2;</span>
<span class="fc" id="L850">            a[(int) offset] = r;</span>
<span class="fc" id="L851">        };</span>
<span class="fc" id="L852">        source.forEach(consumer);</span>
<span class="fc" id="L853">    }</span>

    @Override
    public Iterator&lt;T&gt; subIterator(SquareRange range) {
<span class="fc" id="L857">        final SquareRange r = range.intersection(getRange());</span>
<span class="fc" id="L858">        return new SquareChunkIterator&lt;&gt;(r, this.range, a);</span>
    }

    @Override
    public SquareRangedList&lt;T&gt; subView(SquareRange range) {
<span class="fc" id="L863">        return new SquareRangedListView&lt;&gt;(this, range);</span>
    }

    @Override
    public Object[] toArray() {
<span class="fc" id="L868">        return a;</span>
    }

    @Override
    public Object[] toArray(SquareRange newRange) {
        // TODO : now copy array. more efficient implementation ?
<span class="fc" id="L874">        final Object[] newRail = new Object[(int) newRange.size()];</span>
<span class="fc" id="L875">        final int[] count = { 0 };</span>
<span class="fc" id="L876">        forEach(newRange, (T t) -&gt; {</span>
<span class="fc" id="L877">            newRail[count[0]] = t;</span>
<span class="fc" id="L878">            count[0]++;</span>
<span class="fc" id="L879">        });</span>
<span class="fc" id="L880">        return newRail;</span>
    }

    @Override
    public SquareChunk&lt;T&gt; toChunk(SquareRange newRange) {
        // TODO : now copy chunk. more efficient implementation ?
<span class="fc" id="L886">        final SquareChunk&lt;T&gt; newChunk = new SquareChunk&lt;&gt;(newRange);</span>
<span class="fc" id="L887">        forEach(newRange, (i, j, t) -&gt; {</span>
<span class="fc" id="L888">            newChunk.set(i, j, t);</span>
<span class="fc" id="L889">        });</span>
<span class="fc" id="L890">        return newChunk;</span>
    }

    @Override
    public List&lt;T&gt; toList(SquareRange newRange) {
<span class="fc" id="L895">        final ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;((int) newRange.size());</span>
<span class="fc" id="L896">        forEach(newRange, (t) -&gt; list.add(t)); // check range at forEach</span>
<span class="fc" id="L897">        return list;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L902">        final StringWriter out = new StringWriter();</span>
<span class="nc" id="L903">        debugPrint(&quot;  &quot;, new PrintWriter(out));</span>
<span class="nc" id="L904">        return out.toString();</span>
    }

    @Deprecated
    @Override
    public void write(Kryo kryo, Output output) {
<span class="fc" id="L910">        output.writeLong(innerSize);</span>
<span class="fc" id="L911">        kryo.writeClassAndObject(output, range);</span>
<span class="fc" id="L912">        kryo.writeClassAndObject(output, a);</span>
<span class="fc" id="L913">    }</span>

    private void writeObject(ObjectOutputStream out) throws IOException {
<span class="fc" id="L916">        out.writeLong(innerSize);</span>
<span class="fc" id="L917">        out.writeObject(range);</span>
<span class="fc" id="L918">        out.writeObject(a);</span>
<span class="fc" id="L919">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>