<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DistIdMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">DistIdMap.java</span></div><h1>DistIdMap.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.dist;

import static apgas.Constructs.*;

import java.io.ObjectStreamException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import apgas.Place;
import apgas.util.GlobalID;
import handist.collections.dist.util.LazyObjectReference;
import handist.collections.dist.util.ObjectInput;
import handist.collections.dist.util.ObjectOutput;
import handist.collections.function.DeSerializer;
import handist.collections.function.SerializableConsumer;
import handist.collections.function.Serializer;

/**
 * Distributed Map using {@link Long} as key and type &lt;code&gt;V&lt;/code&gt; as value.
 *
 * @param &lt;V&gt; the type of the value mappings of this instance
 */
public class DistIdMap&lt;V&gt; extends DistMap&lt;Long, V&gt;
        implements DistributedCollection&lt;V, DistMap&lt;Long, V&gt;&gt;, ElementLocationManagable&lt;Long&gt; {
//TODO
    /* implements ManagedDistribution[Long] */

<span class="fc" id="L43">    private static int _debug_level = 0;</span>
    transient ElementLocationManager&lt;Long&gt; ldist;
    transient float[] locality;

    /**
     * Construct a DistIdMap. {@link TeamedPlaceGroup#getWorld()} is used as the
     * PlaceGroup of the new instance, a new {@link GlobalID} will also be created
     * for this new collection.
     */
    public DistIdMap() {
<span class="fc" id="L53">        this(TeamedPlaceGroup.getWorld());</span>
<span class="fc" id="L54">    }</span>

    /**
     * Construct a DistIdMap with the given argument. TeamOperations(placeGroup) is
     * used as the PlaceGroup of the new instance.
     *
     * @param placeGroup the PlaceGroup.
     */
    public DistIdMap(TeamedPlaceGroup placeGroup) {
<span class="fc" id="L63">        super(placeGroup);</span>
<span class="pc" id="L64">        super.GLOBAL = new GlobalOperations&lt;&gt;(this, (TeamedPlaceGroup pg0, GlobalID gid) -&gt; new DistIdMap&lt;&gt;(pg0, gid));</span>
        // TODO
<span class="fc" id="L66">        this.ldist = new ElementLocationManager&lt;&gt;();</span>
<span class="fc" id="L67">        ldist.setup(data.keySet());</span>
<span class="fc" id="L68">        locality = new float[placeGroup.size()];</span>
<span class="fc" id="L69">        Arrays.fill(locality, 1.0f);</span>
<span class="fc" id="L70">    }</span>

    protected DistIdMap(TeamedPlaceGroup placeGroup, GlobalID id) {
<span class="fc" id="L73">        super(placeGroup, id);</span>
<span class="pc" id="L74">        super.GLOBAL = new GlobalOperations&lt;&gt;(this, (TeamedPlaceGroup pg0, GlobalID gid) -&gt; new DistIdMap&lt;&gt;(pg0, gid));</span>
        // TODO
<span class="fc" id="L76">        this.ldist = new ElementLocationManager&lt;&gt;();</span>
<span class="fc" id="L77">        ldist.setup(data.keySet());</span>
<span class="fc" id="L78">        locality = new float[placeGroup.size()];</span>
<span class="fc" id="L79">        Arrays.fill(locality, 1.0f);</span>
<span class="fc" id="L80">    }</span>

    /**
     * Remove the all local entries.
     */
    @Override
    public void clear() {
<span class="nc" id="L87">        super.clear();</span>
<span class="nc" id="L88">        this.ldist.clear();</span>
<span class="nc" id="L89">        Arrays.fill(locality, 1.0f);</span>
<span class="nc" id="L90">    }</span>

    /*
     * Return true if the entry corresponding to the specified id is local.
     *
     * @return true or false.
     */
    public boolean containsId(long id) {
<span class="nc" id="L98">        return super.containsKey(id);</span>
    }

    public boolean delete(long id) {
<span class="nc" id="L102">        ldist.remove(id);</span>
<span class="nc" id="L103">        return super.delete(id);</span>
    }

    /*
     * Ensure calling updateDist() before balance() balance() should be called in
     * all places
     */
    public void distSize(long[] result) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        for (final Map.Entry&lt;Long, Place&gt; entry : ldist.dist.entrySet()) {</span>
            // val k = entry.getKey();
<span class="nc" id="L113">            final Place v = entry.getValue();</span>
<span class="nc" id="L114">            result[placeGroup.rank(v)] += 1;</span>
<span class="nc" id="L115">        }</span>
<span class="nc" id="L116">    }</span>

    /**
     * Execute the specified operation with the corresponding value of the specified
     * id.
     * &lt;ul&gt;
     * &lt;li&gt;If the entry is stored at local, the operation is executed sequentially.
     * &lt;li&gt;If the entry is stored at a remote place, the operation is asynchronously
     * executed on the remote place
     * &lt;/ul&gt;
     * &lt;p&gt;
     * In the remote case, this method returns immediately. Actual completion of the
     * operation can only be guaranteed if this method's enclosing
     * {@link apgas.Constructs#finish(apgas.Job)} has returned.
     *
     * @param id a Long type value.
     * @param op the operation.
     */
    public void execAt(long id, SerializableConsumer&lt;V&gt; op) {
<span class="nc" id="L135">        final Place place = getPlace(id);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (place.equals(here())) {</span>
<span class="nc" id="L137">            op.accept(data.get(id));</span>
<span class="nc" id="L138">            return;</span>
        }
<span class="nc" id="L140">        asyncAt(place, () -&gt; {</span>
<span class="nc" id="L141">            op.accept(data.get(id));</span>
<span class="nc" id="L142">        });</span>
<span class="nc" id="L143">    }</span>

    /**
     * Get the corresponding value of the specified id in the local collection.
     *
     * @param id long index to retrieve
     * @return the corresponding value of the specified index, or {@code null} if
     *         the corresponding mapping was null or if there is no such mapping in
     *         the local collection
     */
    public V get(long id) {
<span class="nc" id="L154">        return data.get(id);</span>
    }

    Map&lt;Long, Integer&gt; getDiff() {
<span class="nc" id="L158">        return ldist.diff;</span>
    }

    public Map&lt;Long, Place&gt; getDist() {
<span class="nc" id="L162">        return ldist.dist;</span>
    }

    public LongDistribution getDistributionLong() {
<span class="nc" id="L166">        return new LongDistribution(getDist());</span>
    }

    /*
     * Get a place where the the corresponding entry of the specified id is stored.
     * Return null when it doesn't exist.
     *
     * @param id a Long type value.
     *
     * @return the Place.
     */
    public Place getPlace(long id) {
<span class="nc" id="L178">        return ldist.dist.get(id);</span>
    }

    @Override
    public void getSizeDistribution(long[] result) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        for (final Map.Entry&lt;Long, Place&gt; entry : ldist.dist.entrySet()) {</span>
<span class="nc" id="L184">            final Place p = entry.getValue();</span>
<span class="nc" id="L185">            result[placeGroup.rank(p)]++;</span>
<span class="nc" id="L186">        }</span>
<span class="nc" id="L187">    }</span>

    /*
     * Return the Set of local ids.
     *
     * @return the Set of local ids.
     */
    public Set&lt;Long&gt; idSet() {
<span class="nc" id="L195">        return keySet();</span>
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSync(Collection&lt;Long&gt; keys, Place dest, MoveManager mm) {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (dest.equals(here())) {</span>
<span class="nc" id="L202">            return;</span>
        }
<span class="nc" id="L204">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L205">        final Serializer serialize = (ObjectOutput s) -&gt; {</span>
<span class="nc" id="L206">            final int size = keys.size();</span>
<span class="nc" id="L207">            s.writeInt(size);</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            for (final Long key : keys) {</span>
<span class="nc" id="L209">                final V value = collection.removeForMove(key);</span>
<span class="nc" id="L210">                final byte mType = ldist.moveOut(key, dest);</span>
<span class="nc" id="L211">                s.writeLong(key);</span>
<span class="nc" id="L212">                s.writeByte(mType);</span>
<span class="nc" id="L213">                s.writeObject(value);</span>
<span class="nc" id="L214">            }</span>
<span class="nc" id="L215">        };</span>
<span class="nc" id="L216">        final DeSerializer deserialize = (ObjectInput ds) -&gt; {</span>
<span class="nc" id="L217">            final int size = ds.readInt();</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L219">                final long key = ds.readLong();</span>
<span class="nc" id="L220">                final byte mType = ds.readByte();</span>
<span class="nc" id="L221">                final V value = (V) ds.readObject();</span>
<span class="nc" id="L222">                collection.putForMove(key, mType, value);</span>
            }
<span class="nc" id="L224">        };</span>
<span class="nc" id="L225">        mm.request(dest, serialize, deserialize);</span>
<span class="nc" id="L226">    }</span>

    @Override
    public void moveAtSync(Distribution&lt;Long&gt; dist, MoveManager mm) {
<span class="nc" id="L230">        final Function&lt;Long, Place&gt; rule = (Long key) -&gt; {</span>
<span class="nc" id="L231">            return dist.place(key);</span>
        };
<span class="nc" id="L233">        moveAtSync(rule, mm);</span>
<span class="nc" id="L234">    }</span>

    @Override
    public void moveAtSync(Function&lt;Long, Place&gt; rule, MoveManager mm) {
<span class="nc" id="L238">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L239">        final HashMap&lt;Place, ArrayList&lt;Long&gt;&gt; keysToMove = new HashMap&lt;&gt;();</span>
<span class="nc" id="L240">        collection.forEach((Long key, V value) -&gt; {</span>
<span class="nc" id="L241">            final Place destination = rule.apply(key);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">            if (!keysToMove.containsKey(destination)) {</span>
<span class="nc" id="L243">                keysToMove.put(destination, new ArrayList&lt;Long&gt;());</span>
            }
<span class="nc" id="L245">            keysToMove.get(destination).add(key);</span>
<span class="nc" id="L246">        });</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">        for (final Place p : keysToMove.keySet()) {</span>
<span class="nc" id="L248">            moveAtSync(keysToMove.get(p), p, mm);</span>
<span class="nc" id="L249">        }</span>
<span class="nc" id="L250">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSync(final long key, Place dest, MoveManager mm) {
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (dest.equals(here())) {</span>
<span class="fc" id="L255">            return;</span>
        }

<span class="fc" id="L258">        final DistIdMap&lt;V&gt; toBranch = this;</span>
<span class="fc" id="L259">        final Serializer serialize = (ObjectOutput s) -&gt; {</span>
<span class="fc" id="L260">            final V value = this.removeForMove(key);</span>
<span class="fc" id="L261">            final byte mType = ldist.moveOut(key, dest);</span>
<span class="fc" id="L262">            s.writeLong(key);</span>
<span class="fc" id="L263">            s.writeByte(mType);</span>
<span class="fc" id="L264">            s.writeObject(value);</span>
<span class="fc" id="L265">        };</span>
<span class="fc" id="L266">        final DeSerializer deserialize = (ObjectInput ds) -&gt; {</span>
<span class="fc" id="L267">            final long k = ds.readLong();</span>
<span class="fc" id="L268">            final byte mType = ds.readByte();</span>
<span class="fc" id="L269">            final V v = (V) ds.readObject();</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            if (_debug_level &gt; 5) {</span>
<span class="nc" id="L271">                System.err.println(&quot;[&quot; + here() + &quot;] putForMove key: &quot; + k + &quot; keyType: &quot; + mType + &quot; value: &quot; + v);</span>
            }
<span class="fc" id="L273">            toBranch.putForMove(k, mType, v);</span>
<span class="fc" id="L274">        };</span>
<span class="fc" id="L275">        mm.request(dest, serialize, deserialize);</span>
<span class="fc" id="L276">    }</span>

    @Override
    public void moveAtSync(Long key, Place dest, MoveManager mm) {
<span class="fc" id="L280">        moveAtSync(key.longValue(), dest, mm);</span>
<span class="fc" id="L281">    }</span>

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void moveAtSyncCount(int count, Place dest, MoveManager mm) {
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (dest.equals(here())) {</span>
<span class="nc" id="L287">            return;</span>
        }
<span class="nc" id="L289">        final DistIdMap&lt;V&gt; collection = this;</span>
<span class="nc" id="L290">        final Serializer serialize = (ObjectOutput s) -&gt; {</span>
<span class="nc" id="L291">            final int size = count;</span>
<span class="nc" id="L292">            s.writeInt(size);</span>
<span class="nc" id="L293">            final long[] keys = new long[size];</span>
<span class="nc" id="L294">            final Object[] values = new Object[size];</span>

<span class="nc" id="L296">            int i = 0;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">            for (final Map.Entry&lt;Long, V&gt; entry : data.entrySet()) {</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">                if (i == size) {</span>
<span class="nc" id="L299">                    break;</span>
                }
<span class="nc" id="L301">                keys[i] = entry.getKey();</span>
<span class="nc" id="L302">                values[i] = entry.getValue();</span>
<span class="nc" id="L303">                i += 1;</span>
<span class="nc" id="L304">            }</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L306">                s.writeLong(keys[j]);</span>
            }
<span class="nc bnc" id="L308" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L309">                s.writeObject(values[j]);</span>
            }
<span class="nc bnc" id="L311" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L312">                final long key = keys[j];</span>
<span class="nc" id="L313">                collection.removeForMove(key);</span>
<span class="nc" id="L314">                final byte mType = ldist.moveOut(key, dest);</span>
<span class="nc" id="L315">                s.writeByte(mType);</span>
            }
<span class="nc" id="L317">        };</span>
<span class="nc" id="L318">        final DeSerializer deserialize = (ObjectInput ds) -&gt; {</span>
<span class="nc" id="L319">            final int size = ds.readInt();</span>
<span class="nc" id="L320">            final long[] keys = new long[size];</span>
<span class="nc" id="L321">            final Object[] values = new Object[size];</span>

<span class="nc bnc" id="L323" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L324">                keys[j] = ds.readLong();</span>
            }
<span class="nc bnc" id="L326" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L327">                values[j] = ds.readObject();</span>
            }
<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L330">                final byte mType = ds.readByte();</span>
<span class="nc" id="L331">                collection.putForMove(keys[j], mType, (V) values[j]);</span>
            }
<span class="nc" id="L333">        };</span>
<span class="nc" id="L334">        mm.request(dest, serialize, deserialize);</span>
<span class="nc" id="L335">    }</span>

    /**
     * Put a new entry into the local map entry
     *
     * @param id    a Long type value.
     * @param value a value.
     */
    public V put(long id, V value) throws Exception {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (data.containsKey(id)) {</span>
<span class="nc" id="L345">            return data.put(id, value);</span>
        }
<span class="fc" id="L347">        ldist.add(id);</span>
<span class="fc" id="L348">        return data.put(id, value);</span>
    }

    private V putForMove(long key, byte mType, V value) throws Exception {
<span class="pc bpc" id="L352" title="2 of 3 branches missed.">        switch (mType) {</span>
        case ElementLocationManager.MOVE_NEW:
<span class="fc" id="L354">            ldist.moveInNew(key);</span>
<span class="fc" id="L355">            break;</span>
        case ElementLocationManager.MOVE_OLD:
<span class="nc" id="L357">            ldist.moveInOld(key);</span>
<span class="nc" id="L358">            break;</span>
        default:
<span class="nc" id="L360">            throw new Exception(&quot;SystemError when calling putForMove &quot; + key);</span>
        }
<span class="fc" id="L362">        return data.put(key, value);</span>
    }

    /*
     * Remove the corresponding value of the specified id.
     *
     * @param id a Long type value.
     */
    public V remove(long id) {
<span class="fc" id="L371">        ldist.remove(id);</span>
<span class="fc" id="L372">        return super.remove(id);</span>
    }

    /*
     * will be implemented in Java using TreeMap public def moveAtSync(range:
     * LongRange, place: Place, mm:MoveManagerLocal) {U haszero}: void {
     *
     * }
     */
    // TODO???
    // public def moveAtSync(dist:Distribution[LongRange], mm:MoveManagerLocal):
    // void {
    // no need for sparse array

    private V removeForMove(long id) {
<span class="fc" id="L387">        return data.remove(id);</span>
    }

    /**
     * Update the distribution information of the entries.
     */
    @Override
    public void updateDist() {
<span class="nc" id="L395">        ldist.updateDist(placeGroup);</span>
<span class="nc" id="L396">    }</span>

    /*
     * public def versioningIdMap(srcName : String){ // return new
     * BranchingManager[DistIdMap[T], Map[Long,T]](srcName, this); return null as
     * BranchingManager[DistIdMap[T], Map[Long, T]]; }
     */

    @Override
    public Object writeReplace() throws ObjectStreamException {
<span class="fc" id="L406">        final TeamedPlaceGroup pg1 = placeGroup;</span>
<span class="fc" id="L407">        final GlobalID id1 = id;</span>
<span class="fc" id="L408">        return new LazyObjectReference&lt;&gt;(pg1, id1, () -&gt; {</span>
<span class="fc" id="L409">            return new DistIdMap&lt;&gt;(pg1, id1);</span>
        });
    }

    /*
     * //TODO different naming convention of balance methods with DistMap public
     * void balance(MoveManagerLocal mm) throws Exception { int pgSize =
     * placeGroup.size(); ArrayList&lt;IntFloatPair&gt; listPlaceLocality = new
     * ArrayList&lt;&gt;(); float localitySum = 0.0f; long globalDataSize =0; long[]
     * localDataSize = new long[pgSize];
     *
     * for (int i = 0; i&lt;locality.length; i++) { localitySum += locality[i]; }
     *
     *
     * for (int i=0; i&lt; pgSize; i++) { globalDataSize += localDataSize[i]; float
     * normalizeLocality = locality[i] / localitySum; listPlaceLocality.add(new
     * IntFloatPair(i, normalizeLocality)); }
     *
     * listPlaceLocality.sort((IntFloatPair a1, IntFloatPair a2)-&gt;{ return
     * (a1.second &lt; a2.second) ? -1 : (a1.second &gt; a1.second) ? 1 : 0; });
     *
     * if (_debug_level &gt; 5) { for (IntFloatPair pair: listPlaceLocality) {
     * System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; + pair.second + &quot;) &quot;); }
     * System.out.println(); placeGroup.barrier(); // for debug print }
     *
     * IntFloatPair[] cumulativeLocality = new IntFloatPair[pgSize]; float
     * sumLocality = 0.0f; for (int i=0; i&lt;pgSize; i++) { sumLocality +=
     * listPlaceLocality.get(i).second; cumulativeLocality[i] = new
     * IntFloatPair(listPlaceLocality.get(i).first, sumLocality); }
     * cumulativeLocality[pgSize - 1] = new
     * IntFloatPair(listPlaceLocality.get(pgSize - 1).first, 1.0f);
     *
     * if (_debug_level &gt; 5) { for (int i=0; i&lt;pgSize; i++) { IntFloatPair pair =
     * cumulativeLocality[i]; System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; + pair.second
     * + &quot;, &quot; + localDataSize[pair.first] + &quot;/&quot; + globalDataSize + &quot;) &quot;); }
     * System.out.println(); placeGroup.barrier(); // for debug print }
     *
     * ArrayList&lt;ArrayList&lt;IntLongPair&gt;&gt; moveList = new ArrayList&lt;&gt;(pgSize); //
     * ArrayList(index of dest Place, num data to export) LinkedList&lt;IntLongPair&gt;
     * stagedData = new LinkedList&lt;&gt;(); // ArrayList(index of src, num data to
     * export) long previousCumuNumData = 0;
     *
     * for (int i=0; i&lt;pgSize; i++) { moveList.add(new ArrayList&lt;IntLongPair&gt;()); }
     *
     * for (int i=0; i&lt;pgSize; i++) { int placeIdx = cumulativeLocality[i].first;
     * float placeLocality = cumulativeLocality[i].second; long cumuNumData = (long)
     * (((float)globalDataSize) * placeLocality); long targetNumData = cumuNumData -
     * previousCumuNumData; if (localDataSize[placeIdx] &gt; targetNumData) {
     * stagedData.add(new IntLongPair(placeIdx, localDataSize[placeIdx] -
     * targetNumData)); if (_debug_level &gt; 5) { System.out.print(&quot;stage src: &quot; +
     * placeIdx + &quot; num: &quot; + (localDataSize[placeIdx] - targetNumData) + &quot;, &quot;); } }
     * previousCumuNumData = cumuNumData; } if (_debug_level &gt; 5) {
     * System.out.println(); placeGroup.barrier(); // for debug print }
     *
     * previousCumuNumData = 0; for (int i=0; i&lt;pgSize; i++) { int placeIdx =
     * cumulativeLocality[i].first; float placeLocality =
     * cumulativeLocality[i].second; long cumuNumData =
     * (long)(((float)globalDataSize) * placeLocality); long targetNumData =
     * cumuNumData - previousCumuNumData; if (targetNumData &gt;
     * localDataSize[placeIdx]) { long numToImport = targetNumData -
     * localDataSize[placeIdx]; while (numToImport &gt; 0) { IntLongPair pair =
     * stagedData.removeFirst(); if (pair.second &gt; numToImport) {
     * moveList.get(pair.first).add(new IntLongPair(placeIdx, numToImport));
     * stagedData.add(new IntLongPair(pair.first, pair.second - numToImport));
     * numToImport = 0; } else { moveList.get(pair.first).add(new
     * IntLongPair(placeIdx, pair.second)); numToImport -= pair.second; } } }
     * previousCumuNumData = cumuNumData; }
     *
     * if (_debug_level &gt; 5) { for (int i=0; i&lt;pgSize; i++) { for (IntLongPair pair:
     * moveList.get(i)) { System.out.print(&quot;src: &quot; + i + &quot; dest: &quot; + pair.first +
     * &quot; size: &quot; + pair.second + &quot;, &quot;); } } System.out.println();
     * placeGroup.barrier(); // for debug print }
     *
     *
     * if (_debug_level &gt; 5) { long[] diffNumData = new long[pgSize]; for (int i=0;
     * i&lt;pgSize; i++) { for (IntLongPair pair: moveList.get(i)) { diffNumData[i] -=
     * pair.second; diffNumData[pair.first] += pair.second; } } for (IntFloatPair
     * pair: listPlaceLocality) { System.out.print(&quot;(&quot; + pair.first + &quot;, &quot; +
     * pair.second + &quot;, &quot; + (localDataSize[pair.first] + diffNumData[pair.first]) +
     * &quot;/&quot; + globalDataSize + &quot;) &quot;); } System.out.println(); placeGroup.barrier();
     * // for debug print }
     *
     * // Move Data for (int i=0; i&lt;pgSize; i++) { if
     * (placeGroup.get(i).equals(here())) {
     *
     * } }
     *
     * }
     *
     * public void balance(float[] newLocality, MoveManagerLocal mm) throws
     * Exception { System.arraycopy(newLocality, 0, locality, 0, placeGroup().size);
     * balance(mm); }
     */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>