<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TeamedPlaceGroup.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">TeamedPlaceGroup.java</span></div><h1>TeamedPlaceGroup.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections.dist;

import static apgas.Constructs.*;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.CountDownLatch;

import apgas.Place;
import apgas.SerializableJob;
import apgas.mpi.MPILauncher;
import apgas.mpi.MPILauncher.Plugin;
import apgas.util.GlobalID;
import apgas.util.SerializableWithReplace;
import handist.collections.dist.util.ObjectInput;
import handist.collections.dist.util.ObjectOutput;
import mpi.Comm;
import mpi.Datatype;
import mpi.Intracomm;
import mpi.MPI;
import mpi.MPIException;
import mpi.Op;

/**
 * Represents a group of hosts and provides communication facilities between
 * hosts.
 * &lt;p&gt;
 * There is always one {@link TeamedPlaceGroup} initialized which contains all
 * the hosts involved in the computation. This instance can be obtained with
 * method {@link #getWorld()}.
 * &lt;p&gt;
 * When creating distributed collections, the hosts that will handle the
 * collections need to be specified with a {@link TeamedPlaceGroup} instance.
 * Such distributed collections can either operate with all the hosts involved
 * in the computation by using the the {@link TeamedPlaceGroup} returned by
 * {@link #getWorld()}, or with a subset of the hosts gathered in a new
 * {@link TeamedPlaceGroup} instance.
 */
public class TeamedPlaceGroup implements SerializableWithReplace {
    // TODO merge with ResilientPlaceGroup ?
    private static final class ObjectReference implements Serializable {
        /** Serial Version UID */
        private static final long serialVersionUID = -1948016251753684732L;
        private final GlobalID id;

        /**
         */
<span class="fc" id="L65">        private ObjectReference(GlobalID id) {</span>
<span class="fc" id="L66">            this.id = id;</span>
<span class="fc" id="L67">        }</span>

        private Object readResolve() throws ObjectStreamException {
<span class="fc" id="L70">            return id.getHere();</span>
        }
    }

    // TODO
<span class="fc" id="L75">    public static boolean debugF = false;</span>

<span class="fc" id="L77">    static boolean isRegistered = false;</span>

    static private volatile CountDownLatch readyToCloseWorld;

    static TeamedPlaceGroup world;

    public static TeamedPlaceGroup getWorld() {
<span class="fc" id="L84">        return world;</span>
    }

    private static void readyToClose(boolean master) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (master) {</span>
<span class="fc" id="L89">            finish(() -&gt; {</span>
<span class="fc" id="L90">                world.broadcastFlat(() -&gt; {</span>
<span class="fc" id="L91">                    readyToCloseWorld.countDown();</span>
<span class="fc" id="L92">                });</span>
<span class="fc" id="L93">            });</span>
        } else {
            try {
<span class="fc" id="L96">                readyToCloseWorld.await();</span>
<span class="nc" id="L97">            } catch (final InterruptedException e) {</span>
<span class="nc" id="L98">                System.err.println(&quot;[TeamedPlaceGroup#readyToClose] Error: readyToClose was interrupted at rank [&quot;</span>
                        + world.myrank + &quot;]&quot;);
<span class="fc" id="L100">            }</span>
        }
<span class="fc" id="L102">    }</span>

    /**
     * Method that needs to be called on every host participating in the computation
     * before the {@link MPILauncher} is started. This method registers a &quot;plugin&quot;
     * with {@link MPILauncher#registerPlugin(Plugin)} which handles specific setup
     * needed by the distributed collection library.
     */
    public static void setup() {
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">        if (isRegistered) {</span>
<span class="nc" id="L112">            return;</span>
        }
<span class="fc" id="L114">        MPILauncher.registerPlugin(new Plugin() {</span>
            @Override
            public void beforeFinalize(int rank, Comm comm) {
<span class="fc bfc" id="L117" title="All 2 branches covered.">                readyToClose(rank == 0);</span>
<span class="fc" id="L118">            }</span>

            @Override
            public String getName() {
<span class="nc" id="L122">                return TeamedPlaceGroup.class.toString();</span>
            }

            @Override
            public void init(int rank, Comm comm) throws MPIException {
<span class="fc" id="L127">                worldSetup();</span>
<span class="fc" id="L128">            }</span>
        });
<span class="fc" id="L130">        isRegistered = true;</span>
<span class="fc" id="L131">    }</span>

    /**
     * Called by {@link MPILauncher} through the plugin submitted in method
     * {@link #setup()}.
     *
     * @throws MPIException if such an exception is thrown during setup
     */
    private static void worldSetup() throws MPIException {
<span class="fc" id="L140">        final int myrank = MPI.COMM_WORLD.Rank();</span>
<span class="fc" id="L141">        final int size = MPI.COMM_WORLD.Size();</span>
<span class="fc" id="L142">        final int[] rank2place = new int[size];</span>
<span class="fc" id="L143">        final Place here = here();</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (debugF) {</span>
<span class="nc" id="L145">            System.out.println(&quot;world setup: rank=&quot; + myrank + &quot;, place&quot; + here + &quot;::&quot; + here.id);</span>
        }
<span class="fc" id="L147">        rank2place[myrank] = here.id;</span>
<span class="fc" id="L148">        MPI.COMM_WORLD.Allgather(rank2place, myrank, 1, MPI.INT, rank2place, 0, 1, MPI.INT);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (int i = 0; i &lt; rank2place.length; i++) {</span>
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            if (debugF) {</span>
<span class="nc" id="L151">                System.out.println(&quot;ws: &quot; + i + &quot;:&quot; + rank2place[i] + &quot;@&quot; + myrank);</span>
            }
        }
        GlobalID id;
<span class="fc bfc" id="L155" title="All 2 branches covered.">        if (myrank == 0) { // we could use here() as an alternative</span>
<span class="fc" id="L156">            id = new GlobalID();</span>
<span class="fc" id="L157">            final ByteArrayOutputStream out0 = new ByteArrayOutputStream();</span>
<span class="fc" id="L158">            final ObjectOutput out = new ObjectOutput(out0);</span>
<span class="fc" id="L159">            out.writeObject(id);</span>
<span class="fc" id="L160">            out.close();</span>
<span class="fc" id="L161">            final byte[] buf = out0.toByteArray();</span>
<span class="fc" id="L162">            final int[] buf0 = new int[1];</span>
<span class="fc" id="L163">            buf0[0] = buf.length;</span>

<span class="fc" id="L165">            MPI.COMM_WORLD.Bcast(buf0, 0, 1, MPI.INT, 0);</span>
<span class="fc" id="L166">            readyToCloseWorld = new CountDownLatch(1);</span>
<span class="fc" id="L167">            MPI.COMM_WORLD.Bcast(buf, 0, buf0[0], MPI.BYTE, 0);</span>
<span class="fc" id="L168">        } else {</span>
<span class="fc" id="L169">            final int[] buf0 = new int[1];</span>
<span class="fc" id="L170">            MPI.COMM_WORLD.Bcast(buf0, 0, 1, MPI.INT, 0);</span>
<span class="fc" id="L171">            final byte[] buf = new byte[buf0[0]];</span>
<span class="fc" id="L172">            readyToCloseWorld = new CountDownLatch(1);</span>
<span class="fc" id="L173">            MPI.COMM_WORLD.Bcast(buf, 0, buf0[0], MPI.BYTE, 0);</span>
<span class="fc" id="L174">            final ObjectInput in = new ObjectInput(new ByteArrayInputStream(buf));</span>
            try {
<span class="fc" id="L176">                id = (GlobalID) in.readObject();</span>
<span class="nc" id="L177">            } catch (final Exception e) {</span>
<span class="nc" id="L178">                throw new Error(&quot;[TeamedPlaceGroup] init error at worker&quot;, e);</span>
            } finally {
<span class="fc" id="L180">                in.close();</span>
            }
        }
<span class="fc" id="L183">        world = new TeamedPlaceGroup(id, myrank, size, rank2place);</span>
        /*
         * PlaceLocalObject.make(places(), ()-&gt;{ return new TeamedPlaceGroup().init();
         * });
         */
<span class="fc" id="L188">    }</span>

    /**
     * Direct access to MPI functions is absolutely discouraged. This member will be
     * made private with intermediate access in the future.
     */
    /*
     * TODO this needs refactoring -&gt; make this member private
     */
    @Deprecated
    public Intracomm comm;

    private final GlobalID id;
    final int myrank;

    private TeamedPlaceGroup parent;

    List&lt;Place&gt; places;

    // int[] place2rank;
    int size;

    /**
     * Proctected constructor used by class {@link SinglePlaceGroup} exclusively
     * &lt;p&gt;
     * This constructor initializes the members of {@link TeamedPlaceGroup} such
     * that a single place (the place on which this method is called) is contained
     * in the group.
     */
<span class="fc" id="L217">    protected TeamedPlaceGroup() {</span>
<span class="fc" id="L218">        id = null;</span>
<span class="fc" id="L219">        myrank = 0;</span>
<span class="fc" id="L220">        size = 1;</span>
<span class="fc" id="L221">        places = new ArrayList&lt;&gt;(size);</span>
<span class="fc" id="L222">        comm = null;</span>
<span class="fc" id="L223">        places.add(here());</span>
<span class="fc" id="L224">    }</span>

    /**
     * Constructor that builds a {@link TeamedPlaceGroup} instance which contains
     * all the hosts that participate in the computation
     *
     * @param id         a global id for this handle
     * @param myrank     the rank of this host in the world
     * @param size       number of hosts in the world
     * @param rank2place correspondance array between {@link Place} number and MPI
     *                   rank
     */
<span class="fc" id="L236">    protected TeamedPlaceGroup(GlobalID id, int myrank, int size, int[] rank2place) { // for whole_world</span>
<span class="fc" id="L237">        this.id = id;</span>
<span class="fc" id="L238">        this.size = size;</span>
<span class="fc" id="L239">        this.myrank = myrank;</span>
<span class="fc" id="L240">        places = new ArrayList&lt;&gt;(size);</span>
<span class="fc" id="L241">        comm = MPI.COMM_WORLD;</span>
        // this.place2rank = new int[size];
<span class="fc bfc" id="L243" title="All 2 branches covered.">        for (int i = 0; i &lt; rank2place.length; i++) {</span>
<span class="fc" id="L244">            final int p = rank2place[i];</span>
<span class="fc" id="L245">            places.add(new Place(p));</span>
            // place2rank[p] = i;
        }
<span class="fc" id="L248">        id.putHere(this);</span>
<span class="fc" id="L249">        parent = null;</span>
<span class="fc" id="L250">    }</span>

<span class="fc" id="L252">    protected TeamedPlaceGroup(GlobalID id, int myrank, List&lt;Place&gt; places, Intracomm comm, TeamedPlaceGroup parent) {</span>
<span class="fc" id="L253">        this.id = id;</span>
<span class="fc" id="L254">        size = places.size();</span>
<span class="fc" id="L255">        this.myrank = myrank;</span>
<span class="fc" id="L256">        this.comm = comm;</span>
<span class="fc" id="L257">        this.places = places;</span>
<span class="fc" id="L258">        this.parent = parent;</span>
<span class="fc" id="L259">        id.putHere(this);</span>
<span class="fc" id="L260">    }</span>

    /**
     * Gathers one double variable from all places, wrapping MPI#Allgather.
     *
     * @param val the value to gather.
     * @return an array storing gathered values to.
     */
    public double[] allGather1(double val) {
<span class="fc" id="L269">        final double[] send = new double[] { val };</span>
<span class="fc" id="L270">        final double[] recv = new double[size];</span>
<span class="fc" id="L271">        comm.Allgather(send, 0, 1, MPI.DOUBLE, recv, 0, 1, MPI.DOUBLE);</span>
<span class="fc" id="L272">        return recv;</span>
    }

    /**
     * Gathers one float variable from all places, wrapping MPI#Allgather.
     *
     * @param val the value to gather.
     * @return an array storing gathered values to.
     */
    public float[] allGather1(float val) {
<span class="fc" id="L282">        final float[] send = new float[] { val };</span>
<span class="fc" id="L283">        final float[] recv = new float[size];</span>
<span class="fc" id="L284">        comm.Allgather(send, 0, 1, MPI.FLOAT, recv, 0, 1, MPI.FLOAT);</span>
<span class="fc" id="L285">        return recv;</span>
    }

    /**
     * Gathers one int variable from all places, wrapping MPI#Allgather.
     *
     * @param val the value to gather.
     * @return an array storing gathered values to.
     */
    public int[] allGather1(int val) {
<span class="fc" id="L295">        final int[] send = new int[] { val };</span>
<span class="fc" id="L296">        final int[] recv = new int[size];</span>
<span class="fc" id="L297">        comm.Allgather(send, 0, 1, MPI.INT, recv, 0, 1, MPI.INT);</span>
<span class="fc" id="L298">        return recv;</span>
    }

    /**
     * Gathers one long variable from all places, wrapping MPI#Allgather.
     *
     * @param val the value to gather.
     * @return an array storing gathered values to.
     */
    public long[] allGather1(long val) {
<span class="fc" id="L308">        final long[] send = new long[] { val };</span>
<span class="fc" id="L309">        final long[] recv = new long[size];</span>
<span class="fc" id="L310">        comm.Allgather(send, 0, 1, MPI.LONG, recv, 0, 1, MPI.LONG);</span>
<span class="fc" id="L311">        return recv;</span>
    }

    /**
     * Gathers one short variable from all places, wrapping MPI#Allgather.
     *
     * @param val tha value to gather.
     * @return an array storing gathered values to.
     */
    public short[] allGather1(short val) {
<span class="fc" id="L321">        final short[] send = new short[] { val };</span>
<span class="fc" id="L322">        final short[] recv = new short[size];</span>
<span class="fc" id="L323">        comm.Allgather(send, 0, 1, MPI.SHORT, recv, 0, 1, MPI.SHORT);</span>
<span class="fc" id="L324">        return recv;</span>
    }

    /**
     * Combine one double value of each process using the reduce operation, and
     * return the combined value of the all process.
     *
     * @param val send value.
     * @param op  reduce operation.
     * @return the combined value.
     */
    public double allReduce1(double val, Op op) {
<span class="fc" id="L336">        final double[] v = new double[] { val };</span>
<span class="fc" id="L337">        comm.Allreduce(v, 0, v, 0, 1, MPI.DOUBLE, op);</span>
<span class="fc" id="L338">        return v[0];</span>
    }

    /**
     * Combine one float value of each process using the reduce operation, and
     * return the combined value of the all process.
     *
     * @param val send value.
     * @param op  reduce operation.
     * @return the combined value.
     */
    public float allReduce1(float val, Op op) {
<span class="fc" id="L350">        final float[] v = new float[] { val };</span>
<span class="fc" id="L351">        comm.Allreduce(v, 0, v, 0, 1, MPI.FLOAT, op);</span>
<span class="fc" id="L352">        return v[0];</span>
    }

    /**
     * Combine one int value of each process using the reduce operation, and return
     * the combined value of the all process.
     *
     * @param val send value.
     * @param op  reduce operation.
     * @return the combined value.
     */
    public int allReduce1(int val, Op op) {
<span class="fc" id="L364">        final int[] v = new int[] { val };</span>
<span class="fc" id="L365">        comm.Allreduce(v, 0, v, 0, 1, MPI.INT, op);</span>
<span class="fc" id="L366">        return v[0];</span>
    }

    /**
     * Combine one long value of each process using the reduce operation, and return
     * the combined value of the all process.
     *
     * @param val send value.
     * @param op  reduce operation.
     * @return the combined value.
     */
    public long allReduce1(long val, Op op) {
<span class="fc" id="L378">        final long[] v = new long[] { val };</span>
<span class="fc" id="L379">        comm.Allreduce(v, 0, v, 0, 1, MPI.LONG, op);</span>
<span class="fc" id="L380">        return v[0];</span>
    }

    /**
     * Combine one short value of each process using the reduce operation, and
     * return the combined value of the all process.
     *
     * @param val send value.
     * @param op  reduce operation.
     * @return the combined value.
     */
    public short allReduce1(short val, Op op) {
<span class="fc" id="L392">        final short[] v = new short[] { val };</span>
<span class="fc" id="L393">        comm.Allreduce(v, 0, v, 0, 1, MPI.SHORT, op);</span>
<span class="fc" id="L394">        return v[0];</span>
    }

    @SuppressWarnings(&quot;unused&quot;)
    public void Alltoallv(Object byteArray, int soffset, int[] sendSize, int[] sendOffset, Datatype stype,
            Object recvbuf, int roffset, int[] rcvSize, int[] rcvOffset, Datatype rtype) throws MPIException {
        if (false) {
            comm.Alltoallv(byteArray, soffset, sendSize, sendOffset, stype, recvbuf, roffset, rcvSize, rcvOffset,
                    rtype);
        } else {
<span class="fc bfc" id="L404" title="All 2 branches covered.">            for (int rank = 0; rank &lt; rcvSize.length; rank++) {</span>
<span class="fc" id="L405">                comm.Gatherv(byteArray, soffset + sendOffset[rank], sendSize[rank], stype, recvbuf, roffset, rcvSize,</span>
                        rcvOffset, rtype, rank);
            }
        }
<span class="fc" id="L409">    }</span>

    public void barrier() {
        try {
<span class="nc" id="L413">            comm.Barrier();</span>
<span class="nc" id="L414">        } catch (final MPIException e) {</span>
<span class="nc" id="L415">            e.printStackTrace();</span>
<span class="nc" id="L416">            throw new Error(&quot;[TeamedPlaceGroup] MPI Exception raised.&quot;);</span>
<span class="nc" id="L417">        }</span>
<span class="nc" id="L418">    }</span>

    /**
     * Broadcast one double value from the root place to all processes of the group.
     *
     * @param val  sent value from the root place. In other places, the value will
     *             be ignored.
     * @param root broadcast a value from the place.
     * @return If the root place, return val and if other places, return recieved
     *         value.
     */
    public double bCast1(double val, Place root) {
<span class="fc" id="L430">        final double[] v = new double[] { val };</span>
<span class="fc" id="L431">        comm.Bcast(v, 0, 1, MPI.DOUBLE, rank(root));</span>
<span class="fc" id="L432">        return v[0];</span>
    }

    /**
     * Broadcast one float value from the root place to all processes of the group.
     *
     * @param val  sent value from the root place. In other places, the value will
     *             be ignored.
     * @param root broadcast a value from the place.
     * @return If the root place, return val and if other places, return recieved
     *         value.
     */
    public float bCast1(float val, Place root) {
<span class="fc" id="L445">        final float[] v = new float[] { val };</span>
<span class="fc" id="L446">        comm.Bcast(v, 0, 1, MPI.FLOAT, rank(root));</span>
<span class="fc" id="L447">        return v[0];</span>
    }

    /**
     * Broadcast one int value from the root place to all processes of the group.
     *
     * @param val  sent value from the root place. In other places, the value will
     *             be ignored.
     * @param root broadcast a value from the place.
     * @return If the root place, return val and if other places, return recieved
     *         value.
     */
    public int bCast1(int val, Place root) {
<span class="fc" id="L460">        final int[] v = new int[] { val };</span>
<span class="fc" id="L461">        comm.Bcast(v, 0, 1, MPI.INT, rank(root));</span>
<span class="fc" id="L462">        return v[0];</span>
    }

    /**
     * Broadcast one long value from the root place to all processes of the group.
     *
     * @param val  sent value from the root place. In other places, the value will
     *             be ignored.
     * @param root broadcast a value from the place.
     * @return If the root place, return val and if other places, return recieved
     *         value.
     */
    public long bCast1(long val, Place root) {
<span class="fc" id="L475">        final long[] v = new long[] { val };</span>
<span class="fc" id="L476">        comm.Bcast(v, 0, 1, MPI.LONG, rank(root));</span>
<span class="fc" id="L477">        return v[0];</span>
    }

    /**
     * Broadcast one short value from the root place to all processes of the group.
     *
     * @param val  sent value from the root place. In other places, the value will
     *             be ignored.
     * @param root broadcast a value from the place.
     * @return If the root place, return val and if other places, return recieved
     *         value.
     */
    public short bCast1(short val, Place root) {
<span class="fc" id="L490">        final short[] v = new short[] { val };</span>
<span class="fc" id="L491">        comm.Bcast(v, 0, 1, MPI.SHORT, rank(root));</span>
<span class="fc" id="L492">        return v[0];</span>
    }

    /**
     * Makes the specified job run on all the hosts of this {@link TeamedPlaceGroup}
     * and returns when this it has terminated on all the hosts.
     *
     * @param job the job to run
     */
    public void broadcastFlat(SerializableJob job) {
        // TODO
<span class="fc" id="L503">        finish(() -&gt; {</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">            for (final Place p : places()) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                if (!p.equals(here())) {</span>
<span class="fc" id="L506">                    asyncAt(p, job);</span>
                }
<span class="fc" id="L508">            }</span>
<span class="fc" id="L509">            job.run();</span>
<span class="fc" id="L510">        });</span>
<span class="fc" id="L511">    }</span>

    /**
     * Gathers one double variable from all places, wrapping MPI#gather.
     *
     * @param val  the value to gather.
     * @param root gather values from all places to the root.
     * @return If at the root place, return an array storing gathered values to. At
     *         other places, return null.
     */
    public double[] gather1(double val, Place root) {
<span class="fc" id="L522">        final double[] v = new double[] { val };</span>
<span class="fc" id="L523">        final double[] recv = new double[size];</span>
<span class="fc" id="L524">        comm.Gather(v, 0, 1, MPI.DOUBLE, recv, 0, 1, MPI.DOUBLE, rank(root));</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">        return (root.equals(here())) ? recv : null;</span>
    }

    /**
     * Gathers one float variable from all places, wrapping MPI#gather.
     *
     * @param val  the value to gather.
     * @param root gather values from all places to the root.
     * @return If at the root place, return an array storing gathered values to. At
     *         other places, return null.
     */
    public float[] gather1(float val, Place root) {
<span class="fc" id="L537">        final float[] v = new float[] { val };</span>
<span class="fc" id="L538">        final float[] recv = new float[size];</span>
<span class="fc" id="L539">        comm.Gather(v, 0, 1, MPI.FLOAT, recv, 0, 1, MPI.FLOAT, rank(root));</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        return (root.equals(here())) ? recv : null;</span>
    }

    /**
     * Gathers one int variable from all places, wrapping MPI#gather.
     *
     * @param val  the value to gather.
     * @param root gather values from all places to the root.
     * @return If at the root place, return an array storing gathered values to. At
     *         other places, return null.
     */
    public int[] gather1(int val, Place root) {
<span class="fc" id="L552">        final int[] v = new int[] { val };</span>
<span class="fc" id="L553">        final int[] recv = new int[size];</span>
<span class="fc" id="L554">        comm.Gather(v, 0, 1, MPI.INT, recv, 0, 1, MPI.INT, rank(root));</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">        return (root.equals(here())) ? recv : null;</span>
    }

    /**
     * Gathers one long variable from all places, wrapping MPI#gather.
     *
     * @param val  the value to gather.
     * @param root gather values from all places to the root.
     * @return If at the root place, return an array storing gathered values to. At
     *         other places, return null.
     */
    public long[] gather1(long val, Place root) {
<span class="fc" id="L567">        final long[] v = new long[] { val };</span>
<span class="fc" id="L568">        final long[] recv = new long[size];</span>
<span class="fc" id="L569">        comm.Gather(v, 0, 1, MPI.LONG, recv, 0, 1, MPI.LONG, rank(root));</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        return (root.equals(here())) ? recv : null;</span>
    }

    /**
     * Gathers one short variable from all places, wrapping MPI#gather.
     *
     * @param val  the value to gather.
     * @param root gather values from all places to the root.
     * @return If at the root place, return an array storing gathered values to. At
     *         other places, return null.
     */
    public short[] gather1(short val, Place root) {
<span class="fc" id="L582">        final short[] v = new short[] { val };</span>
<span class="fc" id="L583">        final short[] recv = new short[size];</span>
<span class="fc" id="L584">        comm.Gather(v, 0, 1, MPI.SHORT, recv, 0, 1, MPI.SHORT, rank(root));</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">        return (root.equals(here())) ? recv : null;</span>
    }

    public Place get(int rank) {
<span class="fc" id="L589">        return places.get(rank);</span>
    }

    /**
     * Returns the &quot;parent&quot; of this {@link TeamedPlaceGroup}, or {@code null} if
     * there is no such parent
     *
     * @return the parent of this {@link TeamedPlaceGroup}
     */
    public TeamedPlaceGroup getParent() {
<span class="nc" id="L599">        return parent;</span>
    }

    /**
     * TODO is this method redundant? should we delete it?
     *
     * @return this
     */
    protected TeamedPlaceGroup init() {
        // TODO
        // setup MPI
        /*
         * if(!MPI.Initialized()) { throw new
         * Error(&quot;[TeamedPlaceGroup] Please setup MPI first&quot;); }
         */
        // setup arrays
        // setup rank2place
        // share the infromation
        // set this to singleton
<span class="nc" id="L618">        return this;</span>
    }

    public List&lt;Place&gt; places() {
<span class="fc" id="L622">        return places;</span>
    }

    /**
     * Returns the MPI rank of the calling host in the current
     * {@link TeamedPlaceGroup}.
     *
     * @return rank of this host within the {@link TeamedPlaceGroup}
     */
    public int rank() {
<span class="fc" id="L632">        return myrank;</span>
    }

    /**
     * Returns the MPI rank of the specified place in the current
     * {@link TeamedPlaceGroup}. If the specified place is not a member of this
     * {@link TeamedPlaceGroup}, throws a {@link RuntimeException}.
     *
     * @param place place whose rank is to be returned
     * @return rank of this host within the {@link TeamedPlaceGroup}
     * @throws RuntimeException if the specified place is not a member of this group
     */
    public int rank(Place place) {
<span class="fc" id="L645">        final int result = places.indexOf(place);</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (result &lt; 0) {</span>
<span class="nc" id="L647">            throw new RuntimeException(&quot;[TeamedPlaceGroup] &quot; + place + &quot; is not a member of &quot; + this);</span>
        }
<span class="fc" id="L649">        return result;</span>
    }

    /**
     *
     * Combine one int value of each process using the reduce operation, and return
     * the combined value of the root process.
     *
     * @param val  send value.
     * @param op   reduce operation.
     * @param root combined value is returned only the root place.
     * @return at root place, the combined value. at other places, return val as it
     *         is.
     */
    public double reduce1(double val, Op op, Place root) {
<span class="fc" id="L664">        final double[] v = new double[] { val };</span>
<span class="fc" id="L665">        comm.Reduce(v, 0, v, 0, 1, MPI.DOUBLE, op, rank(root));</span>
<span class="fc" id="L666">        return v[0];</span>
    }

    /**
     *
     * Combine one float value of each process using the reduce operation, and
     * return the combined value of the root process.
     *
     * @param val  send value.
     * @param op   reduce operation.
     * @param root combined value is returned only the root place.
     * @return at root place, the combined value. at other places, return val as it
     *         is.
     */
    public float reduce1(float val, Op op, Place root) {
<span class="fc" id="L681">        final float[] v = new float[] { val };</span>
<span class="fc" id="L682">        comm.Reduce(v, 0, v, 0, 1, MPI.FLOAT, op, rank(root));</span>
<span class="fc" id="L683">        return v[0];</span>
    }

    /**
     *
     * Combine one int value of each process using the reduce operation, and return
     * the combined value of the root process.
     *
     * @param val  send value.
     * @param op   reduce operation.
     * @param root combined value is returned only the root place.
     * @return at root place, the combined value. at other places, return val as it
     *         is.
     */
    public int reduce1(int val, Op op, Place root) {
<span class="fc" id="L698">        final int[] v = new int[] { val };</span>
<span class="fc" id="L699">        comm.Reduce(v, 0, v, 0, 1, MPI.INT, op, rank(root));</span>
<span class="fc" id="L700">        return v[0];</span>
    }

    /**
     *
     * Combine one long value of each process using the reduce operation, and return
     * the combined value of the root process.
     *
     * @param val  send value.
     * @param op   reduce operation.
     * @param root combined value is returned only the root place.
     * @return at root place, the combined value. at other places, return val as it
     *         is.
     */
    public long reduce1(long val, Op op, Place root) {
<span class="fc" id="L715">        final long[] v = new long[] { val };</span>
<span class="fc" id="L716">        comm.Reduce(v, 0, v, 0, 1, MPI.LONG, op, rank(root));</span>
<span class="fc" id="L717">        return v[0];</span>
    }

    /**
     *
     * Combine one short value of each process using the reduce operation, and
     * return the combined value of the root process.
     *
     * @param val  send value.
     * @param op   reduce operation.
     * @param root combined value is returned only the root place.
     * @return at root place, the combined value. at other places, return val as it
     *         is.
     */
    public short reduce1(short val, Op op, Place root) {
<span class="fc" id="L732">        final short[] v = new short[] { val };</span>
<span class="fc" id="L733">        comm.Reduce(v, 0, v, 0, 1, MPI.SHORT, op, rank(root));</span>
<span class="fc" id="L734">        return v[0];</span>
    }

    // TODO
    // split, relocate feature
    public void remove(GlobalID id) {
        // TODO

<span class="fc" id="L742">    }</span>

    /**
     * Returns the number of hosts that are members of this
     * {@link TeamedPlaceGroup}.
     *
     * @return number of hosts in the group
     */
    public int size() {
<span class="fc" id="L751">        return size;</span>
    }

    public TeamedPlaceGroup split(SortedMap&lt;Integer, Integer&gt; rank2color) {
        try {
<span class="fc" id="L756">            final int newColor = rank2color.get(myrank);</span>
<span class="fc" id="L757">            int newRank = 0;</span>
<span class="fc" id="L758">            final List&lt;Place&gt; newPlaces = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">            for (final Map.Entry&lt;Integer, Integer&gt; entry : rank2color.entrySet()) {</span>
<span class="fc" id="L760">                final int r = entry.getKey();</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">                if (entry.getValue().equals(newColor)) {</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">                    if (r == myrank) {</span>
<span class="fc" id="L763">                        newRank = newPlaces.size();</span>
                    }
<span class="fc" id="L765">                    newPlaces.add(places.get(r));</span>
                }
<span class="fc" id="L767">            }</span>
<span class="fc" id="L768">            final Intracomm newComm = comm.Split(newColor, newRank); // MPIException</span>
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">            if (debugF) {</span>
<span class="nc" id="L770">                System.out.println(&quot;PlaceGroup split =&quot; + newRank + &quot;, place&quot; + here() + &quot;::&quot; + here().id);</span>
            }
            GlobalID id;
<span class="fc bfc" id="L773" title="All 2 branches covered.">            if (newRank == 0) {</span>
<span class="fc" id="L774">                id = new GlobalID();</span>
<span class="fc" id="L775">                final ByteArrayOutputStream out0 = new ByteArrayOutputStream();</span>
<span class="fc" id="L776">                final ObjectOutput out = new ObjectOutput(out0);</span>
<span class="fc" id="L777">                out.writeObject(id);</span>
<span class="fc" id="L778">                out.close();</span>
<span class="fc" id="L779">                final byte[] buf = out0.toByteArray();</span>
<span class="fc" id="L780">                final int[] buf0 = new int[1];</span>
<span class="fc" id="L781">                buf0[0] = buf.length;</span>
<span class="fc" id="L782">                newComm.Bcast(buf0, 0, 1, MPI.INT, 0);</span>
<span class="fc" id="L783">                newComm.Bcast(buf, 0, buf0[0], MPI.BYTE, 0);</span>
<span class="fc" id="L784">            } else {</span>
<span class="fc" id="L785">                final int[] buf0 = new int[1];</span>
<span class="fc" id="L786">                newComm.Bcast(buf0, 0, 1, MPI.INT, 0);</span>
<span class="fc" id="L787">                final byte[] buf = new byte[buf0[0]];</span>
<span class="fc" id="L788">                newComm.Bcast(buf, 0, buf0[0], MPI.BYTE, 0);</span>
<span class="fc" id="L789">                final ObjectInput in = new ObjectInput(new ByteArrayInputStream(buf));</span>
                try {
<span class="fc" id="L791">                    id = (GlobalID) in.readObject();</span>
<span class="nc" id="L792">                } catch (final Exception e) {</span>
<span class="nc" id="L793">                    throw new Error(&quot;[TeamedPlaceGroup] init error at worker&quot;);</span>
                } finally {
<span class="fc" id="L795">                    in.close();</span>
                }
            }
<span class="fc" id="L798">            return new TeamedPlaceGroup(id, newRank, newPlaces, newComm, this);</span>
            /*
             * PlaceLocalObject.make(places(), ()-&gt;{ return new TeamedPlaceGroup().init();
             * });
             */
<span class="nc" id="L803">        } catch (final MPIException e) {</span>
<span class="nc" id="L804">            throw new RuntimeException(&quot;[TeamedPlaceGroup] MPIException caught.&quot;);</span>
        }
    }
    /*
     * TODO: Is close() needed? What close() should do? public void close() {
     * comm.Free(); }
     */

    /**
     * Creates a new TeamedPlaceGroup from this instance containing half of the
     * places involved in this instance
     *
     * @return a new TeamedPlaceGroup
     */
    public TeamedPlaceGroup splitHalf() {
<span class="fc" id="L819">        final TreeMap&lt;Integer, Integer&gt; rank2color = new TreeMap&lt;&gt;();</span>
<span class="pc bpc" id="L820" title="1 of 2 branches missed.">        if (size() == 1) {</span>
<span class="nc" id="L821">            throw new RuntimeException(</span>
                    &quot;[TeamedPlaceGroup] TeamedPlaceGroup with size == 1 cannnot be split any further&quot;);
        }
<span class="fc" id="L824">        final int half = size() / 2;</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">        for (int i = 0; i &lt; half; i++) {</span>
<span class="fc" id="L826">            rank2color.put(i, 0);</span>
        }
<span class="fc bfc" id="L828" title="All 2 branches covered.">        for (int i = half; i &lt; size(); i++) {</span>
<span class="fc" id="L829">            rank2color.put(i, 1);</span>
        }
<span class="fc" id="L831">        return split(rank2color);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L836">        return &quot;TeamedPlaceGroup[&quot; + id + &quot;, myrank:&quot; + myrank + &quot;, places:&quot; + places() + &quot;]&quot;;</span>
    }

    public Object writeReplace() throws ObjectStreamException {
<span class="fc" id="L840">        return new ObjectReference(id);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>