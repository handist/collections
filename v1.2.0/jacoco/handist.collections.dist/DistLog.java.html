<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DistLog.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">DistLog.java</span></div><h1>DistLog.java</h1><pre class="source lang-java linenums">package handist.collections.dist;

import static apgas.Constructs.*;
import static handist.collections.util.StringUtilities.*;

import java.io.PrintStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;

import apgas.Constructs;
import apgas.Place;
import apgas.util.GlobalID;
import handist.collections.dist.util.Pair;
import handist.collections.function.SerializableBiFunction;

/**
 * DistLog is a distributed log manager. It collects log on places and gather it
 * to a place.
 *
 * Each DistLog instance refers to a distributed collection having global ID and
 * you can arbitrary copy it to other places.
 *
 * It offers a static method {@code DistLog.log(tag, msg)}. Please call
 * `DistLog.globalSetup(DistLog)` first, otherwise the method only print the
 * {@code tag} and {@code msg} to {@code System.out}.
 *
 */
<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public class DistLog extends DistCollectionSatellite&lt;DistConcurrentMultiMap&lt;DistLog.LogKey, DistLog.LogItem&gt;, DistLog&gt;</span>
        implements Serializable {

    static class ListDiff {
        int index;
        LogItem first;
        LogItem second;

<span class="nc" id="L46">        public ListDiff(int index, LogItem first, LogItem second) {</span>
<span class="nc" id="L47">            this.index = index;</span>
<span class="nc" id="L48">            this.first = first;</span>
<span class="nc" id="L49">            this.second = second;</span>
<span class="nc" id="L50">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L54">            return &quot;Elements (No. &quot; + index + &quot;) differ: &quot; + first + &quot;, &quot; + second;</span>
        }
    }

    /**
     * Class used to represent information logged. Logged information takes the
     * shape of a message and an optional &quot;appendix&quot;. Logged items can be compared
     * to one-another, but only the message value is considered. The appendix may
     * differ between two instances but the two logged items may still be equal.
     */
    public static class LogItem implements Serializable {
        private static final long serialVersionUID = -1365865614858381506L;
<span class="fc" id="L66">        public static Comparator&lt;LogItem&gt; cmp = Comparator.nullsFirst(Comparator.comparing(i0 -&gt; i0.msg));</span>
<span class="fc" id="L67">        public static boolean appendixPrint = true;</span>
        public final String msg;
        public final String appendix;

<span class="fc" id="L71">        LogItem(String message, String appendix) {</span>
<span class="fc" id="L72">            msg = message;</span>
<span class="fc" id="L73">            this.appendix = appendix;</span>
<span class="fc" id="L74">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">            if (!(obj instanceof LogItem)) {</span>
<span class="nc" id="L79">                return false;</span>
            }
<span class="fc" id="L81">            return msg.equals(((LogItem) obj).msg);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L86">            return msg.hashCode();</span>
        }

        @Override
        public String toString() {

<span class="pc bpc" id="L92" title="1 of 2 branches missed.">            if (appendixPrint) {</span>
<span class="nc" id="L93">                return &quot;LogItem:&quot; + msg + &quot;, &quot; + appendix;</span>
            } else {
<span class="fc" id="L95">                return &quot;LogItem:&quot; + msg;</span>
            }
        }
    }

    /**
     * Class used as a key to record elements in a {@link DistLog}. A {@link LogKey}
     * is a combination of a {@link Place}, a {@link String} tag, and a {@code long}
     * phase tuple.
     */
    public static final class LogKey implements Serializable, Comparable&lt;LogKey&gt; {

        /** Serial Version UID */
        private static final long serialVersionUID = -7799219001690238705L;

        /** Place on which the record was made */
        public final Place place;
        /** Tag, or topic under which the record was made */
        public final String tag;

        /** Phase during which the record was made */
        public final long phase;

        /**
         * Constructor
         *
         * @param p     place on which the record is recorded
         * @param tag   the subject tag for the record
         * @param phase the phase during which the record is made
         */
<span class="fc" id="L125">        public LogKey(Place p, String tag, long phase) {</span>
<span class="fc" id="L126">            place = p;</span>
<span class="fc" id="L127">            this.tag = tag;</span>
<span class="fc" id="L128">            this.phase = phase;</span>
<span class="fc" id="L129">        }</span>

        @Override
        public int compareTo(LogKey o) {
<span class="fc" id="L133">            int result = Long.compare(phase, o.phase);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (result == 0) {</span>
<span class="fc" id="L135">                result = tag.compareTo(o.tag);</span>
            }
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (result == 0) {</span>
<span class="fc" id="L138">                result = Integer.compare(place.id, o.place.id);</span>
            }
<span class="fc" id="L140">            return result;</span>
        }

        /**
         * Two {@link LogKey}s are equal iff their respective {@link #place},
         * {@link #tag} and {@link #phase} match.
         */
        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L150">                return false;</span>
            }
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (!(obj instanceof LogKey)) {</span>
<span class="nc" id="L153">                return false;</span>
            }
<span class="fc" id="L155">            final LogKey key2 = (LogKey) obj;</span>
<span class="pc bpc" id="L156" title="2 of 6 branches missed.">            return place.equals(key2.place) &amp;&amp; nullSafeEquals(tag, key2.tag) &amp;&amp; (phase == key2.phase);</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L161">            return place.id + (tag.hashCode() &lt;&lt; 2) + (int) (phase &lt;&lt; 4 + phase &gt;&gt; 16);</span>
        }

        @Override
        public String toString() {
<span class="fc" id="L166">            return &quot;Log@&quot; + place + &quot;, tag: &quot; + tag + &quot;, phase: &quot; + phase;</span>
        }
    }

    /**
     *
     */
    static class SetDiff {
        Collection&lt;LogItem&gt; first;
        Collection&lt;LogItem&gt; second;

<span class="fc" id="L177">        public SetDiff(Collection&lt;LogItem&gt; first, Collection&lt;LogItem&gt; second) {</span>
<span class="fc" id="L178">            this.first = first;</span>
<span class="fc" id="L179">            this.second = second;</span>
<span class="fc" id="L180">        }</span>

        public boolean isEmpty() {
<span class="nc bnc" id="L183" title="All 8 branches missed.">            return (first == null || first.isEmpty()) &amp;&amp; (second == null || second.isEmpty());</span>
        }

        public void print(PrintStream out) {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">            out.println(&quot;  1st:&quot; + (first == null ? &quot;&quot; : first));</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">            out.println(&quot;  2nd:&quot; + (second == null ? &quot;&quot; : second));</span>
<span class="fc" id="L189">        }</span>
    }

    /** Serial Version UID */
    private static final long serialVersionUID = 3453720633747873404L;

    /**
     * The default DistLog instance used by the static
     * {@link DistLog#log(String, String, String)} method.
     */
    public static DistLog defaultLog;

    /**
     * Map used to keep a record of {@link DistLog} instances in use
     */
<span class="fc" id="L204">    public static HashMap&lt;GlobalID, DistLog&gt; map = new HashMap&lt;&gt;();</span>

<span class="fc" id="L206">    private static final Comparator&lt;Pair&lt;String, Long&gt;&gt; gcmp = Comparator.comparing(Pair&lt;String, Long&gt;::getSecond)</span>
<span class="fc" id="L207">            .thenComparing(Pair&lt;String, Long&gt;::getFirst);</span>

<span class="fc" id="L209">    public static String itemOffset = &quot;  &quot;;</span>

    private static &lt;E&gt; Collection&lt;E&gt; concat(Collection&lt;? extends Collection&lt;E&gt;&gt; lists) {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (lists == null) {</span>
<span class="nc" id="L213">            return null;</span>
        }
<span class="fc" id="L215">        int size = 0;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (final Collection&lt;E&gt; list : lists) {</span>
<span class="fc" id="L217">            size += list.size();</span>
<span class="fc" id="L218">        }</span>
<span class="fc" id="L219">        final ArrayList&lt;E&gt; result = new ArrayList&lt;&gt;(size);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (final Collection&lt;E&gt; list : lists) {</span>
<span class="fc" id="L221">            result.addAll(list);</span>
<span class="fc" id="L222">        }</span>
<span class="fc" id="L223">        return result;</span>
    }

    public static void defaultGlobalGather() {
<span class="fc" id="L227">        DistLog.defaultLog.globalGather();</span>
<span class="fc" id="L228">    }</span>

    /**
     * set the phase of DistLog.defaultLog
     *
     * @param phase the new phase value
     */
    public static void defaultGlobalSetPhase(long phase) {
<span class="fc" id="L236">        DistLog.defaultLog.globalSetPhase(phase);</span>
<span class="fc" id="L237">    }</span>

    private static ListDiff diffCheckList(List&lt;LogItem&gt; list0, List&lt;LogItem&gt; list1) {
<span class="fc" id="L240">        final int size = Math.min(list0.size(), list1.size());</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L242">            final LogItem item0 = list0.get(i);</span>
<span class="fc" id="L243">            final LogItem item1 = list1.get(i);</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">            if (!item0.equals(item1)) {</span>
<span class="nc" id="L245">                return new ListDiff(i, item0, item1);</span>
            }
        }
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (list0.size() &gt; list1.size()) {</span>
<span class="nc" id="L249">            return new ListDiff(size, list0.get(size), null);</span>
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        } else if (list0.size() &lt; list1.size()) {</span>
<span class="nc" id="L251">            return new ListDiff(size, null, list1.get(size));</span>
        } else {
<span class="fc" id="L253">            return null;</span>
        }
    }

    private static SetDiff diffCheckSet(Collection&lt;? extends Collection&lt;LogItem&gt;&gt; lists0,
            Collection&lt;? extends Collection&lt;LogItem&gt;&gt; lists1) {
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (lists0 == null) {</span>
<span class="fc" id="L260">            lists0 = Collections.emptySet();</span>
        }
<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (lists1 == null) {</span>
<span class="fc" id="L263">            lists1 = Collections.emptySet();</span>
        }
<span class="fc" id="L265">        return diffCheckSet0(concat(lists0), concat(lists1));</span>
    }

    private static SetDiff diffCheckSet0(Collection&lt;LogItem&gt; olist0, Collection&lt;LogItem&gt; olist1) {
<span class="pc bpc" id="L269" title="1 of 4 branches missed.">        if (olist0.isEmpty() &amp;&amp; olist1.isEmpty()) {</span>
<span class="nc" id="L270">            return null;</span>
        }
<span class="fc bfc" id="L272" title="All 4 branches covered.">        if (olist0.isEmpty() || olist1.isEmpty()) {</span>
<span class="fc" id="L273">            return new SetDiff(olist0, olist1);</span>
        }
<span class="fc" id="L275">        final ArrayList&lt;LogItem&gt; list0 = new ArrayList&lt;&gt;(olist0);</span>
<span class="fc" id="L276">        final ArrayList&lt;LogItem&gt; list1 = new ArrayList&lt;&gt;(olist1);</span>
<span class="fc" id="L277">        list0.sort(LogItem.cmp);</span>
<span class="fc" id="L278">        list1.sort(LogItem.cmp);</span>
<span class="fc" id="L279">        final SetDiff result = new SetDiff(list0, list1);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (list0.size() != list1.size()) {</span>
<span class="fc" id="L281">            return result;</span>
        }
<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (int i = 0; i &lt; list0.size(); i++) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">            if (!list0.get(i).equals(list1.get(i))) {</span>
<span class="fc" id="L285">                return result;</span>
            }
        }
<span class="fc" id="L288">        return null;</span>
    }

    /**
     * create a DistLog instance and set it to {@code DistLog.defaultLog} on all the
     * places of the place group.
     *
     * @param pg         the place group
     * @param phase      the initial phase of the created DistLog
     * @param setDefault set the created DistLog as DistLog.defaultLog
     */
    public static DistLog globalSetup(TeamedPlaceGroup pg, long phase, boolean setDefault) {
<span class="fc" id="L300">        final DistLog dlog = new DistLog(pg, phase);</span>
<span class="fc" id="L301">        dlog.globalSetup(setDefault);</span>
<span class="fc" id="L302">        return dlog;</span>
    }

    /**
     * put a log to {@code DistLog.defaultLog}. This method only calls
     * {@code DistLog.defaultLog.put(tag, msg, appendix)} if {@code defaultLog} is
     * set. Otherwise {@code System.out.println()} is called instead.
     *
     * @param tag      the topic tag about which a log is made
     * @param msg      object being logged, can be a {@link String} or another
     *                 object
     * @param appendix appendix of the log message
     */
    public static void log(String tag, String msg, String appendix) {
<span class="fc bfc" id="L316" title="All 2 branches covered.">        if (defaultLog != null) {</span>
<span class="fc" id="L317">            defaultLog.put(tag, msg, appendix);</span>
        } else {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            System.out.println(tag + &quot;:&quot; + msg + (appendix == null ? &quot;&quot; : &quot;:&quot; + appendix));</span>
        }
<span class="fc" id="L321">    }</span>

    public final TeamedPlaceGroup pg;

    /** The current logging phase */
    AtomicLong phase;

    /**
     * Creates a {@link DistLog} instance for events that occur in the whole
     * {@link TeamedPlaceGroup#getWorld()} with an initial phase of 0
     */
    public DistLog() {
<span class="fc" id="L333">        this(TeamedPlaceGroup.getWorld());</span>
<span class="fc" id="L334">    }</span>

    /**
     * Creates a {@link DistLog} instance for events to be logged on the provided
     * place group. The initial logging phase is arbitrarily set to 0l.
     *
     * @param pg the group of places on which events are gathered
     */
    public DistLog(final TeamedPlaceGroup pg) {
<span class="fc" id="L343">        this(pg, 0l);</span>
<span class="fc" id="L344">    }</span>

    /**
     * Create a DistLog instance that records logs within a place group and gathers
     * them to a place
     *
     * @param pg    the place group
     * @param phase the initial phase
     */
    public DistLog(final TeamedPlaceGroup pg, final long phase) {
<span class="fc" id="L354">        this(pg, phase, new DistConcurrentMultiMap&lt;&gt;(pg));</span>
<span class="fc" id="L355">    }</span>

    private DistLog(TeamedPlaceGroup pg, long phase, DistConcurrentMultiMap&lt;LogKey, LogItem&gt; base) {
<span class="fc" id="L358">        super(base);</span>
<span class="fc" id="L359">        this.pg = pg;</span>
<span class="fc" id="L360">        this.phase = new AtomicLong(phase);</span>
<span class="pc bpc" id="L361" title="3 of 4 branches missed.">        assert (DistLog.map.get(base.id()) == null);</span>
<span class="pc bpc" id="L362" title="3 of 4 branches missed.">        assert (base != null);</span>
<span class="fc" id="L363">        DistLog.map.put(base.id(), this);</span>
<span class="fc" id="L364">    }</span>

    /**
     * Determines whether the log set of this and the target DistLog instances are
     * equal. It distinguish only tags and ignores the generated places. It return
     * true iff the sets of the logs having the same tag are the same. Diff will be
     * output to {@code out} if they differ.
     *
     * @param target the logger instance to compare to this
     * @param out    the output to which the difference is printed
     * @return {@code true} if this instance and the target are identical,
     *         {@code false otherwise}
     */

    public boolean distributionFreeEquals(DistLog target, PrintStream out) {
<span class="fc" id="L379">        boolean result = true;</span>
<span class="fc" id="L380">        final TreeMap&lt;Pair&lt;String, Long&gt;, List&lt;Collection&lt;LogItem&gt;&gt;&gt; g0 = groupBy();</span>
<span class="fc" id="L381">        final TreeMap&lt;Pair&lt;String, Long&gt;, List&lt;Collection&lt;LogItem&gt;&gt;&gt; g1 = target.groupBy();</span>
<span class="fc" id="L382">        final TreeSet&lt;Pair&lt;String, Long&gt;&gt; keys = new TreeSet&lt;&gt;(gcmp);</span>
<span class="fc" id="L383">        keys.addAll(g0.keySet());</span>
<span class="fc" id="L384">        keys.addAll(g1.keySet());</span>
<span class="fc" id="L385">        long phase = 0;</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (final Pair&lt;String, Long&gt; key : keys) {</span>
<span class="fc bfc" id="L387" title="All 4 branches covered.">            if ((!result) &amp;&amp; phase &lt; key.second) {</span>
<span class="fc" id="L388">                return false;</span>
            }
<span class="fc" id="L390">            final List&lt;Collection&lt;LogItem&gt;&gt; entries0 = g0.get(key);</span>
<span class="fc" id="L391">            final List&lt;Collection&lt;LogItem&gt;&gt; entries1 = g1.get(key);</span>
<span class="fc" id="L392">            final SetDiff diff = diffCheckSet(entries0, entries1);</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">            if (diff != null) {</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                if (result == true) {</span>
<span class="fc" id="L395">                    out.println(&quot;Diff first found in phase &quot; + key.second);</span>
                }
<span class="fc" id="L397">                out.println(&quot;Diff with tag: &quot; + key.first + &quot;, phase: &quot; + key.second);</span>
<span class="fc" id="L398">                diff.print(out);</span>
<span class="fc" id="L399">                result = false;</span>
<span class="fc" id="L400">                phase = key.second;</span>
            }
<span class="fc" id="L402">        }</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">        for (final Map.Entry&lt;Pair&lt;String, Long&gt;, List&lt;Collection&lt;LogItem&gt;&gt;&gt; entry : g1.entrySet()) {</span>
<span class="fc" id="L404">            out.println(&quot;Diff @ [tag: &quot; + entry.getKey().first + &quot;, phase&quot; + entry.getKey().second</span>
<span class="fc" id="L405">                    + &quot;]: target only has values:&quot; + entry.getValue());</span>
<span class="fc" id="L406">        }</span>
<span class="fc" id="L407">        return result;</span>
    }

    @Override
    public SerializableBiFunction&lt;DistConcurrentMultiMap&lt;LogKey, LogItem&gt;, Place, DistLog&gt; getBranchCreator() {
<span class="fc" id="L412">        final DistConcurrentMultiMap&lt;LogKey, LogItem&gt; base0 = base;</span>
<span class="fc" id="L413">        final long phase0 = phase.get();</span>
<span class="fc" id="L414">        return (DistConcurrentMultiMap&lt;LogKey, LogItem&gt; base, Place place) -&gt; new DistLog(base0.placeGroup(), phase0,</span>
                base0);
    }

    public DistConcurrentMultiMap&lt;LogKey, LogItem&gt; getDistMultiMap() {
<span class="fc" id="L419">        return getPlanet();</span>
    }

    /**
     * Returns the {@link LogItem}s mapped to the specified key
     *
     * @param k the key which specify the place, tag, and phase of the targeted
     *          records
     * @return collection of {@link LogItem} mapped to the specified key,
     *         {@code null} if there are no such items
     */
    public Collection&lt;LogItem&gt; getLog(LogKey k) {
<span class="fc" id="L431">        return base.get(k);</span>
    }

    /**
     * Returns the logged items of the specified place for the specified key and the
     * current phase. If the specified place is the local place, then calling this
     * method is equivalent to calling method {@link #getLog(String)}. If the
     * specified place is remote, then programmers should be careful to call method
     * {@link #globalGather()} so that events logged on remote hosts are relocated
     * and accessible on this host.
     *
     * @param p   the place on which the logged events occurred
     * @param key the key under which the events were recorded
     * @return the collection of items logged under the specified key at the
     *         specified host
     */
    public Collection&lt;LogItem&gt; getLog(Place p, String key) {
<span class="nc" id="L448">        return getLog(p, key, getPhase());</span>
    }

    /**
     * Returns the logged items of the specified place, tag and phase.
     * &lt;p&gt;
     * Note that is the targeted log entries are of a remote host, method
     * {@link #globalGather()} should be called prior to attempting to retrieve such
     * logs.
     *
     * @param p     the place on which events were recorded
     * @param tag   the tag under which events were recorded
     * @param phase the phase during which the events were recorded
     * @return the collection of {@link LogItem} recorded under the specified key
     */
    public Collection&lt;LogItem&gt; getLog(Place p, String tag, long phase) {
<span class="fc" id="L464">        return getLog(new LogKey(p, tag, phase));</span>
    }

    /**
     * Returns the logged items of this place for the specified key
     *
     * @param key the key whose logged events needs to be retrieved
     * @return the collection of events logged on this place with the specified key
     */
    public Collection&lt;LogItem&gt; getLog(String key) {
<span class="nc" id="L474">        return getLog(here(), key);</span>
    }

    public long getPhase() {
<span class="nc" id="L478">        return phase.get();</span>
    }

    /**
     * gather the log to the receiving place initially specified
     */
    public void globalGather() {
        // TODO
        // base.GLOBAL.gather(this.place);
<span class="fc" id="L487">        final DistConcurrentMultiMap&lt;LogKey, LogItem&gt; base0 = base;</span>
<span class="fc" id="L488">        final Place dest = here();</span>
<span class="fc" id="L489">        pg.broadcastFlat(() -&gt; {</span>
<span class="fc" id="L490">            final Function&lt;LogKey, Place&gt; func = (LogKey k) -&gt; dest;</span>
<span class="fc" id="L491">            base0.relocate(func);</span>
<span class="fc" id="L492">        });</span>
<span class="fc" id="L493">    }</span>

    public void globalSetDefault() {
<span class="fc" id="L496">        final DistLog b = this;</span>
<span class="fc" id="L497">        DistLog.defaultLog = b;</span>
<span class="fc" id="L498">        final Place caller = here();</span>
<span class="fc" id="L499">        pg.broadcastFlat(() -&gt; {</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            if (!here().equals(caller)) {</span>
<span class="fc" id="L501">                DistLog.defaultLog = b;</span>
            }
<span class="fc" id="L503">        });</span>
<span class="fc" id="L504">    }</span>

    /**
     * set the phase of DistLog on each place
     *
     * @param phase the logging phase to be used from now on
     */
    public void globalSetPhase(final long phase) {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        if (base == null) {</span>
<span class="nc" id="L513">            throw new IllegalStateException(</span>
                    &quot;Note: `DistLog#globalSetPhase` can be used after `globalSetup()` called. &quot;);
        }
<span class="fc" id="L516">        final DistLog b = this;</span>
<span class="fc" id="L517">        b.setPhase(phase);</span>
<span class="fc" id="L518">        final Place caller = Constructs.here();</span>
<span class="fc" id="L519">        pg.broadcastFlat(() -&gt; {</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">            if (Constructs.here().equals(caller)) {</span>
<span class="fc" id="L521">                return;</span>
            }
<span class="fc" id="L523">            b.setPhase(phase);</span>
<span class="fc" id="L524">        });</span>
<span class="fc" id="L525">    }</span>

    /**
     * set this instance to {@code DistLog.defaultLog} on all the places of the
     * place group.
     */
    public void globalSetup(final boolean setDefault) {
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (setDefault) {</span>
<span class="fc" id="L533">            globalSetDefault();</span>
        }
<span class="fc" id="L535">    }</span>

    private TreeMap&lt;Pair&lt;String, Long&gt;, List&lt;Collection&lt;LogItem&gt;&gt;&gt; groupBy() {
<span class="fc" id="L538">        final TreeMap&lt;Pair&lt;String, Long&gt;, List&lt;Collection&lt;LogItem&gt;&gt;&gt; results = new TreeMap&lt;&gt;(gcmp);</span>
<span class="fc" id="L539">        base.forEach((LogKey key, Collection&lt;LogItem&gt; items) -&gt; {</span>
<span class="fc" id="L540">            final Pair&lt;String, Long&gt; keyWOp = new Pair&lt;&gt;(key.tag, key.phase);</span>
<span class="fc" id="L541">            final List&lt;Collection&lt;LogItem&gt;&gt; bag = results.computeIfAbsent(keyWOp, k -&gt; new ArrayList&lt;&gt;());</span>
<span class="fc" id="L542">            bag.add(items);</span>
<span class="fc" id="L543">        });</span>
<span class="fc" id="L544">        return results;</span>
    }

    /**
     * Determines whether the log set of this and the target is equals. It
     * distinguish the log having the different tags or different generated places.
     * It only returns true only iff the two log lists have the same elements with
     * the same order for each generated place and tag. Diff will be output to
     * {@code out} if they differs.
     *
     * @param target the target to which this instance needs to be compared
     * @param out    the output stream to which the difference will be printed
     * @return {@code true} if the target and this logs are equal,
     *         {@code flase otherwise}
     */
    public boolean placeConsciousEquals(DistLog target, PrintStream out, boolean asList) {
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (out != null) {</span>
<span class="nc" id="L562">                out.println(&quot;DistLog differs: target is null&quot;);</span>
            }
<span class="nc" id="L564">            return false;</span>
        }

<span class="fc" id="L567">        final TreeSet&lt;LogKey&gt; keys = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L568">        keys.addAll(base.keySet());</span>
<span class="fc" id="L569">        keys.addAll(target.base.keySet());</span>

<span class="fc" id="L571">        boolean result = true;</span>
<span class="fc" id="L572">        long bugPhase = 0;</span>

<span class="fc bfc" id="L574" title="All 2 branches covered.">        for (final LogKey key : keys) {</span>
<span class="fc bfc" id="L575" title="All 4 branches covered.">            if ((!result) &amp;&amp; key.phase &gt; bugPhase) {</span>
<span class="fc" id="L576">                return false;</span>
            }
<span class="fc" id="L578">            final Collection&lt;LogItem&gt; elems1 = base.get(key);</span>
<span class="fc" id="L579">            final Collection&lt;LogItem&gt; elems2 = target.base.get(key);</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">            final List&lt;LogItem&gt; lists1 = elems1 == null ? Collections.emptyList() : new ArrayList&lt;&gt;(elems1);</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">            final List&lt;LogItem&gt; lists2 = elems2 == null ? Collections.emptyList() : new ArrayList&lt;&gt;(elems2);</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">            if (asList) {</span>
<span class="fc" id="L583">                final ListDiff diff = diffCheckList(lists1, lists2);</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                if (diff != null) {</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                    if (result) {</span>
<span class="nc" id="L586">                        out.println(&quot;Diff first found in phase &quot; + key.phase);</span>
<span class="nc" id="L587">                        bugPhase = key.phase;</span>
<span class="nc" id="L588">                        result = false;</span>
                    }
<span class="nc" id="L590">                    out.println(&quot;Diff in &quot; + key + &quot;::&quot; + diff);</span>
                }
<span class="fc" id="L592">            } else {</span>
<span class="fc" id="L593">                final SetDiff diff = diffCheckSet0(lists1, lists2);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                if (diff != null) {</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                    if (result) {</span>
<span class="fc" id="L596">                        out.println(&quot;Diff first found in phase &quot; + key.phase);</span>
<span class="fc" id="L597">                        bugPhase = key.phase;</span>
<span class="fc" id="L598">                        result = false;</span>
                    }
<span class="fc" id="L600">                    out.println(&quot;Diff in &quot; + key);</span>
<span class="fc" id="L601">                    diff.print(out);</span>
                }
            }
<span class="fc" id="L604">        }</span>
<span class="fc" id="L605">        return result;</span>
    }

    public void printAll(PrintStream out) {
<span class="nc" id="L609">        final TreeMap&lt;LogKey, Collection&lt;LogItem&gt;&gt; sorted = new TreeMap&lt;&gt;((o1, o2) -&gt; {</span>
<span class="nc" id="L610">            int result = Integer.compareUnsigned(o1.place.id, o2.place.id);</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (result == 0) {</span>
<span class="nc" id="L612">                result = o1.tag.compareTo(o2.tag);</span>
            }
<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (result == 0) {</span>
<span class="nc" id="L615">                result = Long.compare(o1.phase, o2.phase);</span>
            }
<span class="nc" id="L617">            return result;</span>
        });
<span class="nc" id="L619">        base.forEach((LogKey key, Collection&lt;LogItem&gt; items) -&gt; {</span>
<span class="nc" id="L620">            sorted.put(key, items);</span>
<span class="nc" id="L621">        });</span>
<span class="nc" id="L622">        sorted.forEach((LogKey key, Collection&lt;LogItem&gt; items) -&gt; {</span>
<span class="nc" id="L623">            out.println(&quot;LogKey: &quot; + key);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            for (final LogItem item : items) {</span>
<span class="nc" id="L625">                out.println(itemOffset + item);</span>
<span class="nc" id="L626">            }</span>
<span class="nc" id="L627">        });</span>
<span class="nc" id="L628">    }</span>

    /**
     * Puts the specified message for the specified tag
     *
     * @param phaseVal the phase under which this log message will be kept
     * @param tag      the topic into which this message will be recorded
     * @param msg      the message to log
     * @param appendix may be null
     */
    public void put(long phaseVal, String tag, String msg, String appendix) {
<span class="fc" id="L639">        base.put1(new LogKey(Constructs.here(), tag, phaseVal), new LogItem(msg, appendix));</span>
<span class="fc" id="L640">    }</span>

    /**
     * put the msg with the specified tag.
     *
     * @param tag      tag for the message.
     * @param msg      the message to be stored. The value of {@code msg.toString()}
     *                 is stored into DistLog.
     * @param appendix the appendix information for the log. The value of appendix
     *                 is not used for equality check of {@code DistLog} instances
     *                 while {@code msg} is used.
     */
    public void put(String tag, String msg, String appendix) {
<span class="fc" id="L653">        put(phase.get(), tag, msg, appendix);</span>
<span class="fc" id="L654">    }</span>

    public Collection&lt;LogItem&gt; removeLog(String key) {
<span class="nc" id="L657">        return base.remove(new LogKey(here(), key, phase.get()));</span>
    }

    public void setPhase(long phase) {
<span class="fc" id="L661">        this.phase.set(phase);</span>
<span class="fc" id="L662">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>