<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SavedLog.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.util</a> &gt; <span class="el_source">SavedLog.java</span></div><h1>SavedLog.java</h1><pre class="source lang-java linenums">package handist.collections.util;

import static apgas.Constructs.*;
import static handist.collections.util.StringUtilities.*;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PrintStream;
import java.io.Serializable;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

import apgas.Constructs;
import apgas.Place;
import handist.collections.Chunk;
import handist.collections.LongRange;
import handist.collections.dist.DistCol;
import handist.collections.dist.DistLog;
import handist.collections.dist.DistLog.LogItem;
import handist.collections.dist.DistLog.LogKey;
import handist.collections.dist.DistMultiMap;
import handist.collections.glb.GlobalLoadBalancer;

/**
 * Class used as a substitute to {@link DistLog} to save the events recorded
 * into a DistLog to a file and to restore it later.
 * &lt;p&gt;
 * This class is used so that distributed logs can be accessed for processing
 * and analysis post-mortem in single-threaded environments, something not
 * possible when working directly with a {@link DistLog}.
 *
 * @author Patrick Finnerty
 *
 */
public class SavedLog {

    /**
     * Class used as a substitute to {@link LogKey} in which the use of the APGAS
     * {@link Place} class has been replaced by a {@code int}.
     *
     * @author Patrick Finnerty
     *
     */
    public static class Key implements Serializable {

        /** Serial Version UID */
        private static final long serialVersionUID = 6245573767313436511L;

        /** Phase during which the events were recorded */
        public final long phase;
        /** Place on which the events occurred */
        public final int place;
        /** Tag under which the events are kept */
        public final String tag;

        /**
         * Constructor
         *
         * @param p place number ({@link Place#id}) on which the events occurred
         * @param t tag under which the events are gathered
         * @param f the phase during which the events occurred
         */
<span class="fc" id="L70">        private Key(int p, String t, long f) {</span>
<span class="fc" id="L71">            place = p;</span>
<span class="fc" id="L72">            tag = t;</span>
<span class="fc" id="L73">            phase = f;</span>
<span class="fc" id="L74">        }</span>

        /**
         * Two {@link Key}s are equal iff their respective {@link #place}, {@link #tag}
         * and {@link #phase} match. Note that {@link Key} can be compared to a
         * {@link LogKey}.
         */
        @Override
        public boolean equals(Object obj) {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L84">                return false;</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">            } else if (obj instanceof LogKey) {</span>
<span class="nc" id="L86">                final LogKey logKey = (LogKey) obj;</span>
<span class="nc bnc" id="L87" title="All 6 branches missed.">                return place == logKey.place.id &amp;&amp; nullSafeEquals(tag, logKey.tag) &amp;&amp; (phase == logKey.phase);</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">            } else if (obj instanceof Key) {</span>
<span class="fc" id="L89">                final Key key2 = (Key) obj;</span>
<span class="pc bpc" id="L90" title="3 of 6 branches missed.">                return place == key2.place &amp;&amp; nullSafeEquals(tag, key2.tag) &amp;&amp; (phase == key2.phase);</span>
            }
<span class="nc" id="L92">            return false;</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L97">            return place + (tag.hashCode() &lt;&lt; 2) + (int) (phase &lt;&lt; 4 + phase &gt;&gt; 16);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L102">            return &quot;Log@Place(&quot; + place + &quot;), tag: &quot; + tag + &quot;, phase: &quot; + phase;</span>
        }

    }

    /**
     * Main used to generate a file into which the events of GLB program execution
     * are recorded
     *
     * @param args one argument: the name of the file into which the log will be
     *             stored
     */
    public static void main(String[] args) {
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (args.length &lt; 1) {</span>
<span class="nc" id="L116">            System.err.println(&quot;1 arguments required:&quot;);</span>
<span class="nc" id="L117">            System.err.println(&quot;\t&lt;file name&gt; \tspecifies the file into which the log recording will be written&quot;);</span>
<span class="nc" id="L118">            return;</span>
        }

<span class="nc" id="L121">        final DistCol&lt;Long&gt; col = new DistCol&lt;&gt;();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        for (long l = 0l; l &lt; 1000; l += 100) {</span>
<span class="nc" id="L123">            final Chunk&lt;Long&gt; c = new Chunk&lt;&gt;(new LongRange(l, l + 100), idx -&gt; {</span>
<span class="nc" id="L124">                return new Long(idx);</span>
            });
<span class="nc" id="L126">            col.add(c);</span>
        }

<span class="nc" id="L129">        GlobalLoadBalancer.underGLB(() -&gt; {</span>
<span class="nc" id="L130">            col.GLB.forEach(i -&gt; i.compareTo(i + 42));</span>
<span class="nc" id="L131">        });</span>

<span class="nc" id="L133">        final DistLog distLog = GlobalLoadBalancer.getPreviousLog();</span>
<span class="nc" id="L134">        distLog.globalGather();</span>
<span class="nc" id="L135">        distLog.printAll(System.out);</span>
<span class="nc" id="L136">        final SavedLog log = new SavedLog(distLog);</span>
        try {
<span class="nc" id="L138">            log.saveToFile(new File(args[0]));</span>
<span class="nc" id="L139">        } catch (final IOException e) {</span>
<span class="nc" id="L140">            System.err.println(&quot;Issue when trying to write to file:&quot;);</span>
<span class="nc" id="L141">            e.printStackTrace();</span>
<span class="nc" id="L142">        }</span>
<span class="nc" id="L143">    }</span>

    /**
     * Map into which the logged entries of the {@link DistLog} are converted
     */
    private final HashMap&lt;Key, Collection&lt;LogItem&gt;&gt; loggedEntries;

    private final int numberOfHosts;

    /**
     * Constructor
     *
     * @param log the distributed log instance into which events that occurred
     *            during a GLB execution were recorded
     */
<span class="fc" id="L158">    public SavedLog(DistLog log) {</span>
<span class="fc" id="L159">        numberOfHosts = Constructs.places().size();</span>

<span class="fc" id="L161">        log.globalGather();</span>

<span class="fc" id="L163">        final DistMultiMap&lt;LogKey, LogItem&gt; distLogMap = log.getDistMultiMap();</span>
<span class="fc" id="L164">        loggedEntries = new HashMap&lt;&gt;(distLogMap.size());</span>

        // Initialize member loggedEntries by substituting the keys used to log the
        // various entries
<span class="fc" id="L168">        log.getDistMultiMap().forEach((key, entries) -&gt; {</span>
<span class="fc" id="L169">            final Key substituteKey = new Key(key.place.id, key.tag, key.phase);</span>
<span class="fc" id="L170">            loggedEntries.put(substituteKey, entries);</span>
<span class="fc" id="L171">        });</span>
<span class="fc" id="L172">    }</span>

    /**
     * Constructor
     * &lt;p&gt;
     * This constructor
     *
     * @param file the file to which an instance of this class was saved
     * @throws IOException            if thrown during the retrieval of information
     *                                from the specified file
     * @throws ClassNotFoundException if thrown when reading objects from the
     *                                specified file
     */
    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L186">    public SavedLog(File file) throws IOException, ClassNotFoundException {</span>
<span class="fc" id="L187">        final ObjectInputStream inStream = new ObjectInputStream(new FileInputStream(file));</span>
<span class="fc" id="L188">        numberOfHosts = inStream.readInt();</span>
<span class="fc" id="L189">        loggedEntries = (HashMap&lt;Key, Collection&lt;LogItem&gt;&gt;) inStream.readObject();</span>
<span class="fc" id="L190">        inStream.close();</span>
<span class="fc" id="L191">    }</span>

    @Override
    public boolean equals(Object o) {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L196">            return false;</span>
        }
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (o instanceof SavedLog) {</span>
<span class="fc" id="L199">            return equalsGlbLog((SavedLog) o);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        } else if (o instanceof DistLog) {</span>
<span class="fc" id="L201">            return equalsDistLog((DistLog) o);</span>
        } else {
<span class="nc" id="L203">            return false;</span>
        }
    }

    private boolean equalsDistLog(DistLog log) {
<span class="fc" id="L208">        final Map&lt;LogKey, Collection&lt;LogItem&gt;&gt; logMap = log.getDistMultiMap();</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (logMap.size() != loggedEntries.size()) {</span>
<span class="fc" id="L210">            return false;</span>
        }

<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (final Key k : loggedEntries.keySet()) {</span>
<span class="fc" id="L214">            final Collection&lt;LogItem&gt; otherItems = log.getLog(place(k.place), k.tag, k.phase);</span>
<span class="fc" id="L215">            final Collection&lt;LogItem&gt; myItems = loggedEntries.get(k);</span>

<span class="pc bpc" id="L217" title="2 of 4 branches missed.">            if (otherItems != null &amp;&amp; otherItems.size() == myItems.size()) {</span>
                // Check that every item in 'myItems' is also in 'otherItems'
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                if (!otherItems.containsAll(myItems)) {</span>
<span class="nc" id="L220">                    return false;</span>
                }
            } else {
<span class="nc" id="L223">                return false;</span>
            }
            // 2-way comparison
<span class="fc" id="L226">        }</span>

<span class="fc" id="L228">        return true;</span>
    }

    /**
     * Checks if the provided GlbLog contains the same
     *
     * @param log
     * @return
     */
    private boolean equalsGlbLog(SavedLog log) {
<span class="fc" id="L238">        final Map&lt;Key, Collection&lt;LogItem&gt;&gt; logMap = log.loggedEntries;</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (logMap.size() != loggedEntries.size()) {</span>
<span class="nc" id="L240">            return false;</span>
        }

<span class="fc bfc" id="L243" title="All 2 branches covered.">        for (final Key k : loggedEntries.keySet()) {</span>
<span class="fc" id="L244">            final Collection&lt;LogItem&gt; otherItems = log.getLog(k.place, k.tag, k.phase);</span>
<span class="fc" id="L245">            final Collection&lt;LogItem&gt; myItems = loggedEntries.get(k);</span>
<span class="fc" id="L246">            System.out.println(otherItems.size() + &quot; &quot; + myItems.size());</span>

<span class="pc bpc" id="L248" title="2 of 4 branches missed.">            if (otherItems != null &amp;&amp; otherItems.size() == myItems.size()) {</span>
                // Check that every item in 'myItems' is also in 'otherItems'
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">                if (!otherItems.containsAll(myItems)) {</span>
<span class="nc" id="L251">                    return false;</span>
                }
            } else {
<span class="nc" id="L254">                return false;</span>
            }
            // 2-way comparison
<span class="fc" id="L257">        }</span>

<span class="fc" id="L259">        return true;</span>
    }

    /**
     * Obtain the logged entries for the specified place, tag, and phase tuple.
     *
     * @param place the number id of the place from which events should be retrieved
     * @param tag   the tag under which the logged items were gathered
     * @param phase the phase during which the events were logged
     * @return a collection containing the {@link LogItem} that were recorded under
     *         the specified tuple, {@code null} if there are no such
     */
    public Collection&lt;LogItem&gt; getLog(int place, String tag, long phase) {
<span class="fc" id="L272">        return getLog(new Key(place, tag, phase));</span>
    }

    /**
     * Obtain the logged entries for the specified key
     *
     * @param k the key for which logged elements should be retrieved
     * @return collection of {@link LogItem} matching the key, or {@code null} if
     *         there are no such elements
     */
    public Collection&lt;LogItem&gt; getLog(Key k) {
<span class="fc" id="L283">        return loggedEntries.get(k);</span>
    }

    /**
     * Obtain the logged entries for the specified log key. The provided key is
     * converted from {@link LogKey} to {@link Key} to retrieve the logged elements
     * from the {@link SavedLog} object.
     *
     * @param k key from a {@link DistLog} instance
     * @return collection of logged items that
     */
    public Collection&lt;LogItem&gt; getLog(LogKey k) {
<span class="fc" id="L295">        return getLog(k.place.id, k.tag, k.phase);</span>
    }

    /**
     * Returns the number of hosts that took part in the execution this
     * {@link SavedLog} is the
     *
     * @return the number of processes involved in this computation
     */
    public int placeCount() {
<span class="nc" id="L305">        return numberOfHosts;</span>
    }

    public void printAll(PrintStream out) {
        // Custom map sorted by place first and tag second
<span class="nc" id="L310">        final TreeMap&lt;Key, Collection&lt;LogItem&gt;&gt; sorted = new TreeMap&lt;&gt;((o1, o2) -&gt; {</span>
<span class="nc" id="L311">            int result = Integer.compareUnsigned(o1.place, o2.place);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (result == 0) {</span>
<span class="nc" id="L313">                result = o1.tag.compareTo(o2.tag);</span>
            }
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (result == 0) {</span>
<span class="nc" id="L316">                result = Long.compare(o1.phase, o2.phase);</span>
            }
<span class="nc" id="L318">            return result;</span>
        });

        // Insert all logs into the map so that they get sorted
<span class="nc bnc" id="L322" title="All 2 branches missed.">        for (final Entry&lt;Key, Collection&lt;LogItem&gt;&gt; entry : loggedEntries.entrySet()) {</span>
<span class="nc" id="L323">            sorted.put(entry.getKey(), entry.getValue());</span>
<span class="nc" id="L324">        }</span>

        // Traverse the sorted map and print each log on a dedicated line
<span class="nc" id="L327">        sorted.forEach((Key key, Collection&lt;LogItem&gt; items) -&gt; {</span>
<span class="nc" id="L328">            out.println(&quot;LogKey: &quot; + key);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (final LogItem item : items) {</span>
<span class="nc" id="L330">                out.println(item);</span>
<span class="nc" id="L331">            }</span>
<span class="nc" id="L332">        });</span>

<span class="nc" id="L334">    }</span>

    /**
     * Records this instance to a file for later retrieval
     *
     * @param file the file to which this instance needs to be saved to
     * @throws IOException if thrown during the process of saving this class to the
     *                     specified file
     */
    public void saveToFile(File file) throws IOException {
<span class="fc" id="L344">        final ObjectOutputStream outStream = new ObjectOutputStream(new FileOutputStream(file));</span>

<span class="fc" id="L346">        outStream.writeInt(numberOfHosts);</span>
<span class="fc" id="L347">        outStream.writeObject(loggedEntries);</span>

<span class="fc" id="L349">        outStream.flush();</span>
<span class="fc" id="L350">        outStream.close();</span>
<span class="fc" id="L351">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>