<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SquareRange.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections</a> &gt; <span class="el_source">SquareRange.java</span></div><h1>SquareRange.java</h1><pre class="source lang-java linenums">/*******************************************************************************
 * Copyright (c) 2021 Handy Tools for Distributed Computing (HanDist) project.
 *
 * This program and the accompanying materials are made available to you under
 * the terms of the Eclipse Public License 1.0 which accompanies this
 * distribution,
 * and is available at https://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ******************************************************************************/
package handist.collections;

import handist.collections.function.SquareIndexConsumer;

import java.awt.*;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.function.BiConsumer;

/**
 * Class {@link SquareRange} describes an interval over {@code long} values.
 * &lt;p&gt;
 * The lower bound is included and the upper bound is excluded from the
 * interval, meaning that for two {@code long} values a and b (a&amp;lt;b), all the
 * {@code long} values l such that a &amp;le; l &amp;lt; b are contained within the
 * {@link SquareRange} [a,b).
 * &lt;p&gt;
 * It is possible to create &quot;empty&quot; {@link SquareRange} instances where the lower
 * bound is equal to the upper bound. In this case it is considered that there
 * are no {@code long} values included in the {@link SquareRange}.
 */
public class SquareRange implements /* Comparable&lt;SquareRange&gt;, Iterable&lt;LongRange&gt;,*/ Serializable {
//    /**
//     * Iterator on the {@code LongRange} contained in a {@link SquareRange}
//     */
//    //class It implements Iterator&lt;Long&gt; {
//    //TK: needless?? Iterable&lt;Pair&lt;Long,LongRange&gt;&gt;??

    /** Serial Version UID */
//    private static final long serialVersionUID = 6430187870603427655L;

    /**
     * Splits the {@link SquareRange} provided in the list into &lt;em&gt;n&lt;/em&gt; lists of
     * {@link SquareRange} instances such that the accumulated size of each list's
     * {@link SquareRange} are the same.
     * &lt;p&gt;
     * To achieve this, {@link SquareRange} instances may be split into several
     * instances that will placed in different lists.
     * &lt;p&gt;
     * The {@link SquareRange} instances given as parameter are not
     *
     * @param n          number of lists of equal sizes
     * @param squareRanges {@link SquareRange} instances to distribute into the lists
     * @return lists of {@link SquareRange} instances of equivalent
     */
    public static List&lt;List&lt;SquareRange&gt;&gt; splitList(int n, List&lt;SquareRange&gt; squareRanges) {
<span class="nc" id="L59">        throw new UnsupportedOperationException(&quot;not implemented yet&quot;) ;</span>
    }

    /** the range of the first dimension */
    public final LongRange outer;

    /** the range of the second dimension */
    public final LongRange inner;

    // TODO more variations...
    boolean isUpperTriangle;
    long triangleDiff;


    /**
     * Constructs a LongRange with the provided parameters.
     *
     * @param outer the range of the first range (outer loop)
     * @param inner the range of the second dimension (inner loop#
     * @throws IllegalArgumentException if the range of the first or the second dimension is null
     */
<span class="fc" id="L80">    public SquareRange(LongRange outer, LongRange inner) {</span>
<span class="fc" id="L81">        this.outer = outer;</span>
<span class="fc" id="L82">        this.inner = inner;</span>
<span class="fc" id="L83">        this.isUpperTriangle = false;</span>
<span class="fc" id="L84">    }</span>
<span class="fc" id="L85">    public SquareRange(LongRange outer, LongRange inner, boolean isUpperTriangle) {</span>
<span class="fc" id="L86">        this.outer = outer;</span>
<span class="fc" id="L87">        this.inner = inner;</span>
<span class="fc" id="L88">        this.isUpperTriangle = isUpperTriangle;</span>
<span class="fc" id="L89">        this.triangleDiff = inner.from - outer.from;</span>
<span class="fc" id="L90">    }</span>
<span class="fc" id="L91">    private SquareRange(LongRange outer, LongRange inner, boolean isUpperTriangle, long tri) {</span>
<span class="fc" id="L92">        this.outer = outer;</span>
<span class="fc" id="L93">        this.inner = inner;</span>
<span class="fc" id="L94">        this.isUpperTriangle = isUpperTriangle;</span>
<span class="fc" id="L95">        this.triangleDiff = tri;</span>
<span class="fc" id="L96">    }</span>

    /**
     * the start column index of the specified row.
     * @param row the index value of the row
     * @return
     */
    public long startColumn(long row) {
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if(isUpperTriangle) return Math.max(row + triangleDiff + 1, inner.from);</span>
<span class="fc" id="L105">        return inner.from;</span>
    }
    public long endColumn(long row) {
<span class="fc" id="L108">        return inner.to;</span>
    }
    public LongRange columnRange(long row) {
<span class="fc" id="L111">        return new LongRange(startColumn(row), endColumn(row));</span>
    }
    public long startRow(long column) {
<span class="fc" id="L114">        return outer.from;</span>
    }
    public long endRow(long column) {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if(isUpperTriangle) return Math.min(column - triangleDiff, outer.to);</span>
<span class="nc" id="L118">        return outer.to;</span>
    }
    public LongRange rowRange(long column) {
<span class="fc" id="L121">        return new LongRange(startRow(column), endRow(column));</span>
    }


//    /**
//     * TK: needless??
//     * Compares the provided instance to this instance and returns an integer
//     * indicating if the provided instance is less than, equal to, or greater than
//     * this instance.
//     * &lt;p&gt;
//     * The implementation relies on ordering the lower bounds first before using the
//     * ordering of the upper bounds. The implemented ordering of {@link SquareRange}
//     * is consistent with equals. To illustrate the ordering, consider the following
//     * examples:
//     * &lt;ul&gt;
//     * &lt;li&gt;[0,0) &amp;lt; [0,100) &amp;lt; [1,1) &amp;lt; [1,20) &amp;lt; [1,21)
//     * &lt;li&gt;[0,0) == [0,0)
//     * &lt;li&gt;[0,10) == [0,10)
//     * &lt;/ul&gt;
//     * &lt;p&gt;
//     *
//     * @param r the object to be compared
//     * @return a negative integer, zero, or a positive integer as this object is
//     *         less than, equal to, or greater than the specified object
//     * @throws NullPointerException if the instance given as parameter is null
//     */
//    @Override
//    public int compareTo(SquareRange r) {
//        // if (to &lt;= r.from &amp;&amp; from != to ) {
//        // return -1;
//        // } else if (r.to &lt;= from &amp;&amp; from != to) {
//        // return 1;
//        // }
//        // The LongRange instances overlap,
//        // We order them based on &quot;from&quot; first and &quot;to&quot; second
//        final int fromComparison = Long.compare(from, r.from);
//        return (fromComparison == 0) ? Long.compare(to, r.to) : fromComparison;
//    }

//    /**
//     * Checks if all the indices in this range are included in one of the keys
//     * contained by the provided {@code ConcurrentSkipListMap}.
//     *
//     * @param rmap the ConcurrentSkipListMap instance to check
//     * @return a LongRange key of the provided ConcurrentSkipListMap instance that
//     *         intersects this instance, or {@code null} if there are so such key.
//     */
//    public boolean contained(ConcurrentSkipListMap&lt;SquareRange, ?&gt; rmap) {
//        throws new UnsupportedOperationException(&quot;not implmented yet&quot;);
//    }

    /**
     * Indicates if the provided index point is included in this instance.
     *
     * @param outer0 the long value whose represents the outer index of the point
     * @param inner0 the long value whose represents the inner index of the point
     * @return {@code true} if the index point is included within the bounds of this
     *         {@link SquareRange}, {@code false} otherwise
     */
    public boolean contains(long outer0, long inner0) {
<span class="nc bnc" id="L181" title="All 4 branches missed.">       return outer.contains(outer0) &amp;&amp; columnRange(outer0).contains(inner0);</span>
    }
    public void containsCheck(long outer0, long inner0) {
<span class="nc" id="L184">        boolean result = contains(outer0, inner0);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">        if(!result) throw new IndexOutOfBoundsException(&quot;ContainsCheck: &quot; + this + &quot; does not contains [&quot; + outer0 +&quot;, &quot;+ inner0 + &quot;].&quot;);</span>
<span class="nc" id="L186">    }</span>


    /**
     * Indicates if the provided {@link SquareRange} is included within this instance.
     * A SquareRange is included inside the outer and inner ranges of this instance
     * contains the outer and inner ranges of the provided instance respectively.
     *
     * @param range the square range whose inclusion into this instance needs to be checked
     * @return true if all the indices of the provided long range are present in
     *         this instance.
     */
    public boolean contains(SquareRange range) {
<span class="nc bnc" id="L199" title="All 4 branches missed.">        if(range.isUpperTriangle || this.isUpperTriangle) throw new UnsupportedOperationException(&quot;not implemented yet&quot;);</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">        return outer.contains(range.outer) &amp;&amp; inner.contains(range.inner);</span>
    }
    public void containsCheck(SquareRange range) {
<span class="nc" id="L203">        boolean result = contains(range);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if(!result) throw new IndexOutOfBoundsException(&quot;ContainsCheck: &quot; + this + &quot; does not contains &quot; + range);</span>
<span class="nc" id="L205">    }</span>
    public void containsRowCheck(long row) {
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if(this.isUpperTriangle) throw new UnsupportedOperationException(&quot;not implemented yet&quot;);</span>
<span class="nc" id="L208">        boolean result = outer.contains(row);</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if(!result) throw new IndexOutOfBoundsException(&quot;ContainsRowCheck: &quot; + this + &quot; does not contains row &quot; + row);</span>
<span class="nc" id="L210">    }</span>
    public void containsColumnCheck(long column) {
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if(this.isUpperTriangle) throw new UnsupportedOperationException(&quot;not implemented yet&quot;);</span>
<span class="nc" id="L213">        boolean result = inner.contains(column);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if(!result) throw new IndexOutOfBoundsException(&quot;ContainsColumnCheck: &quot; + this + &quot; does not contains column &quot; + column);</span>
<span class="nc" id="L215">    }</span>



    /**
     * Checks whether the provided instance and this instance are equal. Two
     * {@link SquareRange} instances are equal if they share the same upper and lower
     * bounds.
     *
     * @return true if the provided instance and this instance are equal
     */
    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (!(o instanceof SquareRange)) {</span>
<span class="nc" id="L229">            return false;</span>
        }
<span class="nc" id="L231">        final SquareRange sqrange2 = (SquareRange) o;</span>
<span class="nc bnc" id="L232" title="All 8 branches missed.">        return inner.equals(sqrange2.inner) &amp;&amp; outer.equals(sqrange2.outer) &amp;&amp;</span>
                isUpperTriangle==sqrange2.isUpperTriangle &amp;&amp; triangleDiff == sqrange2.triangleDiff;
    }

    // TODO
    // I cannot find a way to convert ConcurrentSkipListMap to TreeSet (or something
    // having
    // floor/ceiling).
    // (I think TreeSet used ConcurrentSkipListMap in its implementation.)
    // prepare TreeSet version of the following methods
    // OR
    // prepare LongRangeSet having such facilities
//    /**
//     * Checks if this instance intersects with one of the keys contained by the
//     * provided {@code ConcurrentSkipListMap&lt;LongRange, S&gt; rmap}. Returns the
//     * smallest of the intersecting keys, or {@code null} if there are no such
//     * intersecting key.
//     *
//     * @param rmap the ConcurrentSkipListMap instance to check
//     * @return a LongRange key of the provided ConcurrentSkipListMap instance that
//     *         intersects this instance, or {@code null} if there are so such key.
//     */
//    public SquareRange findOverlap(ConcurrentSkipListMap&lt;SquareRange, ?&gt; rmap) {
//        final SquareRange floorKey = rmap.floorKey(this);
//        if (floorKey != null &amp;&amp; floorKey.isOverlapped(this)) {
//            return floorKey;
//        }
//        final SquareRange nextKey = rmap.higherKey(this);
//        if (nextKey != null &amp;&amp; nextKey.isOverlapped(this)) {
//            return nextKey;
//        }
//        return null;
//    }

    /**
     * Calls the provided function with every {@code long} index contained in this
     * instance.
     * &lt;p&gt;
     * Calling this function on empty {@link SquareRange} instances will not result in
     * any call to the function.
     *
     * @param func the function to apply with every index of this instance
     */
    public void forEach(SquareIndexConsumer func) {
<span class="fc" id="L276">        outer.forEach((long i)-&gt;{</span>
<span class="fc" id="L277">            columnRange(i).forEach((long j)-&gt;{</span>
<span class="fc" id="L278">                func.accept(i, j);</span>
<span class="fc" id="L279">            });</span>
<span class="fc" id="L280">        });</span>
<span class="fc" id="L281">    }</span>

    /**
     * Returns a hash code for the {@link SquareRange}. The hash-code is generated
     * based on some bit shift operations on the {@link #outer lower} and {@link #inner
     * upper bound} of the {@link SquareRange}.
     *
     * @return hash-code for this instance
     */
    @Override
    public int hashCode() {
<span class="nc" id="L292">        return  ((inner.hashCode() &lt;&lt; 4) + (inner.hashCode() &gt;&gt; 16) + outer.hashCode());</span>
    }



    /**
     * Return the intersection range of this instance and the provided one. If there
     * are no index regions that belongs to either ranges, returns null;
     *
     * @param range the square range whose intersection with this instance is to be checked
     * @return a {@link SquareRange} representing the intersection between this and
     *         the provided instance, {@code null} if there is no intersection
     */
    public SquareRange intersection(SquareRange range) {
<span class="fc" id="L306">        LongRange interOut = outer.intersection(range.outer);</span>
<span class="fc" id="L307">        LongRange interInn = inner.intersection(range.inner);</span>
<span class="pc bpc" id="L308" title="4 of 8 branches missed.">        if (interOut == null || interOut.size()==0 || interInn == null || interInn.size()==0) {</span>
<span class="nc" id="L309">            return null;</span>
        }
<span class="pc bpc" id="L311" title="1 of 4 branches missed.">        boolean isUpper = this.isUpperTriangle || range.isUpperTriangle;</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if(!isUpper) return new SquareRange(interOut, interInn, false);</span>
<span class="pc bpc" id="L313" title="1 of 4 branches missed.">        long triDiff =</span>
                isUpperTriangle?
<span class="pc" id="L315">                        (range.isUpperTriangle? Math.max(triangleDiff, range.triangleDiff): triangleDiff): // TODO min will be used for lowerTriangle</span>
                        range.triangleDiff;
<span class="fc" id="L317">        return new SquareRange(interOut, interInn, isUpper, triDiff).normalizeTriangle();</span>
    }
    private SquareRange normalizeTriangle() {
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if(startColumn(outer.from) &gt;= inner.to) return null;</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if(startColumn(outer.to) &lt; inner.from) return new SquareRange(inner, outer); // normal rec</span>
<span class="fc" id="L322">        return new SquareRange(rowRange(inner.to), columnRange(outer.from-1), true, triangleDiff);</span>
    }
    public SquareRange intersectionCheck(SquareRange subrange) {
<span class="nc" id="L325">        containsCheck(subrange);</span>
        // TODO
        // upper rect care...
<span class="nc" id="L328">        return intersection(subrange);</span>
    }




//    /**
//     * Returns true if the provided {@link SquareRange} and this instance are
//     * overlapped. This operation is symmetric, meaning that calling this method
//     * with two instances a and b, the result produced by {@code a.isOverlapped(b)}
//     * is the same as {@code b.isOverlapped(a)}.
//     * &lt;p&gt;
//     * Two {@link SquareRange} a and b are overlapped if they share some indices, that
//     * is if there exist a {@code long} l such that a.contains(l) and b.contains(l)
//     * return true.
//     * &lt;p&gt;
//     * In cases where an empty {@link SquareRange} and a non-empty {@link SquareRange}
//     * are considered, this method returns true if the lower bound (or upper bound
//     * as it has the same value) of the empty instance is between the lower bound
//     * (included) and the upper bound (excluded) of the other instance.
//     * &lt;p&gt;
//     * If both considered {@link SquareRange} are empty, returns true if they have the
//     * same bounds.
//     *
//     * @param range the range whose overlap with this instance is to be checked
//     * @return true if the provided LongRange and this instance overlap
//     */
//    public boolean isOverlapped(SquareRange range) {
//        if (equals(range)) {
//            return true;
//        } else if (from == to) {
//            return from &gt;= range.from &amp;&amp; from &lt; range.to;
//        } else if (range.from == range.to) {
//            return range.from &gt;= from &amp;&amp; range.from &lt; to;
//        } else {
//            return (from &lt; range.from) ? (to &gt; range.from) : (from &lt; range.to);
//        }
//    }

//    /**
//     * Returns an iterator on the {@code long} indices contained in this instance
//     *
//     * @return a new iterator starting at {@link #from} and whose last value is the
//     *         long preceding {@link #to}
//     */
//    @Override
//    public Iterator&lt;Long&gt; iterator() {
//        return new It();
//    }

//    /**
//     * Returns the size of the LongRange, i.e. how many different indices are
//     * contained between its lower bound and its upper bound. In practice, returns
//     * the difference between {@link #to} and {@link #from}.
//            *
//            * @return size of the {@link SquareRange}
//     */
//    public long size() {
//        return to - from;
//    }

//    /**
//     * Splits the LongRange into &lt;em&gt;n&lt;/em&gt; LongRange instances of equal size (or
//     * near equal size if the size of this instance is not divisible by &lt;em&gt;n&lt;/em&gt;.
//     *
//     * @param n the number of LongRange instance in which to split this instance
//     * @return a list of &lt;em&gt;n&lt;/em&gt; consecutive LongRange instances
//     */
//    public List&lt;SquareRange&gt; split(int n) {
//        final ArrayList&lt;SquareRange&gt; result = new ArrayList&lt;&gt;();
//        final long rem = size() % n;
//        final long quo = size() / n;
//        long c = from;
//
//        for (int i = 0; i &lt; n; i++) {
//            final long given = quo + ((i &lt; rem) ? 1 : 0);
//            result.add(new SquareRange(c, c + given));
//            c += given;
//        }
//        return result;
//    }

//    /**
//     * Streams every {@code long} index contained in this instance.
//     *
//     * @return a {@link LongStream} of every index contained in this instance
//     */
//    public LongStream stream() {
//        return LongStream.range(from, to);
//    }
    public List&lt;SquareRange&gt; split(int outerN, int innerN) {
        // TODO
        // more smart split for upper rectangle
        // lazy way??
<span class="fc" id="L422">        List&lt;SquareRange&gt; results = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L423">        List&lt;LongRange&gt; splitOuters = outer.split(outerN);</span>
<span class="fc" id="L424">        List&lt;LongRange&gt; splitInners = inner.split(innerN);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        for (LongRange out0 : splitOuters) {</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            for (LongRange in0 : splitInners) {</span>
<span class="fc" id="L427">                SquareRange sq = intersection(new SquareRange(out0, in0));</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                if(sq!=null) results.add(sq);</span>
<span class="fc" id="L429">            }</span>
<span class="fc" id="L430">        }</span>
<span class="fc" id="L431">        return results;</span>
    }

    /**
     * Returns this SquareRange printed in the following format:
     * [ outerRange, innerRange ]
     *
     * @return the range of this {@link SquareRange} as &quot;[ outerRange, innerRange] &quot;
     */
    @Override
    public String toString() {
<span class="fc" id="L442">        return &quot;[&quot; + outer + &quot;,&quot; + inner + &quot;]&quot;;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>