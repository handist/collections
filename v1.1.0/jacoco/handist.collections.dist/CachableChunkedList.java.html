<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CachableChunkedList.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">handistCollections</a> &gt; <a href="index.source.html" class="el_package">handist.collections.dist</a> &gt; <span class="el_source">CachableChunkedList.java</span></div><h1>CachableChunkedList.java</h1><pre class="source lang-java linenums">package handist.collections.dist;

import static apgas.Constructs.*;

import java.io.ObjectStreamException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.ConcurrentModificationException;
import java.util.HashMap;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

import apgas.Place;
import apgas.util.GlobalID;
import handist.collections.ChunkedList;
import handist.collections.LongRange;
import handist.collections.RangedList;
import handist.collections.dist.util.LazyObjectReference;
import handist.collections.dist.util.ObjectInput;
import handist.collections.dist.util.ObjectOutput;
import handist.collections.function.DeSerializer;
import handist.collections.function.DeSerializerUsingPlace;
import handist.collections.function.LongTBiConsumer;
import handist.collections.function.SerializableBiConsumer;
import handist.collections.function.Serializer;

public class CachableChunkedList&lt;T&gt; extends DistCol&lt;T&gt; {

//    static class Team&lt;S&gt; extends TeamOperations&lt;S, CachableChunkedList&lt;S&gt;&gt; {
//
//        /**
//         * Super constructor. Needs to be called by all implementations to initialize
//         * the necessary members common to all Team handles.
//         *
//         * @param localObject local handle of the distributed collection
//         */
//        public Team(CachableChunkedList&lt;S&gt; localObject) {
//            super(localObject);
//        }
//        @Override
//        public void gather(Place root) {
//            throw new UnsupportedOperationException(&quot;CachableChunkedList does not support gather().&quot;);
//        }
//        @Override
//        public void teamedBalance(CollectiveMoveManager mm) {
//            throw new UnsupportedOperationException(&quot;CachableChunkedList does not support balance operations.&quot;);
//        }
//    }

<span class="fc" id="L52">    protected ChunkedList&lt;T&gt; shared = new ChunkedList&lt;&gt;();</span>
<span class="fc" id="L53">    protected HashMap&lt;RangedList&lt;T&gt;, Place&gt; shared2owner = new HashMap&lt;&gt;();</span>

    public CachableChunkedList(final TeamedPlaceGroup pg) {
<span class="fc" id="L56">        this(pg, new GlobalID());</span>
<span class="fc" id="L57">    }</span>

    private CachableChunkedList(final TeamedPlaceGroup placeGroup, final GlobalID id) {
<span class="pc" id="L60">        super(placeGroup, id, (TeamedPlaceGroup pg, GlobalID gid) -&gt; new CachableChunkedList&lt;&gt;(pg, gid));</span>
<span class="fc" id="L61">    }</span>

    private void addNewShared(Place owner, List&lt;RangedList&lt;T&gt;&gt; chunks) {
<span class="fc bfc" id="L64" title="All 2 branches covered.">        for (final RangedList&lt;T&gt; chunk : chunks) {</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">            if (!owner.equals(here())) {</span>
<span class="fc" id="L66">                add(chunk);</span>
            }
<span class="fc" id="L68">            shared.add(chunk);</span>
<span class="fc" id="L69">            shared2owner.put(chunk, owner);</span>
<span class="fc" id="L70">        }</span>
<span class="fc" id="L71">    }</span>

    private void addNewShared(Place owner, RangedList&lt;T&gt; chunk) {
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">        if (!owner.equals(here())) {</span>
<span class="nc" id="L75">            add(chunk);</span>
        }
<span class="fc" id="L77">        shared.add(chunk);</span>
<span class="fc" id="L78">        shared2owner.put(chunk, owner);</span>
<span class="fc" id="L79">    }</span>

    public &lt;U&gt; void allreduce(Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack) {
<span class="nc" id="L82">        allreduce(new ArrayList&lt;&gt;(ranges()), pack, unpack); // TODO: not good, copying ranges to arraylist</span>
<span class="nc" id="L83">    }</span>

    public &lt;U&gt; void allreduce(Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack, CollectiveRelocator.Allgather mm) {
<span class="nc" id="L86">        allreduce(new ArrayList&lt;&gt;(ranges()), pack, unpack, mm); // TODO: not good, copying ranges to arraylist</span>
<span class="nc" id="L87">    }</span>

    public &lt;U&gt; void allreduce(List&lt;LongRange&gt; ranges, Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack) {
<span class="fc" id="L90">        final CollectiveRelocator.Allgather mm = new CollectiveRelocator.Allgather(placeGroup());</span>
<span class="fc" id="L91">        allreduce(ranges, pack, unpack, mm);</span>
<span class="fc" id="L92">        mm.execute();</span>
<span class="fc" id="L93">    }</span>

    /**
     * conduct allreduce operation on shared chunks in the given range. Note: please
     * use the same ranges in all the places.
     *
     * @param ranges the list of ranges in which chunks are applied to the
     *               operation.
     * @param pack   the function that receives an element and extracts data that
     *               will be transferred to other places and be reduced by the
     *               unpack operation.
     * @param unpack the function that receives a local element and the transferred
     *               data from each place and conducts reduction operation to the
     *               local element.
     * @param mm     the collective relocator to manage serialize process
     * @param &lt;U&gt;    the type of the extracted data
     */
    public &lt;U&gt; void allreduce(List&lt;LongRange&gt; ranges, Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack,
            CollectiveRelocator.Allgather mm) {
<span class="fc" id="L112">        final List&lt;RangedList&lt;T&gt;&gt; chunks = searchSharedChunks(ranges);</span>
<span class="fc" id="L113">        final Serializer serProcess = (ObjectOutput s) -&gt; {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            for (final RangedList&lt;T&gt; chunk : chunks) {</span>
<span class="fc" id="L115">                chunk.forEach((T elem) -&gt; {</span>
<span class="fc" id="L116">                    s.writeObject(pack.apply(elem));</span>
<span class="fc" id="L117">                });</span>
<span class="fc" id="L118">            }</span>
<span class="fc" id="L119">        };</span>
<span class="fc" id="L120">        final DeSerializerUsingPlace desProcess = (ObjectInput ds, Place place) -&gt; {</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            for (final RangedList&lt;T&gt; chunk : chunks) {</span>
<span class="fc" id="L122">                chunk.forEach((T elem) -&gt; {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L124">                    final U diff = (U) ds.readObject();</span>
<span class="fc" id="L125">                    unpack.accept(elem, diff);</span>
<span class="fc" id="L126">                });</span>
<span class="fc" id="L127">            }</span>
<span class="fc" id="L128">        };</span>
<span class="fc" id="L129">        mm.request(serProcess, desProcess);</span>
<span class="fc" id="L130">    }</span>

    private void assertUnshared(LongRange r) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (!searchSharedChunks(Collections.singletonList(r)).isEmpty()) {</span>
<span class="nc" id="L134">            throw new IllegalStateException(&quot;CachableChunkedList found shared chunks in range: &quot; + r);</span>
        }
<span class="fc" id="L136">    }</span>

    public &lt;U&gt; void bcast(Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack) {
<span class="nc" id="L139">        bcast((LongRange) null, pack, unpack);</span>
<span class="nc" id="L140">    }</span>

    public &lt;U&gt; void bcast(Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack, CollectiveRelocator.Allgather mm) {
<span class="nc" id="L143">        bcast((LongRange) null, pack, unpack, mm);</span>
<span class="nc" id="L144">    }</span>

    public &lt;U&gt; void bcast(List&lt;LongRange&gt; ranges, Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack) {
<span class="nc" id="L147">        final CollectiveRelocator.Allgather mm = new CollectiveRelocator.Allgather(placeGroup());</span>
<span class="nc" id="L148">        bcast(ranges, pack, unpack, mm);</span>
<span class="nc" id="L149">        mm.execute();</span>
<span class="nc" id="L150">    }</span>

    /**
     * conduct broadcast operation on chunks that are already shared within the
     * place group. The user must call each of the broadcast methods of a cachable
     * chunked list in all the place belonging to the place group.
     *
     * @param ranges
     * @param pack
     * @param unpack
     * @param mm
     * @param &lt;U&gt;
     */
    public &lt;U&gt; void bcast(List&lt;LongRange&gt; ranges, Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack,
            CollectiveRelocator.Allgather mm) {
<span class="fc" id="L165">        final List&lt;RangedList&lt;T&gt;&gt; chunks = searchSharedChunks(here(), ranges);</span>
<span class="fc" id="L166">        final Serializer serProcess = (ObjectOutput s) -&gt; {</span>
<span class="fc" id="L167">            s.writeObject(ranges);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            for (final RangedList&lt;T&gt; chunk : chunks) {</span>
<span class="fc" id="L169">                chunk.forEach((T elem) -&gt; {</span>
<span class="fc" id="L170">                    s.writeObject(pack.apply(elem));</span>
<span class="fc" id="L171">                });</span>
<span class="fc" id="L172">            }</span>
<span class="fc" id="L173">        };</span>
<span class="fc" id="L174">        final DeSerializerUsingPlace desProcess = (ObjectInput ds, Place p) -&gt; {</span>
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">            if (p.equals(here())) {</span>
<span class="nc" id="L176">                return;</span>
            }
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L179">            final List&lt;LongRange&gt; rangesX = (List&lt;LongRange&gt;) ds.readObject();</span>
<span class="fc" id="L180">            final List&lt;RangedList&lt;T&gt;&gt; receiving = searchSharedChunks(p, rangesX);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            for (final RangedList&lt;T&gt; chunk : receiving) {</span>
<span class="fc" id="L182">                chunk.forEach((T elem) -&gt; {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L184">                    final U diff = (U) ds.readObject();</span>
<span class="fc" id="L185">                    unpack.accept(elem, diff);</span>
<span class="fc" id="L186">                });</span>
<span class="fc" id="L187">            }</span>
<span class="fc" id="L188">        };</span>
<span class="fc" id="L189">        mm.request(serProcess, desProcess);</span>
<span class="fc" id="L190">    }</span>

    public &lt;U&gt; void bcast(LongRange range, Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack) {
<span class="fc" id="L193">        final CollectiveRelocator.Allgather mm = new CollectiveRelocator.Allgather(placeGroup());</span>
<span class="fc" id="L194">        bcast(range, pack, unpack, mm);</span>
<span class="fc" id="L195">        mm.execute();</span>
<span class="fc" id="L196">    }</span>

    public &lt;U&gt; void bcast(LongRange range, Function&lt;T, U&gt; pack, BiConsumer&lt;T, U&gt; unpack,
            CollectiveRelocator.Allgather mm) {
<span class="fc" id="L200">        bcast(Collections.singletonList(range), pack, unpack, mm);</span>
<span class="fc" id="L201">    }</span>

    @Override
    public void clear() {
        // TODO
        // The super of clear() assums teamed operation of clear();
<span class="nc" id="L207">    }</span>

    private List&lt;RangedList&lt;T&gt;&gt; exportLocalChunks(List&lt;LongRange&gt; ranges) {
        // TODO
        // Should we check the overlaps in ranges?
<span class="fc" id="L212">        final ArrayList&lt;RangedList&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        for (final LongRange range : ranges) {</span>
<span class="fc" id="L214">            forEachChunk(range, (RangedList&lt;T&gt; chunk) -&gt; {</span>
<span class="fc" id="L215">                final LongRange r0 = chunk.getRange();</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                if (range.contains(r0)) {</span>
<span class="fc" id="L217">                    addNewShared(here(), chunk);</span>
<span class="fc" id="L218">                    result.add(chunk);</span>
<span class="pc bpc" id="L219" title="1 of 4 branches missed.">                } else if (r0.from &lt; range.from &amp;&amp; r0.to &gt; range.to) {</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">                    if (attemptSplitChunkAtTwoPoints(range)) {</span>
<span class="nc" id="L221">                        final RangedList&lt;T&gt; c = getChunk(range);</span>
<span class="nc" id="L222">                        addNewShared(here(), c);</span>
<span class="nc" id="L223">                        result.add(c);</span>
<span class="nc" id="L224">                    } else {</span>
<span class="nc" id="L225">                        throw new ConcurrentModificationException();</span>
                    }
                } else {
<span class="fc bfc" id="L228" title="All 2 branches covered.">                    final long splitPoint = (r0.from &gt;= range.from) ? range.to : range.from;</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                    final LongRange rRange = (r0.from &gt;= range.from) ? new LongRange(r0.from, range.to)</span>
                            : new LongRange(range.from, r0.to);
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">                    if (attemptSplitChunkAtSinglePoint(new LongRange(splitPoint))) {</span>
<span class="fc" id="L232">                        final RangedList&lt;T&gt; c = getChunk(rRange);</span>
<span class="fc" id="L233">                        addNewShared(here(), c);</span>
<span class="fc" id="L234">                        result.add(c);</span>
<span class="fc" id="L235">                    } else {</span>
<span class="nc" id="L236">                        throw new ConcurrentModificationException();</span>
                    }
                }
<span class="fc" id="L239">            });</span>
<span class="fc" id="L240">        }</span>
<span class="fc" id="L241">        return result;</span>
    }

    public void forEachSharedChunk(LongRange range, Consumer&lt;RangedList&lt;T&gt;&gt; func) {
<span class="nc" id="L245">        shared.forEachChunk(range, func);</span>
<span class="nc" id="L246">    }</span>

    public void forEachSharedOwner(LongRange range, Consumer&lt;T&gt; func) {
<span class="fc" id="L249">        shared.forEachChunk(range, (RangedList&lt;T&gt; r0) -&gt; {</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (shared2owner.get(r0).equals(here())) {</span>
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">                if (!range.contains(r0.getRange())) {</span>
<span class="fc" id="L252">                    r0 = r0.subList(range);</span>
                }
<span class="fc" id="L254">                r0.forEach(func);</span>
            }
<span class="fc" id="L256">        });</span>
<span class="fc" id="L257">    }</span>

    public void forEachSharedOwner(LongRange range, LongTBiConsumer&lt;T&gt; func) {
<span class="nc" id="L260">        shared.forEachChunk(range, (RangedList&lt;T&gt; r0) -&gt; {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (shared2owner.get(r0).equals(here())) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (!range.contains(r0.getRange())) {</span>
<span class="nc" id="L263">                    r0 = r0.subList(range);</span>
                }
<span class="nc" id="L265">                r0.forEach(func);</span>
            }
<span class="nc" id="L267">        });</span>
<span class="nc" id="L268">    }</span>

    public Place getSharedOwner(RangedList&lt;T&gt; chunk) {
<span class="fc" id="L271">        return shared2owner.get(chunk);</span>
    }

    @Override
    protected void moveAtSync(final List&lt;RangedList&lt;T&gt;&gt; cs, final Place dest, final MoveManager mm) {
        // check or filter out shared ones.
<span class="nc bnc" id="L277" title="All 2 branches missed.">        for (final RangedList&lt;T&gt; c : cs) {</span>
<span class="nc" id="L278">            assertUnshared(c.getRange());</span>
<span class="nc" id="L279">        }</span>
<span class="nc" id="L280">        super.moveAtSync(cs, dest, mm);</span>
<span class="nc" id="L281">    }</span>

    public &lt;U&gt; void reduce(List&lt;LongRange&gt; ranges, Function&lt;T, U&gt; pack, SerializableBiConsumer&lt;T, U&gt; unpack) {
<span class="fc" id="L284">        final CollectiveMoveManager mm = new CollectiveMoveManager(placeGroup());</span>
<span class="fc" id="L285">        reduce(ranges, pack, unpack, mm);</span>
        try {
<span class="fc" id="L287">            mm.sync();</span>
<span class="nc" id="L288">        } catch (final Exception e) {</span>
<span class="nc" id="L289">            e.printStackTrace();</span>
<span class="nc" id="L290">            throw new Error(&quot;Exception raised during CachbleArray#reduce().&quot;);</span>
<span class="fc" id="L291">        }</span>
<span class="fc" id="L292">    }</span>

    public &lt;U&gt; void reduce(List&lt;LongRange&gt; ranges, final Function&lt;T, U&gt; pack, final SerializableBiConsumer&lt;T, U&gt; unpack,
            CollectiveMoveManager mm) {
<span class="fc" id="L296">        final CachableChunkedList&lt;T&gt; toBranch = this;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        for (final Place p : placeGroup().places()) {</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">            if (p.equals(here())) {</span>
<span class="fc" id="L299">                continue;</span>
            }
<span class="fc" id="L301">            final List&lt;RangedList&lt;T&gt;&gt; chunks = searchSharedChunks(p, ranges);</span>
<span class="fc" id="L302">            final Serializer serProcess = (ObjectOutput s) -&gt; {</span>
<span class="fc" id="L303">                s.writeInt(chunks.size());</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                for (final RangedList&lt;T&gt; chunk : chunks) {</span>
<span class="fc" id="L305">                    s.writeObject(chunk.getRange());</span>
<span class="fc" id="L306">                    chunk.forEach((T elem) -&gt; {</span>
<span class="fc" id="L307">                        s.writeObject(pack.apply(elem));</span>
<span class="fc" id="L308">                    });</span>
<span class="fc" id="L309">                }</span>
<span class="fc" id="L310">            };</span>
<span class="fc" id="L311">            final DeSerializer desProcess = (ObjectInput ds) -&gt; {</span>
<span class="fc" id="L312">                final int n = ds.readInt();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L314">                    final LongRange range0 = (LongRange) ds.readObject();</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                    if (!toBranch.containsRange(range0)) {</span>
<span class="nc" id="L316">                        throw new ConcurrentModificationException(</span>
<span class="nc" id="L317">                                &quot;The specified range seems to be remove from &quot; + toBranch + &quot; at &quot; + here());</span>
                    }
<span class="fc" id="L319">                    toBranch.forEach(range0, (T elem) -&gt; {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L321">                        final U diff = (U) ds.readObject();</span>
<span class="fc" id="L322">                        unpack.accept(elem, diff);</span>
<span class="fc" id="L323">                    });</span>
                }
<span class="fc" id="L325">            };</span>
<span class="fc" id="L326">            mm.request(p, serProcess, desProcess);</span>
<span class="fc" id="L327">        }</span>
<span class="fc" id="L328">    }</span>

    @Override
    public RangedList&lt;T&gt; remove(final LongRange r) {
<span class="fc" id="L332">        assertUnshared(r);</span>
<span class="fc" id="L333">        return super.remove(r);</span>
    }

    private List&lt;RangedList&lt;T&gt;&gt; searchSharedChunks(List&lt;LongRange&gt; ranges) {
<span class="fc" id="L337">        final ArrayList&lt;RangedList&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        for (final LongRange range : ranges) {</span>
<span class="fc" id="L339">            shared.forEachChunk(range, (RangedList&lt;T&gt; r0) -&gt; {</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">                if (range.contains(r0.getRange())) {</span>
<span class="nc" id="L341">                    result.add(r0);</span>
                } else {
<span class="fc" id="L343">                    result.add(r0.subList(range));</span>
                }
<span class="fc" id="L345">            });</span>
<span class="fc" id="L346">        }</span>
<span class="fc" id="L347">        return result;</span>
    }

    private List&lt;RangedList&lt;T&gt;&gt; searchSharedChunks(Place owner, List&lt;LongRange&gt; ranges) {
<span class="fc" id="L351">        final ArrayList&lt;RangedList&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">        for (final LongRange range : ranges) {</span>
<span class="fc" id="L353">            shared.forEachChunk(range, (RangedList&lt;T&gt; r0) -&gt; {</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">                if (shared2owner.get(r0).equals(owner)) {</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">                    if (range.contains(r0.getRange())) {</span>
<span class="nc" id="L356">                        result.add(r0);</span>
                    } else {
<span class="fc" id="L358">                        result.add(r0.subList(range));</span>
                    }
                }
<span class="fc" id="L361">            });</span>
<span class="fc" id="L362">        }</span>
<span class="fc" id="L363">        return result;</span>
    }

    @Override
    public void setProxyGenerator(Function&lt;Long, T&gt; func) {
<span class="nc" id="L368">        throw new UnsupportedOperationException(&quot;CachableChunkedList does not support proxy feature.&quot;);</span>
    }

    public void share() {
<span class="nc" id="L372">        final CollectiveRelocator.Allgather mm = new CollectiveRelocator.Allgather(placeGroup());</span>
<span class="nc" id="L373">        share(Collections.singletonList(null), mm);</span>
<span class="nc" id="L374">        mm.execute();</span>
<span class="nc" id="L375">    }</span>

    public void share(CollectiveRelocator.Allgather mm) {
<span class="nc" id="L378">        share(Collections.singletonList(null), mm);</span>
<span class="nc" id="L379">    }</span>

    public void share(List&lt;LongRange&gt; ranges) {
<span class="nc" id="L382">        final CollectiveRelocator.Allgather mm = new CollectiveRelocator.Allgather(placeGroup());</span>
<span class="nc" id="L383">        share(ranges, mm);</span>
<span class="nc" id="L384">        mm.execute();</span>
<span class="nc" id="L385">    }</span>

    /**
     * conduct broadcast operation on chunks that are not shared with other places
     * yet. The user must call each of the share methods of a cachable chunked list
     * in all the place belonging to the place group. This method should not be
     * called simultaneously with other collective methods. The caller place is
     * treated as the owner even if the chunks become shared.
     *
     * Note 1: if you want to share all the local chunks, please call
     * {@code share()}. Note 2: if you want to specify multiple ranges, please use
     * {@code share(List&lt;LongRange&gt;)}. Note 3: if you don't want to share any local
     * chunks from the called place, please specify an empty range or an empty list
     * of ranges. Note 3: if you want to conduct relocate process of multiple
     * cachable chunked lists using the same ObjectOutput(Stream), please prepare an
     * instance of {@link CollectiveRelocator.Allgather} first and call the
     * relocation methods of the cachable chunked lists in the same order specifying
     * the collective relocator as a parameter, and finally call the execute method
     * of the relocator.
     *
     * @param ranges The library scans the ranges and exports (the parts of) the
     *               local chunks in the ranges.
     * @param mm     You can relocate multiple cachable chunked lists using the same
     *               collective relocator, specified with {@code mm}.
     */
    public void share(final List&lt;LongRange&gt; ranges, CollectiveRelocator.Allgather mm) {
<span class="fc" id="L411">        final List&lt;RangedList&lt;T&gt;&gt; chunks = exportLocalChunks(ranges);</span>
<span class="fc" id="L412">        final Serializer serProcess = (ObjectOutput s) -&gt; {</span>
<span class="fc" id="L413">            s.writeObject(chunks);</span>
<span class="fc" id="L414">        };</span>
<span class="fc" id="L415">        final DeSerializerUsingPlace desProcess = (ObjectInput ds, Place sender) -&gt; {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L417">            final List&lt;RangedList&lt;T&gt;&gt; received = (List&lt;RangedList&lt;T&gt;&gt;) ds.readObject();</span>
<span class="fc" id="L418">            addNewShared(sender, received);</span>
<span class="fc" id="L419">        };</span>
<span class="fc" id="L420">        mm.request(serProcess, desProcess);</span>
<span class="fc" id="L421">    }</span>

    public void share(LongRange range) {
<span class="fc" id="L424">        final CollectiveRelocator.Allgather mm = new CollectiveRelocator.Allgather(placeGroup());</span>
<span class="fc" id="L425">        share(Collections.singletonList(range), mm);</span>
<span class="fc" id="L426">        mm.execute();</span>
<span class="fc" id="L427">    }</span>

    public void share(LongRange range, CollectiveRelocator.Allgather mm) {
<span class="nc" id="L430">        share(Collections.singletonList(range), mm);</span>
<span class="nc" id="L431">    }</span>

    public ChunkedList&lt;T&gt; sharedChunks() {
<span class="nc" id="L434">        return new ChunkedList.UnmodifiableView&lt;&gt;(shared);</span>
    }

    @Override
    public Object writeReplace() throws ObjectStreamException {
<span class="fc" id="L439">        final TeamedPlaceGroup pg1 = manager.placeGroup;</span>
<span class="fc" id="L440">        final GlobalID id1 = id();</span>
<span class="fc" id="L441">        return new LazyObjectReference&lt;&gt;(pg1, id1, () -&gt; {</span>
<span class="fc" id="L442">            return new CachableChunkedList&lt;&gt;(pg1, id1);</span>
        });
    }

    // TODO
    // prepare documents for the following methods
    // getSizedistribution: only returns unshared
    // getDistribution: only returns unshared
    // getRangedDistribution: only returns unshared
    // TEAM: only support DistCol methods

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>